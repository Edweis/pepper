{"ast":null,"code":"const {\n  parseOpId,\n  copyObject\n} = require('../src/common');\n\nconst {\n  COLUMN_TYPE,\n  VALUE_TYPE,\n  ACTIONS,\n  OBJECT_TYPE,\n  DOC_OPS_COLUMNS,\n  CHANGE_COLUMNS,\n  DOCUMENT_COLUMNS,\n  encoderByColumnId,\n  decoderByColumnId,\n  makeDecoders,\n  decodeValue,\n  encodeChange,\n  decodeChangeColumns,\n  decodeChangeMeta,\n  decodeChanges,\n  decodeDocumentHeader,\n  encodeDocumentHeader\n} = require('./columnar');\n\nconst MAX_BLOCK_SIZE = 600; // operations\n\nconst BLOOM_BITS_PER_ENTRY = 10,\n      BLOOM_NUM_PROBES = 7; // 1% false positive rate\n\nconst BLOOM_FILTER_SIZE = Math.floor(BLOOM_BITS_PER_ENTRY * MAX_BLOCK_SIZE / 8); // bytes\n\nconst objActorIdx = 0,\n      objCtrIdx = 1,\n      keyActorIdx = 2,\n      keyCtrIdx = 3,\n      keyStrIdx = 4,\n      idActorIdx = 5,\n      idCtrIdx = 6,\n      insertIdx = 7,\n      actionIdx = 8,\n      valLenIdx = 9,\n      valRawIdx = 10,\n      predNumIdx = 13,\n      predActorIdx = 14,\n      predCtrIdx = 15,\n      succNumIdx = 13,\n      succActorIdx = 14,\n      succCtrIdx = 15;\nconst PRED_COLUMN_IDS = CHANGE_COLUMNS.filter(column => ['predNum', 'predActor', 'predCtr'].includes(column.columnName)).map(column => column.columnId);\n/**\n * Updates `objectTree`, which is a tree of nested objects, so that afterwards\n * `objectTree[path[0]][path[1]][...] === value`. Only the root object is mutated, whereas any\n * nested objects are copied before updating. This means that once the root object has been\n * shallow-copied, this function can be used to update it without mutating the previous version.\n */\n\nfunction deepCopyUpdate(objectTree, path, value) {\n  if (path.length === 1) {\n    objectTree[path[0]] = value;\n  } else {\n    let child = Object.assign({}, objectTree[path[0]]);\n    deepCopyUpdate(child, path.slice(1), value);\n    objectTree[path[0]] = child;\n  }\n}\n/**\n * Scans a block of document operations, encoded as columns `docCols`, to find the position at which\n * an operation (or sequence of operations) `ops` should be applied. `actorIds` is the array that\n * maps actor numbers to hexadecimal actor IDs. `resumeInsertion` is true if we're performing a list\n * insertion and we already found the reference element in a previous block, but we reached the end\n * of that previous block while scanning for the actual insertion position, and so we're continuing\n * the scan in a subsequent block.\n *\n * Returns an object with keys:\n * - `found`: false if we were scanning for a reference element in a list but couldn't find it;\n *    true otherwise.\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or applied.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\n\n\nfunction seekWithinBlock(ops, docCols, actorIds, resumeInsertion) {\n  for (let col of docCols) col.decoder.reset();\n\n  const {\n    objActor,\n    objCtr,\n    keyActor,\n    keyCtr,\n    keyStr,\n    idActor,\n    idCtr,\n    insert\n  } = ops;\n  const [\n    /* keyActorD */\n\n    /* keyCtrD */\n\n    /* valLenD */\n\n    /* valRawD */\n\n    /* chldActorD */\n\n    /* chldCtrD */\n  objActorD, objCtrD,,, keyStrD, idActorD, idCtrD, insertD, actionD,,,,, succNumD] = docCols.map(col => col.decoder);\n  let skipCount = 0,\n      visibleCount = 0,\n      elemVisible = false,\n      nextObjActor = null,\n      nextObjCtr = null;\n  let nextIdActor = null,\n      nextIdCtr = null,\n      nextKeyStr = null,\n      nextInsert = null,\n      nextSuccNum = 0; // Seek to the beginning of the object being updated\n\n  if (objCtr !== null && !resumeInsertion) {\n    while (!objCtrD.done || !objActorD.done || !actionD.done) {\n      nextObjCtr = objCtrD.readValue();\n      nextObjActor = actorIds[objActorD.readValue()];\n      actionD.skipValues(1);\n\n      if (nextObjCtr === null || !nextObjActor || nextObjCtr < objCtr || nextObjCtr === objCtr && nextObjActor < objActor) {\n        skipCount += 1;\n      } else {\n        break;\n      }\n    }\n  }\n\n  if ((nextObjCtr !== objCtr || nextObjActor !== objActor) && !resumeInsertion) {\n    return {\n      found: true,\n      skipCount,\n      visibleCount\n    };\n  } // Seek to the appropriate key (if string key is used)\n\n\n  if (keyStr !== null) {\n    keyStrD.skipValues(skipCount);\n\n    while (!keyStrD.done) {\n      const objActorIndex = objActorD.readValue();\n      nextObjActor = objActorIndex === null ? null : actorIds[objActorIndex];\n      nextObjCtr = objCtrD.readValue();\n      nextKeyStr = keyStrD.readValue();\n\n      if (nextKeyStr !== null && nextKeyStr < keyStr && nextObjCtr === objCtr && nextObjActor === objActor) {\n        skipCount += 1;\n      } else {\n        break;\n      }\n    }\n\n    return {\n      found: true,\n      skipCount,\n      visibleCount\n    };\n  }\n\n  idCtrD.skipValues(skipCount);\n  idActorD.skipValues(skipCount);\n  insertD.skipValues(skipCount);\n  succNumD.skipValues(skipCount);\n  nextIdCtr = idCtrD.readValue();\n  nextIdActor = actorIds[idActorD.readValue()];\n  nextInsert = insertD.readValue();\n  nextSuccNum = succNumD.readValue(); // If we are inserting into a list, an opId key is used, and we need to seek to a position *after*\n  // the referenced operation. Moreover, we need to skip over any existing operations with a greater\n  // opId than the new insertion, for CRDT convergence on concurrent insertions in the same place.\n\n  if (insert) {\n    // If insertion is not at the head, search for the reference element\n    if (!resumeInsertion && keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n      skipCount += 1;\n\n      while (!idCtrD.done && !idActorD.done && (nextIdCtr !== keyCtr || nextIdActor !== keyActor)) {\n        if (nextInsert) elemVisible = false;\n\n        if (nextSuccNum === 0 && !elemVisible) {\n          visibleCount += 1;\n          elemVisible = true;\n        }\n\n        nextIdCtr = idCtrD.readValue();\n        nextIdActor = actorIds[idActorD.readValue()];\n        nextObjCtr = objCtrD.readValue();\n        nextObjActor = actorIds[objActorD.readValue()];\n        nextInsert = insertD.readValue();\n        nextSuccNum = succNumD.readValue();\n        if (nextObjCtr === objCtr && nextObjActor === objActor) skipCount += 1;else break;\n      }\n\n      if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr || nextIdActor !== keyActor || !nextInsert) {\n        return {\n          found: false,\n          skipCount,\n          visibleCount\n        };\n      }\n\n      if (nextInsert) elemVisible = false;\n\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1;\n        elemVisible = true;\n      } // Set up the next* variables to the operation following the reference element\n\n\n      if (idCtrD.done || idActorD.done) return {\n        found: true,\n        skipCount,\n        visibleCount\n      };\n      nextIdCtr = idCtrD.readValue();\n      nextIdActor = actorIds[idActorD.readValue()];\n      nextObjCtr = objCtrD.readValue();\n      nextObjActor = actorIds[objActorD.readValue()];\n      nextInsert = insertD.readValue();\n      nextSuccNum = succNumD.readValue();\n    } // Skip over any list elements with greater ID than the new one, and any non-insertions\n\n\n    while ((!nextInsert || nextIdCtr > idCtr || nextIdCtr === idCtr && nextIdActor > idActor) && nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1;\n      if (nextInsert) elemVisible = false;\n\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1;\n        elemVisible = true;\n      }\n\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue();\n        nextIdActor = actorIds[idActorD.readValue()];\n        nextObjCtr = objCtrD.readValue();\n        nextObjActor = actorIds[objActorD.readValue()];\n        nextInsert = insertD.readValue();\n        nextSuccNum = succNumD.readValue();\n      } else {\n        break;\n      }\n    }\n  } else if (keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n    // If we are updating an existing list element, seek to just before the referenced ID\n    while ((!nextInsert || nextIdCtr !== keyCtr || nextIdActor !== keyActor) && nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1;\n      if (nextInsert) elemVisible = false;\n\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1;\n        elemVisible = true;\n      }\n\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue();\n        nextIdActor = actorIds[idActorD.readValue()];\n        nextObjCtr = objCtrD.readValue();\n        nextObjActor = actorIds[objActorD.readValue()];\n        nextInsert = insertD.readValue();\n        nextSuccNum = succNumD.readValue();\n      } else {\n        break;\n      }\n    }\n\n    if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr || nextIdActor !== keyActor || !nextInsert) {\n      return {\n        found: false,\n        skipCount,\n        visibleCount\n      };\n    }\n  }\n\n  return {\n    found: true,\n    skipCount,\n    visibleCount\n  };\n}\n/**\n * Returns the number of list elements that should be added to a list index when skipping over the\n * block with index `blockIndex` in the list object with object ID consisting of actor number\n * `objActorNum` and counter `objCtr`.\n */\n\n\nfunction visibleListElements(docState, blockIndex, objActorNum, objCtr) {\n  const thisBlock = docState.blocks[blockIndex];\n  const nextBlock = docState.blocks[blockIndex + 1];\n\n  if (thisBlock.lastObjectActor !== objActorNum || thisBlock.lastObjectCtr !== objCtr || thisBlock.numVisible === undefined) {\n    return 0; // If a list element is split across the block boundary, don't double-count it\n  } else if (thisBlock.lastVisibleActor === nextBlock.firstVisibleActor && thisBlock.lastVisibleActor !== undefined && thisBlock.lastVisibleCtr === nextBlock.firstVisibleCtr && thisBlock.lastVisibleCtr !== undefined) {\n    return thisBlock.numVisible - 1;\n  } else {\n    return thisBlock.numVisible;\n  }\n}\n/**\n * Scans the blocks of document operations to find the position where a new operation should be\n * inserted. Returns an object with keys:\n * - `blockIndex`: the index of the block into which we should insert the new operation\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or merged.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\n\n\nfunction seekToOp(docState, ops) {\n  const {\n    objActor,\n    objActorNum,\n    objCtr,\n    keyActor,\n    keyCtr,\n    keyStr\n  } = ops;\n  let blockIndex = 0,\n      totalVisible = 0; // Skip any blocks that contain only objects with lower objectIds\n\n  if (objCtr !== null) {\n    while (blockIndex < docState.blocks.length - 1) {\n      const blockActor = docState.blocks[blockIndex].lastObjectActor === undefined ? undefined : docState.actorIds[docState.blocks[blockIndex].lastObjectActor];\n      const blockCtr = docState.blocks[blockIndex].lastObjectCtr;\n\n      if (blockCtr === null || blockCtr < objCtr || blockCtr === objCtr && blockActor < objActor) {\n        blockIndex++;\n      } else {\n        break;\n      }\n    }\n  }\n\n  if (keyStr !== null) {\n    // String key is used. First skip any blocks that contain only lower keys\n    while (blockIndex < docState.blocks.length - 1) {\n      const {\n        lastObjectActor,\n        lastObjectCtr,\n        lastKey\n      } = docState.blocks[blockIndex];\n      if (objCtr === lastObjectCtr && objActorNum === lastObjectActor && lastKey !== undefined && lastKey < keyStr) blockIndex++;else break;\n    } // When we have a candidate block, decode it to find the exact insertion position\n\n\n    const {\n      skipCount\n    } = seekWithinBlock(ops, docState.blocks[blockIndex].columns, docState.actorIds, false);\n    return {\n      blockIndex,\n      skipCount,\n      visibleCount: 0\n    };\n  } else {\n    // List operation\n    const insertAtHead = keyCtr === null || keyCtr === 0 || keyActor === null;\n    const keyActorNum = keyActor === null ? null : docState.actorIds.indexOf(keyActor);\n    let resumeInsertion = false;\n\n    while (true) {\n      // Search for the reference element, skipping any blocks whose Bloom filter does not contain\n      // the reference element. We only do this if not inserting at the head (in which case there is\n      // no reference element), or if we already found the reference element in an earlier block (in\n      // which case we have resumeInsertion === true). The latter case arises with concurrent\n      // insertions at the same position, and so we have to scan beyond the reference element to\n      // find the actual insertion position, and that further scan crosses a block boundary.\n      if (!insertAtHead && !resumeInsertion) {\n        while (blockIndex < docState.blocks.length - 1 && docState.blocks[blockIndex].lastObjectActor === objActorNum && docState.blocks[blockIndex].lastObjectCtr === objCtr && !bloomFilterContains(docState.blocks[blockIndex].bloom, keyActorNum, keyCtr)) {\n          // If we reach the end of the list object without a Bloom filter hit, the reference element\n          // doesn't exist\n          if (docState.blocks[blockIndex].lastObjectCtr > objCtr) {\n            throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`);\n          } // Add up number of visible list elements in any blocks we skip, for list index computation\n\n\n          totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr);\n          blockIndex++;\n        }\n      } // We have a candidate block. Decode it to see whether it really contains the reference element\n\n\n      const {\n        found,\n        skipCount,\n        visibleCount\n      } = seekWithinBlock(ops, docState.blocks[blockIndex].columns, docState.actorIds, resumeInsertion);\n\n      if (blockIndex === docState.blocks.length - 1 || docState.blocks[blockIndex].lastObjectActor !== objActorNum || docState.blocks[blockIndex].lastObjectCtr !== objCtr) {\n        // Last block: if we haven't found the reference element by now, it's an error\n        if (found) {\n          return {\n            blockIndex,\n            skipCount,\n            visibleCount: totalVisible + visibleCount\n          };\n        } else {\n          throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`);\n        }\n      } else if (found && skipCount < docState.blocks[blockIndex].numOps) {\n        // The insertion position lies within the current block\n        return {\n          blockIndex,\n          skipCount,\n          visibleCount: totalVisible + visibleCount\n        };\n      } // Reference element not found and there are still blocks left ==> it was probably a false positive.\n      // Reference element found, but we skipped all the way to the end of the block ==> we need to\n      // continue scanning the next block to find the actual insertion position.\n      // Either way, go back round the loop again to skip blocks until the next Bloom filter hit.\n\n\n      resumeInsertion = found && ops.insert;\n      totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr);\n      blockIndex++;\n    }\n  }\n}\n/**\n * Updates Bloom filter `bloom`, given as a Uint8Array, to contain the list element ID consisting of\n * counter `elemIdCtr` and actor number `elemIdActor`. We don't actually bother computing a hash\n * function, since those two integers serve perfectly fine as input. We turn the two integers into a\n * sequence of probe indexes using the triple hashing algorithm from the following paper:\n *\n * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.\n * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.\n * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf\n */\n\n\nfunction bloomFilterAdd(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength,\n      x = elemIdCtr % modulo,\n      y = elemIdActor % modulo; // Use one step of FNV-1a to compute a third value from the two inputs.\n  // Taken from http://www.isthe.com/chongo/tech/comp/fnv/index.html\n  // The prime is just over 2^24, so elemIdCtr can be up to about 2^29 = 500 million before the\n  // result of the multiplication exceeds 2^53. And even if it does exceed 2^53 and loses precision,\n  // that shouldn't be a problem as it should still be deterministic, and the Bloom filter\n  // computation only needs to be internally consistent within this library.\n\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo;\n\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    bloom[x >>> 3] |= 1 << (x & 7);\n    x = (x + y) % modulo;\n    y = (y + z) % modulo;\n  }\n}\n/**\n * Returns true if the list element ID consisting of counter `elemIdCtr` and actor number\n * `elemIdActor` is likely to be contained in the Bloom filter `bloom`.\n */\n\n\nfunction bloomFilterContains(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength,\n      x = elemIdCtr % modulo,\n      y = elemIdActor % modulo;\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo; // See comments in the bloomFilterAdd function for an explanation\n\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    if ((bloom[x >>> 3] & 1 << (x & 7)) === 0) {\n      return false;\n    }\n\n    x = (x + y) % modulo;\n    y = (y + z) % modulo;\n  }\n\n  return true;\n}\n/**\n * Reads the relevant columns of a block of operations and updates that block to contain the\n * metadata we need to efficiently figure out where to insert new operations.\n */\n\n\nfunction updateBlockMetadata(block) {\n  block.bloom = new Uint8Array(BLOOM_FILTER_SIZE);\n  block.numOps = 0;\n  block.lastKey = undefined;\n  block.numVisible = undefined;\n  block.lastObjectActor = undefined;\n  block.lastObjectCtr = undefined;\n  block.firstVisibleActor = undefined;\n  block.firstVisibleCtr = undefined;\n  block.lastVisibleActor = undefined;\n  block.lastVisibleCtr = undefined;\n\n  for (let col of block.columns) col.decoder.reset();\n\n  const [\n    /* actionD */\n\n    /* valLenD */\n\n    /* valRawD */\n\n    /* chldActorD */\n\n    /* chldCtrD */\n  objActorD, objCtrD, keyActorD, keyCtrD, keyStrD, idActorD, idCtrD, insertD,,,,,, succNumD] = block.columns.map(col => col.decoder);\n\n  while (!idCtrD.done) {\n    block.numOps += 1;\n    const objActor = objActorD.readValue(),\n          objCtr = objCtrD.readValue();\n    const keyActor = keyActorD.readValue(),\n          keyCtr = keyCtrD.readValue(),\n          keyStr = keyStrD.readValue();\n    const idActor = idActorD.readValue(),\n          idCtr = idCtrD.readValue();\n    const insert = insertD.readValue(),\n          succNum = succNumD.readValue();\n\n    if (block.lastObjectActor !== objActor || block.lastObjectCtr !== objCtr) {\n      block.numVisible = 0;\n      block.lastObjectActor = objActor;\n      block.lastObjectCtr = objCtr;\n    }\n\n    if (keyStr !== null) {\n      // Map key: for each object, record the highest key contained in the block\n      block.lastKey = keyStr;\n    } else if (insert || keyCtr !== null) {\n      // List element\n      block.lastKey = undefined;\n      const elemIdActor = insert ? idActor : keyActor;\n      const elemIdCtr = insert ? idCtr : keyCtr;\n      bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr); // If the list element is visible, update the block metadata accordingly\n\n      if (succNum === 0) {\n        if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor;\n        if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr;\n\n        if (block.lastVisibleActor !== elemIdActor || block.lastVisibleCtr !== elemIdCtr) {\n          block.numVisible += 1;\n          block.lastVisibleActor = elemIdActor;\n          block.lastVisibleCtr = elemIdCtr;\n        }\n      }\n    }\n  }\n}\n/**\n * Updates a block's metadata based on an operation being added to a block.\n */\n\n\nfunction addBlockOperation(block, op, actorIds, isChangeOp) {\n  if (op[keyStrIdx] !== null) {\n    // TODO this comparison should use UTF-8 encoding, not JavaScript's UTF-16\n    if (block.lastObjectCtr === op[objCtrIdx] && block.lastObjectActor === op[objActorIdx] && (block.lastKey === undefined || block.lastKey < op[keyStrIdx])) {\n      block.lastKey = op[keyStrIdx];\n    }\n  } else {\n    // List element\n    const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx];\n    const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx];\n    bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr); // Set lastVisible on the assumption that this is the last op in the block; if there are further\n    // ops after this one in the block, lastVisible will be overwritten again later.\n\n    if (op[succNumIdx] === 0 || isChangeOp) {\n      if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor;\n      if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr;\n      block.lastVisibleActor = elemIdActor;\n      block.lastVisibleCtr = elemIdCtr;\n    }\n  } // Keep track of the largest objectId contained within a block\n\n\n  if (block.lastObjectCtr === undefined || op[objActorIdx] !== null && op[objCtrIdx] !== null && (block.lastObjectCtr === null || block.lastObjectCtr < op[objCtrIdx] || block.lastObjectCtr === op[objCtrIdx] && actorIds[block.lastObjectActor] < actorIds[op[objActorIdx]])) {\n    block.lastObjectActor = op[objActorIdx];\n    block.lastObjectCtr = op[objCtrIdx];\n    block.lastKey = op[keyStrIdx] !== null ? op[keyStrIdx] : undefined;\n    block.numVisible = 0;\n  }\n}\n/**\n * Takes a block containing too many operations, and splits it into a sequence of adjacent blocks of\n * roughly equal size.\n */\n\n\nfunction splitBlock(block) {\n  for (let col of block.columns) col.decoder.reset(); // Make each of the resulting blocks between 50% and 80% full (leaving a bit of space in each\n  // block so that it doesn't get split again right away the next time an operation is added).\n  // The upper bound cannot be lower than 75% since otherwise we would end up with a block less than\n  // 50% full when going from two to three blocks.\n\n\n  const numBlocks = Math.ceil(block.numOps / (0.8 * MAX_BLOCK_SIZE));\n  let blocks = [],\n      opsSoFar = 0;\n\n  for (let i = 1; i <= numBlocks; i++) {\n    const opsToCopy = Math.ceil(i * block.numOps / numBlocks) - opsSoFar;\n    const encoders = block.columns.map(col => ({\n      columnId: col.columnId,\n      encoder: encoderByColumnId(col.columnId)\n    }));\n    copyColumns(encoders, block.columns, opsToCopy);\n    const decoders = encoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);\n      return {\n        columnId: col.columnId,\n        decoder\n      };\n    });\n    const newBlock = {\n      columns: decoders\n    };\n    updateBlockMetadata(newBlock);\n    blocks.push(newBlock);\n    opsSoFar += opsToCopy;\n  }\n\n  return blocks;\n}\n/**\n * Takes an array of blocks and concatenates the corresponding columns across all of the blocks.\n */\n\n\nfunction concatBlocks(blocks) {\n  const encoders = blocks[0].columns.map(col => ({\n    columnId: col.columnId,\n    encoder: encoderByColumnId(col.columnId)\n  }));\n\n  for (let block of blocks) {\n    for (let col of block.columns) col.decoder.reset();\n\n    copyColumns(encoders, block.columns, block.numOps);\n  }\n\n  return encoders;\n}\n/**\n * Copies `count` rows from the set of input columns `inCols` to the set of output columns\n * `outCols`. The input columns are given as an array of `{columnId, decoder}` objects, and the\n * output columns are given as an array of `{columnId, encoder}` objects. Both are sorted in\n * increasing order of columnId. If there is no matching input column for a given output column, it\n * is filled in with `count` blank values (according to the column type).\n */\n\n\nfunction copyColumns(outCols, inCols, count) {\n  if (count === 0) return;\n  let inIndex = 0,\n      lastGroup = -1,\n      lastCardinality = 0,\n      valueColumn = -1,\n      valueBytes = 0;\n\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++;\n\n    let inCol = null;\n\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId && inCols[inIndex].decoder.buf.byteLength > 0) {\n      inCol = inCols[inIndex].decoder;\n    }\n\n    const colCount = outCol.columnId >> 4 === lastGroup ? lastCardinality : count;\n\n    if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4;\n\n      if (inCol) {\n        lastCardinality = outCol.encoder.copyFrom(inCol, {\n          count,\n          sumValues: true\n        }).sum;\n      } else {\n        outCol.encoder.appendValue(0, count);\n        lastCardinality = 0;\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n      if (inCol) {\n        if (inIndex + 1 === inCols.length || inCols[inIndex + 1].columnId !== outCol.columnId + 1) {\n          throw new RangeError('VALUE_LEN column without accompanying VALUE_RAW column');\n        }\n\n        valueColumn = outCol.columnId + 1;\n        valueBytes = outCol.encoder.copyFrom(inCol, {\n          count: colCount,\n          sumValues: true,\n          sumShift: 4\n        }).sum;\n      } else {\n        outCol.encoder.appendValue(null, colCount);\n        valueColumn = outCol.columnId + 1;\n        valueBytes = 0;\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (outCol.columnId !== valueColumn) {\n        throw new RangeError('VALUE_RAW column without accompanying VALUE_LEN column');\n      }\n\n      if (valueBytes > 0) {\n        outCol.encoder.appendRawBytes(inCol.readRawBytes(valueBytes));\n      }\n    } else {\n      // ACTOR_ID, INT_RLE, INT_DELTA, BOOLEAN, or STRING_RLE\n      if (inCol) {\n        outCol.encoder.copyFrom(inCol, {\n          count: colCount\n        });\n      } else {\n        const blankValue = outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN ? false : null;\n        outCol.encoder.appendValue(blankValue, colCount);\n      }\n    }\n  }\n}\n/**\n * Parses one operation from a set of columns. The argument `columns` contains a list of objects\n * with `columnId` and `decoder` properties. Returns an array in which the i'th element is the\n * value read from the i'th column in `columns`. Does not interpret datatypes; the only\n * interpretation of values is that if `actorTable` is given, a value `v` in a column of type\n * ACTOR_ID is replaced with `actorTable[v]`.\n */\n\n\nfunction readOperation(columns, actorTable) {\n  let operation = [],\n      colValue,\n      lastGroup = -1,\n      lastCardinality = 0,\n      valueColumn = -1,\n      valueBytes = 0;\n\n  for (let col of columns) {\n    if (col.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (col.columnId !== valueColumn) throw new RangeError('unexpected VALUE_RAW column');\n      colValue = col.decoder.readRawBytes(valueBytes);\n    } else if (col.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = col.columnId >> 4;\n      lastCardinality = col.decoder.readValue() || 0;\n      colValue = lastCardinality;\n    } else if (col.columnId >> 4 === lastGroup) {\n      colValue = [];\n\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1;\n        valueBytes = 0;\n      }\n\n      for (let i = 0; i < lastCardinality; i++) {\n        let value = col.decoder.readValue();\n\n        if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof value === 'number') {\n          value = actorTable[value];\n        }\n\n        if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n          valueBytes += colValue >>> 4;\n        }\n\n        colValue.push(value);\n      }\n    } else {\n      colValue = col.decoder.readValue();\n\n      if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof colValue === 'number') {\n        colValue = actorTable[colValue];\n      }\n\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1;\n        valueBytes = colValue >>> 4;\n      }\n    }\n\n    operation.push(colValue);\n  }\n\n  return operation;\n}\n/**\n * Appends `operation`, in the form returned by `readOperation()`, to the columns in `outCols`. The\n * argument `inCols` provides metadata about the types of columns in `operation`; the value\n * `operation[i]` comes from the column `inCols[i]`.\n */\n\n\nfunction appendOperation(outCols, inCols, operation) {\n  let inIndex = 0,\n      lastGroup = -1,\n      lastCardinality = 0;\n\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++;\n\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId) {\n      const colValue = operation[inIndex];\n\n      if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        lastGroup = outCol.columnId >> 4;\n        lastCardinality = colValue;\n        outCol.encoder.appendValue(colValue);\n      } else if (outCol.columnId >> 4 === lastGroup) {\n        if (!Array.isArray(colValue) || colValue.length !== lastCardinality) {\n          throw new RangeError('bad group value');\n        }\n\n        for (let v of colValue) outCol.encoder.appendValue(v);\n      } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n        if (colValue) outCol.encoder.appendRawBytes(colValue);\n      } else {\n        outCol.encoder.appendValue(colValue);\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4;\n      lastCardinality = 0;\n      outCol.encoder.appendValue(0);\n    } else if (outCol.columnId % 8 !== COLUMN_TYPE.VALUE_RAW) {\n      const count = outCol.columnId >> 4 === lastGroup ? lastCardinality : 1;\n      let blankValue = null;\n      if (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) blankValue = false;\n      if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) blankValue = 0;\n      outCol.encoder.appendValue(blankValue, count);\n    }\n  }\n}\n/**\n * Parses the next operation from block `blockIndex` of the document. Returns an object of the form\n * `{docOp, blockIndex}` where `docOp` is an operation in the form returned by `readOperation()`,\n * and `blockIndex` is the block number to use on the next call (it moves on to the next block when\n * we reach the end of the current block). `docOp` is null if there are no more operations.\n */\n\n\nfunction readNextDocOp(docState, blockIndex) {\n  let block = docState.blocks[blockIndex];\n\n  if (!block.columns[actionIdx].decoder.done) {\n    return {\n      docOp: readOperation(block.columns),\n      blockIndex\n    };\n  } else if (blockIndex === docState.blocks.length - 1) {\n    return {\n      docOp: null,\n      blockIndex\n    };\n  } else {\n    blockIndex += 1;\n    block = docState.blocks[blockIndex];\n\n    for (let col of block.columns) col.decoder.reset();\n\n    return {\n      docOp: readOperation(block.columns),\n      blockIndex\n    };\n  }\n}\n/**\n * Parses the next operation from a sequence of changes. `changeState` serves as the state of this\n * pseudo-iterator, and it is mutated to reflect the new operation. In particular,\n * `changeState.nextOp` is set to the operation that was read, and `changeState.done` is set to true\n * when we have finished reading the last operation in the last change.\n */\n\n\nfunction readNextChangeOp(docState, changeState) {\n  // If we've finished reading one change, move to the next change that contains at least one op\n  while (changeState.changeIndex < changeState.changes.length - 1 && (!changeState.columns || changeState.columns[actionIdx].decoder.done)) {\n    changeState.changeIndex += 1;\n    const change = changeState.changes[changeState.changeIndex];\n    changeState.columns = makeDecoders(change.columns, CHANGE_COLUMNS);\n    changeState.opCtr = change.startOp; // Update docState based on the information in the change\n\n    updateBlockColumns(docState, changeState.columns);\n    const {\n      actorIds,\n      actorTable\n    } = getActorTable(docState.actorIds, change);\n    docState.actorIds = actorIds;\n    changeState.actorTable = actorTable;\n    changeState.actorIndex = docState.actorIds.indexOf(change.actorIds[0]);\n  } // Reached the end of the last change?\n\n\n  if (changeState.columns[actionIdx].decoder.done) {\n    changeState.done = true;\n    changeState.nextOp = null;\n    return;\n  }\n\n  changeState.nextOp = readOperation(changeState.columns, changeState.actorTable);\n  changeState.nextOp[idActorIdx] = changeState.actorIndex;\n  changeState.nextOp[idCtrIdx] = changeState.opCtr;\n  changeState.changes[changeState.changeIndex].maxOp = changeState.opCtr;\n  if (changeState.opCtr > docState.maxOp) docState.maxOp = changeState.opCtr;\n  changeState.opCtr += 1;\n  const op = changeState.nextOp;\n\n  if (op[objCtrIdx] === null && op[objActorIdx] !== null || op[objCtrIdx] !== null && op[objActorIdx] === null) {\n    throw new RangeError(`Mismatched object reference: (${op[objCtrIdx]}, ${op[objActorIdx]})`);\n  }\n\n  if (op[keyCtrIdx] === null && op[keyActorIdx] !== null || op[keyCtrIdx] === 0 && op[keyActorIdx] !== null || op[keyCtrIdx] > 0 && op[keyActorIdx] === null) {\n    throw new RangeError(`Mismatched operation key: (${op[keyCtrIdx]}, ${op[keyActorIdx]})`);\n  }\n}\n\nfunction emptyObjectPatch(objectId, type) {\n  if (type === 'list' || type === 'text') {\n    return {\n      objectId,\n      type,\n      edits: []\n    };\n  } else {\n    return {\n      objectId,\n      type,\n      props: {}\n    };\n  }\n}\n/**\n * Returns true if the two given operation IDs have the same actor ID, and the counter of `id2` is\n * exactly `delta` greater than the counter of `id1`.\n */\n\n\nfunction opIdDelta(id1, id2) {\n  let delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const parsed1 = parseOpId(id1),\n        parsed2 = parseOpId(id2);\n  return parsed1.actorId === parsed2.actorId && parsed1.counter + delta === parsed2.counter;\n}\n/**\n * Appends a list edit operation (insert, update, remove) to an array of existing operations. If the\n * last existing operation can be extended (as a multi-op), we do that.\n */\n\n\nfunction appendEdit(existingEdits, nextEdit) {\n  if (existingEdits.length === 0) {\n    existingEdits.push(nextEdit);\n    return;\n  }\n\n  let lastEdit = existingEdits[existingEdits.length - 1];\n\n  if (lastEdit.action === 'insert' && nextEdit.action === 'insert' && lastEdit.index === nextEdit.index - 1 && lastEdit.value.type === 'value' && nextEdit.value.type === 'value' && lastEdit.elemId === lastEdit.opId && nextEdit.elemId === nextEdit.opId && opIdDelta(lastEdit.elemId, nextEdit.elemId, 1) && lastEdit.value.datatype === nextEdit.value.datatype && typeof lastEdit.value.value === typeof nextEdit.value.value) {\n    lastEdit.action = 'multi-insert';\n    if (nextEdit.value.datatype) lastEdit.datatype = nextEdit.value.datatype;\n    lastEdit.values = [lastEdit.value.value, nextEdit.value.value];\n    delete lastEdit.value;\n    delete lastEdit.opId;\n  } else if (lastEdit.action === 'multi-insert' && nextEdit.action === 'insert' && lastEdit.index + lastEdit.values.length === nextEdit.index && nextEdit.value.type === 'value' && nextEdit.elemId === nextEdit.opId && opIdDelta(lastEdit.elemId, nextEdit.elemId, lastEdit.values.length) && lastEdit.datatype === nextEdit.value.datatype && typeof lastEdit.values[0] === typeof nextEdit.value.value) {\n    lastEdit.values.push(nextEdit.value.value);\n  } else if (lastEdit.action === 'remove' && nextEdit.action === 'remove' && lastEdit.index === nextEdit.index) {\n    lastEdit.count += nextEdit.count;\n  } else {\n    existingEdits.push(nextEdit);\n  }\n}\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. This function appends an UpdateEdit to this array. A conflict is represented by\n * having several consecutive edits with the same index, and this can be realised by calling\n * `appendUpdate` several times for the same list element. On the first such call, `firstUpdate`\n * must be true.\n *\n * It is possible that coincidentally the previous edit (potentially arising from a different\n * change) is for the same index. If this is the case, to avoid accidentally treating consecutive\n * updates for the same index as a conflict, we remove the previous edit for the same index. This is\n * safe because the previous edit is overwritten by the new edit being appended, and we know that\n * it's for the same list elements because there are no intervening insertions/deletions that could\n * have changed the indexes.\n */\n\n\nfunction appendUpdate(edits, index, elemId, opId, value, firstUpdate) {\n  let insert = false;\n\n  if (firstUpdate) {\n    // Pop all edits for the same index off the end of the edits array. This sequence may begin with\n    // either an insert or an update. If it's an insert, we remember that fact, and use it below.\n    while (!insert && edits.length > 0) {\n      const lastEdit = edits[edits.length - 1];\n\n      if ((lastEdit.action === 'insert' || lastEdit.action === 'update') && lastEdit.index === index) {\n        edits.pop();\n        insert = lastEdit.action === 'insert';\n      } else if (lastEdit.action === 'multi-insert' && lastEdit.index + lastEdit.values.length - 1 === index) {\n        lastEdit.values.pop();\n        insert = true;\n      } else {\n        break;\n      }\n    }\n  } // If we popped an insert edit off the edits array, we need to turn the new update into an insert\n  // in order to ensure the list element still gets inserted (just with a new value).\n\n\n  if (insert) {\n    appendEdit(edits, {\n      action: 'insert',\n      index,\n      elemId,\n      opId,\n      value\n    });\n  } else {\n    appendEdit(edits, {\n      action: 'update',\n      index,\n      opId,\n      value\n    });\n  }\n}\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. We assume that there is a suffix of this array that consists of an insertion at\n * position `index`, followed by zero or more UpdateEdits at the same index. This function rewrites\n * that suffix to be all updates instead. This is needed because sometimes when generating a patch\n * we think we are performing a list insertion, but then it later turns out that there was already\n * an existing value at that list element, and so we actually need to do an update, not an insert.\n *\n * If the suffix is preceded by one or more updates at the same index, those earlier updates are\n * removed by `appendUpdate()` to ensure we don't inadvertently treat them as part of the same\n * conflict.\n */\n\n\nfunction convertInsertToUpdate(edits, index, elemId) {\n  let updates = [];\n\n  while (edits.length > 0) {\n    let lastEdit = edits[edits.length - 1];\n\n    if (lastEdit.action === 'insert') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index');\n      updates.unshift(edits.pop());\n      break;\n    } else if (lastEdit.action === 'update') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index');\n      updates.unshift(edits.pop());\n    } else {\n      // It's impossible to encounter a remove edit here because the state machine in\n      // updatePatchProperty() ensures that a property can have either an insert or a remove edit,\n      // but not both. It's impossible to encounter a multi-insert here because multi-inserts always\n      // have equal elemId and opId (i.e. they can only be used for the operation that first inserts\n      // an element, but not for any subsequent assignments to that list element); moreover,\n      // convertInsertToUpdate is only called if an insert action is followed by a non-overwritten\n      // document op. The fact that there is a non-overwritten document op after another op on the\n      // same list element implies that the original insertion op for that list element must be\n      // overwritten, and thus the original insertion op cannot have given rise to a multi-insert.\n      throw new RangeError('last edit has unexpected action');\n    }\n  } // Now take the edits we popped off and push them back onto the list again\n\n\n  let firstUpdate = true;\n\n  for (let update of updates) {\n    appendUpdate(edits, index, elemId, update.opId, update.value, firstUpdate);\n    firstUpdate = false;\n  }\n}\n/**\n * Updates `patches` to reflect the operation `op` within the document with state `docState`.\n * Can be called multiple times if there are multiple operations for the same property (e.g. due\n * to a conflict). `propState` is an object that carries over state between such successive\n * invocations for the same property. If the current object is a list, `listIndex` is the index\n * into that list (counting only visible elements). If the operation `op` was already previously\n * in the document, `oldSuccNum` is the value of `op[succNumIdx]` before the current change was\n * applied (allowing us to determine whether this operation was overwritten or deleted in the\n * current change). `oldSuccNum` must be undefined if the operation came from the current change.\n * If we are creating an incremental patch as a result of applying one or more changes, `newBlock`\n * is the block to which the operations are getting written; we will update the metadata on this\n * block. `newBlock` should be null if we are creating a patch for the whole document.\n */\n\n\nfunction updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex, oldSuccNum) {\n  const isWholeDoc = !newBlock;\n  const type = op[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[op[actionIdx]]] : null;\n  const opId = `${op[idCtrIdx]}@${docState.actorIds[op[idActorIdx]]}`;\n  const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx];\n  const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx];\n  const elemId = op[keyStrIdx] ? op[keyStrIdx] : `${elemIdCtr}@${docState.actorIds[elemIdActor]}`; // When the change contains a new make* operation (i.e. with an even-numbered action), record the\n  // new parent-child relationship in objectMeta. TODO: also handle link/move operations.\n\n  if (op[actionIdx] % 2 === 0 && !docState.objectMeta[opId]) {\n    docState.objectMeta[opId] = {\n      parentObj: objectId,\n      parentKey: elemId,\n      opId,\n      type,\n      children: {}\n    };\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId, opId], {\n      objectId: opId,\n      type,\n      props: {}\n    });\n  } // firstOp is true if the current operation is the first of a sequence of ops for the same key\n\n\n  const firstOp = !propState[elemId];\n  if (!propState[elemId]) propState[elemId] = {\n    visibleOps: [],\n    hasChild: false\n  }; // An operation is overwritten if it is a document operation that has at least one successor\n\n  const isOverwritten = oldSuccNum !== undefined && op[succNumIdx] > 0; // Record all visible values for the property, and whether it has any child object\n\n  if (!isOverwritten) {\n    propState[elemId].visibleOps.push(op);\n    propState[elemId].hasChild = propState[elemId].hasChild || op[actionIdx] % 2 === 0; // even-numbered action == make* operation\n  } // If one or more of the values of the property is a child object, we update objectMeta to store\n  // all of the visible values of the property (even the non-child-object values). Then, when we\n  // subsequently process an update within that child object, we can construct the patch to\n  // contain the conflicting values.\n\n\n  const prevChildren = docState.objectMeta[objectId].children[elemId];\n\n  if (propState[elemId].hasChild || prevChildren && Object.keys(prevChildren).length > 0) {\n    let values = {};\n\n    for (let visible of propState[elemId].visibleOps) {\n      const opId = `${visible[idCtrIdx]}@${docState.actorIds[visible[idActorIdx]]}`;\n\n      if (ACTIONS[visible[actionIdx]] === 'set') {\n        values[opId] = Object.assign({\n          type: 'value'\n        }, decodeValue(visible[valLenIdx], visible[valRawIdx]));\n      } else if (visible[actionIdx] % 2 === 0) {\n        const objType = visible[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[visible[actionIdx]]] : null;\n        values[opId] = emptyObjectPatch(opId, objType);\n      }\n    } // Copy so that objectMeta is not modified if an exception is thrown while applying change\n\n\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId], values);\n  }\n\n  let patchKey, patchValue; // For counters, increment operations are succs to the set operation that created the counter,\n  // but in this case we want to add the values rather than overwriting them.\n\n  if (isOverwritten && ACTIONS[op[actionIdx]] === 'set' && (op[valLenIdx] & 0x0f) === VALUE_TYPE.COUNTER) {\n    // This is the initial set operation that creates a counter. Initialise the counter state\n    // to contain all successors of the set operation. Only if we later find that each of these\n    // successor operations is an increment, we make the counter visible in the patch.\n    if (!propState[elemId]) propState[elemId] = {\n      visibleOps: [],\n      hasChild: false\n    };\n    if (!propState[elemId].counterStates) propState[elemId].counterStates = {};\n    let counterStates = propState[elemId].counterStates;\n    let counterState = {\n      opId,\n      value: decodeValue(op[valLenIdx], op[valRawIdx]).value,\n      succs: {}\n    };\n\n    for (let i = 0; i < op[succNumIdx]; i++) {\n      const succOp = `${op[succCtrIdx][i]}@${docState.actorIds[op[succActorIdx][i]]}`;\n      counterStates[succOp] = counterState;\n      counterState.succs[succOp] = true;\n    }\n  } else if (ACTIONS[op[actionIdx]] === 'inc') {\n    // Incrementing a previously created counter.\n    if (!propState[elemId] || !propState[elemId].counterStates || !propState[elemId].counterStates[opId]) {\n      throw new RangeError(`increment operation ${opId} for unknown counter`);\n    }\n\n    let counterState = propState[elemId].counterStates[opId];\n    counterState.value += decodeValue(op[valLenIdx], op[valRawIdx]).value;\n    delete counterState.succs[opId];\n\n    if (Object.keys(counterState.succs).length === 0) {\n      patchKey = counterState.opId;\n      patchValue = {\n        type: 'value',\n        datatype: 'counter',\n        value: counterState.value\n      }; // TODO if the counter is in a list element, we need to add a 'remove' action when deleted\n    }\n  } else if (!isOverwritten) {\n    // Add the value to the patch if it is not overwritten (i.e. if it has no succs).\n    if (ACTIONS[op[actionIdx]] === 'set') {\n      patchKey = opId;\n      patchValue = Object.assign({\n        type: 'value'\n      }, decodeValue(op[valLenIdx], op[valRawIdx]));\n    } else if (op[actionIdx] % 2 === 0) {\n      // even-numbered action == make* operation\n      if (!patches[opId]) patches[opId] = emptyObjectPatch(opId, type);\n      patchKey = opId;\n      patchValue = patches[opId];\n    }\n  }\n\n  if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, docState.objectMeta[objectId].type);\n  const patch = patches[objectId]; // Updating a list or text object (with elemId key)\n\n  if (op[keyStrIdx] === null) {\n    // If we come across any document op that was previously non-overwritten/non-deleted, that\n    // means the current list element already had a value before this change was applied, and\n    // therefore the current element cannot be an insert. If we already registered an insert, we\n    // have to convert it into an update.\n    if (oldSuccNum === 0 && !isWholeDoc && propState[elemId].action === 'insert') {\n      propState[elemId].action = 'update';\n      convertInsertToUpdate(patch.edits, listIndex, elemId);\n\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1;\n      }\n    }\n\n    if (patchValue) {\n      // If the op has a non-overwritten value and it came from the change, it's an insert.\n      // (It's not necessarily the case that op[insertIdx] is true: if a list element is concurrently\n      // deleted and updated, the node that first processes the deletion and then the update will\n      // observe the update as a re-insertion of the deleted list element.)\n      if (!propState[elemId].action && (oldSuccNum === undefined || isWholeDoc)) {\n        propState[elemId].action = 'insert';\n        appendEdit(patch.edits, {\n          action: 'insert',\n          index: listIndex,\n          elemId,\n          opId: patchKey,\n          value: patchValue\n        });\n\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1;\n        } // If the property has a value and it's not an insert, then it must be an update.\n        // We might have previously registered it as a remove, in which case we convert it to update.\n\n      } else if (propState[elemId].action === 'remove') {\n        let lastEdit = patch.edits[patch.edits.length - 1];\n        if (lastEdit.action !== 'remove') throw new RangeError('last edit has unexpected type');\n        if (lastEdit.count > 1) lastEdit.count -= 1;else patch.edits.pop();\n        propState[elemId].action = 'update';\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, true);\n\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1;\n        }\n      } else {\n        // A 'normal' update\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, !propState[elemId].action);\n        if (!propState[elemId].action) propState[elemId].action = 'update';\n      }\n    } else if (oldSuccNum === 0 && !propState[elemId].action) {\n      // If the property used to have a non-overwritten/non-deleted value, but no longer, it's a remove\n      propState[elemId].action = 'remove';\n      appendEdit(patch.edits, {\n        action: 'remove',\n        index: listIndex,\n        count: 1\n      });\n\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1;\n      }\n    }\n  } else if (patchValue || !isWholeDoc) {\n    // Updating a map or table (with string key)\n    if (firstOp || !patch.props[op[keyStrIdx]]) patch.props[op[keyStrIdx]] = {};\n    if (patchValue) patch.props[op[keyStrIdx]][patchKey] = patchValue;\n  }\n}\n/**\n * Applies operations (from one or more changes) to the document by merging the sequence of change\n * ops into the sequence of document ops. The two inputs are `changeState` and `docState`\n * respectively. Assumes that the decoders of both sets of columns are at the position where we want\n * to start merging. `patches` is mutated to reflect the effect of the change operations. `ops` is\n * the operation sequence to apply (as decoded by `groupRelatedOps()`). `docState` is as\n * documented in `applyOps()`. If the operations are updating a list or text object, `listIndex`\n * is the number of visible elements that precede the position at which we start merging.\n * `blockIndex` is the document block number from which we are currently reading.\n */\n\n\nfunction mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, listIndex, blockIndex) {\n  const firstOp = changeState.nextOp,\n        insert = firstOp[insertIdx];\n  const objActor = firstOp[objActorIdx],\n        objCtr = firstOp[objCtrIdx];\n  const objectId = objActor === null ? '_root' : `${objCtr}@${docState.actorIds[objActor]}`;\n  const idActorIndex = changeState.actorIndex,\n        idActor = docState.actorIds[idActorIndex];\n  let foundListElem = false,\n      elemVisible = false,\n      propState = {},\n      docOp;\n  ({\n    docOp,\n    blockIndex\n  } = readNextDocOp(docState, blockIndex));\n  let docOpsConsumed = docOp === null ? 0 : 1;\n  let docOpOldSuccNum = docOp === null ? 0 : docOp[succNumIdx];\n  let changeOp = null,\n      changeOps = [],\n      changeCols = [],\n      predSeen = [],\n      lastChangeKey = null;\n  changeState.objectIds.add(objectId); // Merge the two inputs: the sequence of ops in the doc, and the sequence of ops in the change.\n  // At each iteration, we either output the doc's op (possibly updated based on the change's ops)\n  // or output an op from the change.\n\n  while (true) {\n    // The array `changeOps` contains operations from the change(s) we're applying. When the array\n    // is empty, we load changes from the change. Typically we load only a single operation at a\n    // time, with two exceptions: 1. all operations that update the same key or list element in the\n    // same object are put into changeOps at the same time (this is needed so that we can update the\n    // succ columns of the document ops correctly); 2. a run of consecutive insertions is also\n    // placed into changeOps in one go.\n    //\n    // When we have processed all the ops in changeOps we try to see whether there are further\n    // operations that we can also process while we're at it. Those operations must be for the same\n    // object, they must be for a key or list element that appears later in the document, they must\n    // either all be insertions or all be non-insertions, and if insertions, they must be\n    // consecutive. If these conditions are satisfied, that means the operations can be processed in\n    // the same pass. If we encounter an operation that does not meet these conditions, we leave\n    // changeOps empty, and this function returns after having processed any remaining document ops.\n    //\n    // Any operations that could not be processed in a single pass remain in changeState; applyOps\n    // will seek to the appropriate position and then call mergeDocChangeOps again.\n    if (changeOps.length === 0) {\n      foundListElem = false;\n      let nextOp = changeState.nextOp;\n\n      while (!changeState.done && nextOp[idActorIdx] === idActorIndex && nextOp[insertIdx] === insert && nextOp[objActorIdx] === firstOp[objActorIdx] && nextOp[objCtrIdx] === firstOp[objCtrIdx]) {\n        // Check if the operation's pred references a previous operation in changeOps\n        const lastOp = changeOps.length > 0 ? changeOps[changeOps.length - 1] : null;\n        let isOverwrite = false;\n\n        for (let i = 0; i < nextOp[predNumIdx]; i++) {\n          for (let prevOp of changeOps) {\n            if (nextOp[predActorIdx][i] === prevOp[idActorIdx] && nextOp[predCtrIdx][i] === prevOp[idCtrIdx]) {\n              isOverwrite = true;\n            }\n          }\n        } // If any of the following `if` statements is true, we add `nextOp` to `changeOps`. If they\n        // are all false, we break out of the loop and stop adding to `changeOps`.\n\n\n        if (nextOp === firstOp) {// First change operation in a mergeDocChangeOps call is always used\n        } else if (insert && lastOp !== null && nextOp[keyStrIdx] === null && nextOp[keyActorIdx] === lastOp[idActorIdx] && nextOp[keyCtrIdx] === lastOp[idCtrIdx]) {// Collect consecutive insertions\n        } else if (!insert && lastOp !== null && nextOp[keyStrIdx] !== null && nextOp[keyStrIdx] === lastOp[keyStrIdx] && !isOverwrite) {// Collect several updates to the same key\n        } else if (!insert && lastOp !== null && nextOp[keyStrIdx] === null && lastOp[keyStrIdx] === null && nextOp[keyActorIdx] === lastOp[keyActorIdx] && nextOp[keyCtrIdx] === lastOp[keyCtrIdx] && !isOverwrite) {// Collect several updates to the same list element\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] === null && docOp && docOp[insertIdx] && docOp[keyStrIdx] === null && docOp[idActorIdx] === nextOp[keyActorIdx] && docOp[idCtrIdx] === nextOp[keyCtrIdx]) {// When updating/deleting list elements, keep going if the next elemId in the change\n          // equals the next elemId in the doc (i.e. we're updating several consecutive elements)\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] !== null && lastChangeKey !== null && lastChangeKey < nextOp[keyStrIdx]) {// Allow a single mergeDocChangeOps call to process changes to several keys in the same\n          // object, provided that they appear in ascending order\n        } else break;\n\n        lastChangeKey = nextOp !== null ? nextOp[keyStrIdx] : null;\n        changeOps.push(changeState.nextOp);\n        changeCols.push(changeState.columns);\n        predSeen.push(new Array(changeState.nextOp[predNumIdx]));\n        readNextChangeOp(docState, changeState);\n        nextOp = changeState.nextOp;\n      }\n    }\n\n    if (changeOps.length > 0) changeOp = changeOps[0];\n    const inCorrectObject = docOp && docOp[objActorIdx] === changeOp[objActorIdx] && docOp[objCtrIdx] === changeOp[objCtrIdx];\n    const keyMatches = docOp && docOp[keyStrIdx] !== null && docOp[keyStrIdx] === changeOp[keyStrIdx];\n    const listElemMatches = docOp && docOp[keyStrIdx] === null && changeOp[keyStrIdx] === null && (!docOp[insertIdx] && docOp[keyActorIdx] === changeOp[keyActorIdx] && docOp[keyCtrIdx] === changeOp[keyCtrIdx] || docOp[insertIdx] && docOp[idActorIdx] === changeOp[keyActorIdx] && docOp[idCtrIdx] === changeOp[keyCtrIdx]); // We keep going until we run out of ops in the change, except that even when we run out, we\n    // keep going until we have processed all doc ops for the current key/list element.\n\n    if (changeOps.length === 0 && !(inCorrectObject && (keyMatches || listElemMatches))) break;\n    let takeDocOp = false,\n        takeChangeOps = 0; // The change operations come first if we are inserting list elements (seekToOp already\n    // determines the correct insertion position), if there is no document operation, if the next\n    // document operation is for a different object, or if the change op's string key is\n    // lexicographically first (TODO check ordering of keys beyond the basic multilingual plane).\n\n    if (insert || !inCorrectObject || docOp[keyStrIdx] === null && changeOp[keyStrIdx] !== null || docOp[keyStrIdx] !== null && changeOp[keyStrIdx] !== null && changeOp[keyStrIdx] < docOp[keyStrIdx]) {\n      // Take the operations from the change\n      takeChangeOps = changeOps.length;\n\n      if (!inCorrectObject && !foundListElem && changeOp[keyStrIdx] === null && !changeOp[insertIdx]) {\n        // This can happen if we first update one list element, then another one earlier in the\n        // list. That is not allowed: list element updates must occur in ascending order.\n        throw new RangeError(\"could not find list element with ID: \" + `${changeOp[keyCtrIdx]}@${docState.actorIds[changeOp[keyActorIdx]]}`);\n      }\n    } else if (keyMatches || listElemMatches || foundListElem) {\n      // The doc operation is for the same key or list element in the same object as the change\n      // ops, so we merge them. First, if any of the change ops' `pred` matches the opId of the\n      // document operation, we update the document operation's `succ` accordingly.\n      for (let opIndex = 0; opIndex < changeOps.length; opIndex++) {\n        const op = changeOps[opIndex];\n\n        for (let i = 0; i < op[predNumIdx]; i++) {\n          if (op[predActorIdx][i] === docOp[idActorIdx] && op[predCtrIdx][i] === docOp[idCtrIdx]) {\n            // Insert into the doc op's succ list such that the lists remains sorted\n            let j = 0;\n\n            while (j < docOp[succNumIdx] && (docOp[succCtrIdx][j] < op[idCtrIdx] || docOp[succCtrIdx][j] === op[idCtrIdx] && docState.actorIds[docOp[succActorIdx][j]] < idActor)) j++;\n\n            docOp[succCtrIdx].splice(j, 0, op[idCtrIdx]);\n            docOp[succActorIdx].splice(j, 0, idActorIndex);\n            docOp[succNumIdx]++;\n            predSeen[opIndex][i] = true;\n            break;\n          }\n        }\n      }\n\n      if (listElemMatches) foundListElem = true;\n\n      if (foundListElem && !listElemMatches) {\n        // If the previous docOp was for the correct list element, and the current docOp is for\n        // the wrong list element, then place the current changeOp before the docOp.\n        takeChangeOps = changeOps.length;\n      } else if (changeOps.length === 0 || docOp[idCtrIdx] < changeOp[idCtrIdx] || docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] < idActor) {\n        // When we have several operations for the same object and the same key, we want to keep\n        // them sorted in ascending order by opId. Here we have docOp with a lower opId, so we\n        // output it first.\n        takeDocOp = true;\n        updatePatchProperty(patches, newBlock, objectId, docOp, docState, propState, listIndex, docOpOldSuccNum); // A deletion op in the change is represented in the document only by its entries in the\n        // succ list of the operations it overwrites; it has no separate row in the set of ops.\n\n        for (let i = changeOps.length - 1; i >= 0; i--) {\n          let deleted = true;\n\n          for (let j = 0; j < changeOps[i][predNumIdx]; j++) {\n            if (!predSeen[i][j]) deleted = false;\n          }\n\n          if (ACTIONS[changeOps[i][actionIdx]] === 'del' && deleted) {\n            changeOps.splice(i, 1);\n            changeCols.splice(i, 1);\n            predSeen.splice(i, 1);\n          }\n        }\n      } else if (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] === idActor) {\n        throw new RangeError(`duplicate operation ID: ${changeOp[idCtrIdx]}@${idActor}`);\n      } else {\n        // The changeOp has the lower opId, so we output it first.\n        takeChangeOps = 1;\n      }\n    } else {\n      // The document operation comes first if its string key is lexicographically first, or if\n      // we're using opId keys and the keys don't match (i.e. we scan the document until we find a\n      // matching key).\n      takeDocOp = true;\n    }\n\n    if (takeDocOp) {\n      appendOperation(outCols, docState.blocks[blockIndex].columns, docOp);\n      addBlockOperation(newBlock, docOp, docState.actorIds, false);\n\n      if (docOp[insertIdx] && elemVisible) {\n        elemVisible = false;\n        listIndex++;\n      }\n\n      if (docOp[succNumIdx] === 0) elemVisible = true;\n      newBlock.numOps++;\n      ({\n        docOp,\n        blockIndex\n      } = readNextDocOp(docState, blockIndex));\n\n      if (docOp !== null) {\n        docOpsConsumed++;\n        docOpOldSuccNum = docOp[succNumIdx];\n      }\n    }\n\n    if (takeChangeOps > 0) {\n      for (let i = 0; i < takeChangeOps; i++) {\n        let op = changeOps[i]; // Check that we've seen all ops mentioned in `pred` (they must all have lower opIds than\n        // the change op's own opId, so we must have seen them already)\n\n        for (let j = 0; j < op[predNumIdx]; j++) {\n          if (!predSeen[i][j]) {\n            throw new RangeError(`no matching operation for pred: ${op[predCtrIdx][j]}@${docState.actorIds[op[predActorIdx][j]]}`);\n          }\n        }\n\n        appendOperation(outCols, changeCols[i], op);\n        addBlockOperation(newBlock, op, docState.actorIds, true);\n        updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex);\n\n        if (op[insertIdx]) {\n          elemVisible = false;\n          listIndex++;\n        } else {\n          elemVisible = true;\n        }\n      }\n\n      if (takeChangeOps === changeOps.length) {\n        changeOps.length = 0;\n        changeCols.length = 0;\n        predSeen.length = 0;\n      } else {\n        changeOps.splice(0, takeChangeOps);\n        changeCols.splice(0, takeChangeOps);\n        predSeen.splice(0, takeChangeOps);\n      }\n\n      newBlock.numOps += takeChangeOps;\n    }\n  }\n\n  if (docOp) {\n    appendOperation(outCols, docState.blocks[blockIndex].columns, docOp);\n    newBlock.numOps++;\n    addBlockOperation(newBlock, docOp, docState.actorIds, false);\n  }\n\n  return {\n    docOpsConsumed,\n    blockIndex\n  };\n}\n/**\n * Applies operations from the change (or series of changes) in `changeState` to the document\n * `docState`. Passing `changeState` to `readNextChangeOp` allows iterating over the change ops.\n * `docState` is an object with keys:\n *   - `actorIds` is an array of actorIds (as hex strings) occurring in the document (values in\n *     the document's objActor/keyActor/idActor/... columns are indexes into this array).\n *   - `blocks` is an array of all the blocks of operations in the document.\n *   - `objectMeta` is a map from objectId to metadata about that object.\n *\n * `docState` is mutated to contain the updated document state.\n * `patches` is a patch object that is mutated to reflect the operations applied by this function.\n */\n\n\nfunction applyOps(patches, changeState, docState) {\n  const [objActorNum, objCtr, keyActorNum, keyCtr, keyStr, idActorNum, idCtr, insert] = changeState.nextOp;\n  const objActor = objActorNum === null ? null : docState.actorIds[objActorNum];\n  const keyActor = keyActorNum === null ? null : docState.actorIds[keyActorNum];\n  const ops = {\n    objActor,\n    objActorNum,\n    objCtr,\n    keyActor,\n    keyActorNum,\n    keyCtr,\n    keyStr,\n    idActor: docState.actorIds[idActorNum],\n    idCtr,\n    insert,\n    objId: objActor === null ? '_root' : `${objCtr}@${objActor}`\n  };\n  const {\n    blockIndex,\n    skipCount,\n    visibleCount\n  } = seekToOp(docState, ops);\n  const block = docState.blocks[blockIndex];\n\n  for (let col of block.columns) col.decoder.reset();\n\n  const resetFirstVisible = skipCount === 0 || block.firstVisibleActor === undefined || !insert && block.firstVisibleActor === keyActorNum && block.firstVisibleCtr === keyCtr;\n  const newBlock = {\n    columns: undefined,\n    bloom: new Uint8Array(block.bloom),\n    numOps: skipCount,\n    lastKey: block.lastKey,\n    numVisible: block.numVisible,\n    lastObjectActor: block.lastObjectActor,\n    lastObjectCtr: block.lastObjectCtr,\n    firstVisibleActor: resetFirstVisible ? undefined : block.firstVisibleActor,\n    firstVisibleCtr: resetFirstVisible ? undefined : block.firstVisibleCtr,\n    lastVisibleActor: undefined,\n    lastVisibleCtr: undefined\n  }; // Copy the operations up to the insertion position (the first skipCount operations)\n\n  const outCols = block.columns.map(col => ({\n    columnId: col.columnId,\n    encoder: encoderByColumnId(col.columnId)\n  }));\n  copyColumns(outCols, block.columns, skipCount); // Apply the operations from the change. This may cause blockIndex to move forwards if the\n  // property being updated straddles a block boundary.\n\n  const {\n    blockIndex: lastBlockIndex,\n    docOpsConsumed\n  } = mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, visibleCount, blockIndex); // Copy the remaining operations after the insertion position\n\n  const lastBlock = docState.blocks[lastBlockIndex];\n  let copyAfterMerge = -skipCount - docOpsConsumed;\n\n  for (let i = blockIndex; i <= lastBlockIndex; i++) copyAfterMerge += docState.blocks[i].numOps;\n\n  copyColumns(outCols, lastBlock.columns, copyAfterMerge);\n  newBlock.numOps += copyAfterMerge;\n\n  for (let col of lastBlock.columns) {\n    if (!col.decoder.done) throw new RangeError(`excess ops in column ${col.columnId}`);\n  }\n\n  newBlock.columns = outCols.map(col => {\n    const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);\n    return {\n      columnId: col.columnId,\n      decoder\n    };\n  });\n\n  if (blockIndex === lastBlockIndex && newBlock.numOps <= MAX_BLOCK_SIZE) {\n    // The result is just one output block\n    if (copyAfterMerge > 0 && block.lastVisibleActor !== undefined && block.lastVisibleCtr !== undefined) {\n      // It's possible that none of the ops after the merge point are visible, in which case the\n      // lastVisible may not be strictly correct, because it may refer to an operation before the\n      // merge point rather than a list element inserted by the current change. However, this doesn't\n      // matter, because the only purpose for which we need it is to check whether one block ends with\n      // the same visible element as the next block starts with (to avoid double-counting its index);\n      // if the last list element of a block is invisible, the exact value of lastVisible doesn't\n      // matter since it will be different from the next block's firstVisible in any case.\n      newBlock.lastVisibleActor = block.lastVisibleActor;\n      newBlock.lastVisibleCtr = block.lastVisibleCtr;\n    }\n\n    docState.blocks[blockIndex] = newBlock;\n  } else {\n    // Oversized output block must be split into smaller blocks\n    const newBlocks = splitBlock(newBlock);\n    docState.blocks.splice(blockIndex, lastBlockIndex - blockIndex + 1, ...newBlocks);\n  }\n}\n/**\n * Updates the columns in a document's operation blocks to contain all the columns in a change\n * (including any column types we don't recognise, which have been generated by a future version\n * of Automerge).\n */\n\n\nfunction updateBlockColumns(docState, changeCols) {\n  // Check that the columns of a change appear at the index at which we expect them to be\n  if (changeCols[objActorIdx].columnId !== CHANGE_COLUMNS[objActorIdx].columnId || CHANGE_COLUMNS[objActorIdx].columnName !== 'objActor' || changeCols[objCtrIdx].columnId !== CHANGE_COLUMNS[objCtrIdx].columnId || CHANGE_COLUMNS[objCtrIdx].columnName !== 'objCtr' || changeCols[keyActorIdx].columnId !== CHANGE_COLUMNS[keyActorIdx].columnId || CHANGE_COLUMNS[keyActorIdx].columnName !== 'keyActor' || changeCols[keyCtrIdx].columnId !== CHANGE_COLUMNS[keyCtrIdx].columnId || CHANGE_COLUMNS[keyCtrIdx].columnName !== 'keyCtr' || changeCols[keyStrIdx].columnId !== CHANGE_COLUMNS[keyStrIdx].columnId || CHANGE_COLUMNS[keyStrIdx].columnName !== 'keyStr' || changeCols[idActorIdx].columnId !== CHANGE_COLUMNS[idActorIdx].columnId || CHANGE_COLUMNS[idActorIdx].columnName !== 'idActor' || changeCols[idCtrIdx].columnId !== CHANGE_COLUMNS[idCtrIdx].columnId || CHANGE_COLUMNS[idCtrIdx].columnName !== 'idCtr' || changeCols[insertIdx].columnId !== CHANGE_COLUMNS[insertIdx].columnId || CHANGE_COLUMNS[insertIdx].columnName !== 'insert' || changeCols[actionIdx].columnId !== CHANGE_COLUMNS[actionIdx].columnId || CHANGE_COLUMNS[actionIdx].columnName !== 'action' || changeCols[valLenIdx].columnId !== CHANGE_COLUMNS[valLenIdx].columnId || CHANGE_COLUMNS[valLenIdx].columnName !== 'valLen' || changeCols[valRawIdx].columnId !== CHANGE_COLUMNS[valRawIdx].columnId || CHANGE_COLUMNS[valRawIdx].columnName !== 'valRaw' || changeCols[predNumIdx].columnId !== CHANGE_COLUMNS[predNumIdx].columnId || CHANGE_COLUMNS[predNumIdx].columnName !== 'predNum' || changeCols[predActorIdx].columnId !== CHANGE_COLUMNS[predActorIdx].columnId || CHANGE_COLUMNS[predActorIdx].columnName !== 'predActor' || changeCols[predCtrIdx].columnId !== CHANGE_COLUMNS[predCtrIdx].columnId || CHANGE_COLUMNS[predCtrIdx].columnName !== 'predCtr') {\n    throw new RangeError('unexpected columnId');\n  } // Check if there any columns in the change that are not in the document, apart from pred*\n\n\n  const docCols = docState.blocks[0].columns;\n\n  if (!changeCols.every(changeCol => PRED_COLUMN_IDS.includes(changeCol.columnId) || docCols.find(docCol => docCol.columnId === changeCol.columnId))) {\n    let allCols = docCols.map(docCol => ({\n      columnId: docCol.columnId\n    }));\n\n    for (let changeCol of changeCols) {\n      const {\n        columnId\n      } = changeCol;\n\n      if (!PRED_COLUMN_IDS.includes(columnId) && !docCols.find(docCol => docCol.columnId === columnId)) {\n        allCols.push({\n          columnId\n        });\n      }\n    }\n\n    allCols.sort((a, b) => a.columnId - b.columnId);\n\n    for (let blockIndex = 0; blockIndex < docState.blocks.length; blockIndex++) {\n      let block = copyObject(docState.blocks[blockIndex]);\n      block.columns = makeDecoders(block.columns.map(col => ({\n        columnId: col.columnId,\n        buffer: col.decoder.buf\n      })), allCols);\n      docState.blocks[blockIndex] = block;\n    }\n  }\n}\n/**\n * Takes a decoded change header, including an array of actorIds. Returns an object of the form\n * `{actorIds, actorTable}`, where `actorIds` is an updated array of actorIds appearing in the\n * document (including the new change's actorId). `actorTable` is an array of integers where\n * `actorTable[i]` contains the document's actor index for the actor that has index `i` in the\n * change (`i == 0` is the author of the change).\n */\n\n\nfunction getActorTable(actorIds, change) {\n  if (actorIds.indexOf(change.actorIds[0]) < 0) {\n    if (change.seq !== 1) {\n      throw new RangeError(`Seq ${change.seq} is the first change for actor ${change.actorIds[0]}`);\n    } // Use concat, not push, so that the original array is not mutated\n\n\n    actorIds = actorIds.concat([change.actorIds[0]]);\n  }\n\n  const actorTable = []; // translate from change's actor index to doc's actor index\n\n  for (let actorId of change.actorIds) {\n    const index = actorIds.indexOf(actorId);\n\n    if (index < 0) {\n      throw new RangeError(`actorId ${actorId} is not known to document`);\n    }\n\n    actorTable.push(index);\n  }\n\n  return {\n    actorIds,\n    actorTable\n  };\n}\n/**\n * Finalises the patch for a change. `patches` is a map from objectIds to patch for that\n * particular object, `objectIds` is the array of IDs of objects that are created or updated in the\n * change, and `docState` is an object containing various bits of document state, including\n * `objectMeta`, a map from objectIds to metadata about that object (such as its parent in the\n * document tree). Mutates `patches` such that child objects are linked into their parent object,\n * all the way to the root object.\n */\n\n\nfunction setupPatches(patches, objectIds, docState) {\n  for (let objectId of objectIds) {\n    let meta = docState.objectMeta[objectId],\n        childMeta = null,\n        patchExists = false;\n\n    while (true) {\n      const hasChildren = childMeta && Object.keys(meta.children[childMeta.parentKey]).length > 0;\n      if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, meta.type);\n\n      if (childMeta && hasChildren) {\n        if (meta.type === 'list' || meta.type === 'text') {\n          // In list/text objects, parentKey is an elemID. First see if it already appears in an edit\n          for (let edit of patches[objectId].edits) {\n            if (edit.opId && meta.children[childMeta.parentKey][edit.opId]) {\n              patchExists = true;\n            }\n          } // If we need to add an edit, we first have to translate the elemId into an index\n\n\n          if (!patchExists) {\n            const obj = parseOpId(objectId),\n                  elem = parseOpId(childMeta.parentKey);\n            const seekPos = {\n              objActor: obj.actorId,\n              objCtr: obj.counter,\n              keyActor: elem.actorId,\n              keyCtr: elem.counter,\n              objActorNum: docState.actorIds.indexOf(obj.actorId),\n              keyActorNum: docState.actorIds.indexOf(elem.actorId),\n              keyStr: null,\n              insert: false,\n              objId: objectId\n            };\n            const {\n              visibleCount\n            } = seekToOp(docState, seekPos);\n\n            for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n              let patchValue = value;\n\n              if (value.objectId) {\n                if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type);\n                patchValue = patches[value.objectId];\n              }\n\n              const edit = {\n                action: 'update',\n                index: visibleCount,\n                opId,\n                value: patchValue\n              };\n              appendEdit(patches[objectId].edits, edit);\n            }\n          }\n        } else {\n          // Non-list object: parentKey is the name of the property being updated (a string)\n          if (!patches[objectId].props[childMeta.parentKey]) {\n            patches[objectId].props[childMeta.parentKey] = {};\n          }\n\n          let values = patches[objectId].props[childMeta.parentKey];\n\n          for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n            if (values[opId]) {\n              patchExists = true;\n            } else if (value.objectId) {\n              if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type);\n              values[opId] = patches[value.objectId];\n            } else {\n              values[opId] = value;\n            }\n          }\n        }\n      }\n\n      if (patchExists || !meta.parentObj || childMeta && !hasChildren) break;\n      childMeta = meta;\n      objectId = meta.parentObj;\n      meta = docState.objectMeta[objectId];\n    }\n  }\n\n  return patches;\n}\n/**\n * Takes an array of decoded changes and applies them to a document. `docState` contains a bunch of\n * fields describing the document state. This function mutates `docState` to contain the updated\n * document state, and mutates `patches` to contain a patch to return to the frontend. Only the\n * top-level `docState` object is mutated; all nested objects within it are treated as immutable.\n * `objectIds` is mutated to contain the IDs of objects that are updated in any of the changes.\n *\n * The function detects duplicate changes that we've already applied by looking up each change's\n * hash in `docState.changeIndexByHash`. If we deferred the hash graph computation, that structure\n * will be incomplete, and we run the risk of applying the same change twice. However, we still have\n * the sequence numbers for detecting duplicates. If `throwExceptions` is true, we assume that the\n * set of change hashes is complete, and therefore a duplicate sequence number indicates illegal\n * behaviour. If `throwExceptions` is false, and we detect a possible sequence number reuse, we\n * don't throw an exception but instead enqueue all of the changes. This gives us a chance to\n * recompute the hash graph and eliminate duplicates before raising an error to the application.\n *\n * Returns a two-element array `[applied, enqueued]`, where `applied` is an array of changes that\n * have been applied to the document, and `enqueued` is an array of changes that have not yet been\n * applied because they are missing a dependency.\n */\n\n\nfunction applyChanges(patches, decodedChanges, docState, objectIds, throwExceptions) {\n  let heads = new Set(docState.heads),\n      changeHashes = new Set();\n  let clock = copyObject(docState.clock);\n  let applied = [],\n      enqueued = [];\n\n  for (let change of decodedChanges) {\n    // Skip any duplicate changes that we have already seen\n    if (docState.changeIndexByHash[change.hash] !== undefined || changeHashes.has(change.hash)) continue;\n    const expectedSeq = (clock[change.actor] || 0) + 1;\n    let causallyReady = true;\n\n    for (let dep of change.deps) {\n      const depIndex = docState.changeIndexByHash[dep];\n\n      if ((depIndex === undefined || depIndex === -1) && !changeHashes.has(dep)) {\n        causallyReady = false;\n      }\n    }\n\n    if (!causallyReady) {\n      enqueued.push(change);\n    } else if (change.seq < expectedSeq) {\n      if (throwExceptions) {\n        throw new RangeError(`Reuse of sequence number ${change.seq} for actor ${change.actor}`);\n      } else {\n        return [[], decodedChanges];\n      }\n    } else if (change.seq > expectedSeq) {\n      throw new RangeError(`Skipped sequence number ${expectedSeq} for actor ${change.actor}`);\n    } else {\n      clock[change.actor] = change.seq;\n      changeHashes.add(change.hash);\n\n      for (let dep of change.deps) heads.delete(dep);\n\n      heads.add(change.hash);\n      applied.push(change);\n    }\n  }\n\n  if (applied.length > 0) {\n    let changeState = {\n      changes: applied,\n      changeIndex: -1,\n      objectIds\n    };\n    readNextChangeOp(docState, changeState);\n\n    while (!changeState.done) applyOps(patches, changeState, docState);\n\n    docState.heads = [...heads].sort();\n    docState.clock = clock;\n  }\n\n  return [applied, enqueued];\n}\n/**\n * Scans the operations in a document and generates a patch that can be sent to the frontend to\n * instantiate the current state of the document. `objectMeta` is mutated to contain information\n * about the parent and children of each object in the document.\n */\n\n\nfunction documentPatch(docState) {\n  for (let col of docState.blocks[0].columns) col.decoder.reset();\n\n  let propState = {},\n      docOp = null,\n      blockIndex = 0;\n  let patches = {\n    _root: {\n      objectId: '_root',\n      type: 'map',\n      props: {}\n    }\n  };\n  let lastObjActor = null,\n      lastObjCtr = null,\n      objectId = '_root',\n      elemVisible = false,\n      listIndex = 0;\n\n  while (true) {\n    ({\n      docOp,\n      blockIndex\n    } = readNextDocOp(docState, blockIndex));\n    if (docOp === null) break;\n\n    if (docOp[objActorIdx] !== lastObjActor || docOp[objCtrIdx] !== lastObjCtr) {\n      objectId = `${docOp[objCtrIdx]}@${docState.actorIds[docOp[objActorIdx]]}`;\n      lastObjActor = docOp[objActorIdx];\n      lastObjCtr = docOp[objCtrIdx];\n      propState = {};\n      listIndex = 0;\n      elemVisible = false;\n    }\n\n    if (docOp[insertIdx] && elemVisible) {\n      elemVisible = false;\n      listIndex++;\n    }\n\n    if (docOp[succNumIdx] === 0) elemVisible = true;\n    if (docOp[idCtrIdx] > docState.maxOp) docState.maxOp = docOp[idCtrIdx];\n\n    for (let i = 0; i < docOp[succNumIdx]; i++) {\n      if (docOp[succCtrIdx][i] > docState.maxOp) docState.maxOp = docOp[succCtrIdx][i];\n    }\n\n    updatePatchProperty(patches, null, objectId, docOp, docState, propState, listIndex, docOp[succNumIdx]);\n  }\n\n  return patches._root;\n}\n/**\n * Takes an encoded document whose headers have been parsed using `decodeDocumentHeader()` and reads\n * from it the list of changes. Returns the document's current vector clock, i.e. an object mapping\n * each actor ID (as a hex string) to the number of changes seen from that actor. Also returns an\n * array of the actorIds whose most recent change has no dependents (i.e. the actors that\n * contributed the current heads of the document), and an array of encoders that has been\n * initialised to contain the columns of the changes list.\n */\n\n\nfunction readDocumentChanges(doc) {\n  const columns = makeDecoders(doc.changesColumns, DOCUMENT_COLUMNS);\n  const actorD = columns[0].decoder,\n        seqD = columns[1].decoder;\n  const depsNumD = columns[5].decoder,\n        depsIndexD = columns[6].decoder;\n\n  if (columns[0].columnId !== DOCUMENT_COLUMNS[0].columnId || DOCUMENT_COLUMNS[0].columnName !== 'actor' || columns[1].columnId !== DOCUMENT_COLUMNS[1].columnId || DOCUMENT_COLUMNS[1].columnName !== 'seq' || columns[5].columnId !== DOCUMENT_COLUMNS[5].columnId || DOCUMENT_COLUMNS[5].columnName !== 'depsNum' || columns[6].columnId !== DOCUMENT_COLUMNS[6].columnId || DOCUMENT_COLUMNS[6].columnName !== 'depsIndex') {\n    throw new RangeError('unexpected columnId');\n  }\n\n  let numChanges = 0,\n      clock = {},\n      actorNums = [],\n      headIndexes = new Set();\n\n  while (!actorD.done) {\n    const actorNum = actorD.readValue(),\n          seq = seqD.readValue(),\n          depsNum = depsNumD.readValue();\n    const actorId = doc.actorIds[actorNum];\n\n    if (seq !== 1 && seq !== clock[actorId] + 1) {\n      throw new RangeError(`Expected seq ${clock[actorId] + 1}, got ${seq} for actor ${actorId}`);\n    }\n\n    actorNums.push(actorNum);\n    clock[actorId] = seq;\n    headIndexes.add(numChanges);\n\n    for (let j = 0; j < depsNum; j++) headIndexes.delete(depsIndexD.readValue());\n\n    numChanges++;\n  }\n\n  const headActors = [...headIndexes].map(index => doc.actorIds[actorNums[index]]).sort();\n\n  for (let col of columns) col.decoder.reset();\n\n  const encoders = columns.map(col => ({\n    columnId: col.columnId,\n    encoder: encoderByColumnId(col.columnId)\n  }));\n  copyColumns(encoders, columns, numChanges);\n  return {\n    clock,\n    headActors,\n    encoders,\n    numChanges\n  };\n}\n/**\n * Records the metadata about a change in the appropriate columns.\n */\n\n\nfunction appendChange(columns, change, actorIds, changeIndexByHash) {\n  appendOperation(columns, DOCUMENT_COLUMNS, [actorIds.indexOf(change.actor), // actor\n  change.seq, // seq\n  change.maxOp, // maxOp\n  change.time, // time\n  change.message, // message\n  change.deps.length, // depsNum\n  change.deps.map(dep => changeIndexByHash[dep]), // depsIndex\n  change.extraBytes ? change.extraBytes.byteLength << 4 | VALUE_TYPE.BYTES : VALUE_TYPE.BYTES, // extraLen\n  change.extraBytes // extraRaw\n  ]);\n}\n\nclass BackendDoc {\n  constructor(buffer) {\n    this.maxOp = 0;\n    this.haveHashGraph = false;\n    this.changes = [];\n    this.changeIndexByHash = {};\n    this.dependenciesByHash = {};\n    this.dependentsByHash = {};\n    this.hashesByActor = {};\n    this.actorIds = [];\n    this.heads = [];\n    this.clock = {};\n    this.queue = [];\n    this.objectMeta = {\n      _root: {\n        parentObj: null,\n        parentKey: null,\n        opId: null,\n        type: 'map',\n        children: {}\n      }\n    };\n\n    if (buffer) {\n      const doc = decodeDocumentHeader(buffer);\n      const {\n        clock,\n        headActors,\n        encoders,\n        numChanges\n      } = readDocumentChanges(doc);\n      this.binaryDoc = buffer;\n      this.changes = new Array(numChanges);\n      this.actorIds = doc.actorIds;\n      this.heads = doc.heads;\n      this.clock = clock;\n      this.changesEncoders = encoders;\n      this.extraBytes = doc.extraBytes; // If there is a single head, we can unambiguously point at the actorId and sequence number of\n      // the head hash without having to reconstruct the hash graph\n\n      if (doc.heads.length === 1 && headActors.length === 1) {\n        this.hashesByActor[headActors[0]] = [];\n        this.hashesByActor[headActors[0]][clock[headActors[0]] - 1] = doc.heads[0];\n      } // The encoded document gives each change an index, and expresses dependencies in terms of\n      // those indexes. Initialise the translation table from hash to index.\n\n\n      if (doc.heads.length === doc.headsIndexes.length) {\n        for (let i = 0; i < doc.heads.length; i++) {\n          this.changeIndexByHash[doc.heads[i]] = doc.headsIndexes[i];\n        }\n      } else if (doc.heads.length === 1) {\n        // If there is only one head, it must be the last change\n        this.changeIndexByHash[doc.heads[0]] = numChanges - 1;\n      } else {\n        // We know the heads hashes, but not their indexes\n        for (let head of doc.heads) this.changeIndexByHash[head] = -1;\n      }\n\n      this.blocks = [{\n        columns: makeDecoders(doc.opsColumns, DOC_OPS_COLUMNS)\n      }];\n      updateBlockMetadata(this.blocks[0]);\n\n      if (this.blocks[0].numOps > MAX_BLOCK_SIZE) {\n        this.blocks = splitBlock(this.blocks[0]);\n      }\n\n      let docState = {\n        blocks: this.blocks,\n        actorIds: this.actorIds,\n        objectMeta: this.objectMeta,\n        maxOp: 0\n      };\n      this.initPatch = documentPatch(docState);\n      this.maxOp = docState.maxOp;\n    } else {\n      this.haveHashGraph = true;\n      this.changesEncoders = DOCUMENT_COLUMNS.map(col => ({\n        columnId: col.columnId,\n        encoder: encoderByColumnId(col.columnId)\n      }));\n      this.blocks = [{\n        columns: makeDecoders([], DOC_OPS_COLUMNS),\n        bloom: new Uint8Array(BLOOM_FILTER_SIZE),\n        numOps: 0,\n        lastKey: undefined,\n        numVisible: undefined,\n        lastObjectActor: undefined,\n        lastObjectCtr: undefined,\n        firstVisibleActor: undefined,\n        firstVisibleCtr: undefined,\n        lastVisibleActor: undefined,\n        lastVisibleCtr: undefined\n      }];\n    }\n  }\n  /**\n   * Makes a copy of this BackendDoc that can be independently modified.\n   */\n\n\n  clone() {\n    let copy = new BackendDoc();\n    copy.maxOp = this.maxOp;\n    copy.haveHashGraph = this.haveHashGraph;\n    copy.changes = this.changes.slice();\n    copy.changeIndexByHash = copyObject(this.changeIndexByHash);\n    copy.dependenciesByHash = copyObject(this.dependenciesByHash);\n    copy.dependentsByHash = Object.entries(this.dependentsByHash).reduce((acc, _ref) => {\n      let [k, v] = _ref;\n      acc[k] = v.slice();\n      return acc;\n    }, {});\n    copy.hashesByActor = Object.entries(this.hashesByActor).reduce((acc, _ref2) => {\n      let [k, v] = _ref2;\n      acc[k] = v.slice();\n      return acc;\n    }, {});\n    copy.actorIds = this.actorIds; // immutable, no copying needed\n\n    copy.heads = this.heads; // immutable, no copying needed\n\n    copy.clock = this.clock; // immutable, no copying needed\n\n    copy.blocks = this.blocks; // immutable, no copying needed\n\n    copy.objectMeta = this.objectMeta; // immutable, no copying needed\n\n    copy.queue = this.queue; // immutable, no copying needed\n\n    return copy;\n  }\n  /**\n   * Parses the changes given as Uint8Arrays in `changeBuffers`, and applies them to the current\n   * document. Returns a patch to apply to the frontend. If an exception is thrown, the document\n   * object is not modified.\n   */\n\n\n  applyChanges(changeBuffers) {\n    let isLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // decoded change has the form { actor, seq, startOp, time, message, deps, actorIds, hash, columns, buffer }\n    let decodedChanges = changeBuffers.map(buffer => {\n      const decoded = decodeChangeColumns(buffer);\n      decoded.buffer = buffer;\n      return decoded;\n    });\n    let patches = {\n      _root: {\n        objectId: '_root',\n        type: 'map',\n        props: {}\n      }\n    };\n    let docState = {\n      maxOp: this.maxOp,\n      changeIndexByHash: this.changeIndexByHash,\n      actorIds: this.actorIds,\n      heads: this.heads,\n      clock: this.clock,\n      blocks: this.blocks.slice(),\n      objectMeta: Object.assign({}, this.objectMeta)\n    };\n    let queue = this.queue.length === 0 ? decodedChanges : decodedChanges.concat(this.queue);\n    let allApplied = [],\n        objectIds = new Set();\n\n    while (true) {\n      const [applied, enqueued] = applyChanges(patches, queue, docState, objectIds, this.haveHashGraph);\n      queue = enqueued;\n      if (applied.length > 0) allApplied = allApplied.concat(applied);\n      if (queue.length === 0) break; // If we are missing a dependency, and we haven't computed the hash graph yet, first compute\n      // the hashes to see if we actually have it already\n\n      if (applied.length === 0) {\n        if (this.haveHashGraph) break;\n        this.computeHashGraph();\n        docState.changeIndexByHash = this.changeIndexByHash;\n      }\n    }\n\n    setupPatches(patches, objectIds, docState); // Update the document state only if `applyChanges` does not throw an exception\n\n    for (let change of allApplied) {\n      this.changes.push(change.buffer);\n      if (!this.hashesByActor[change.actor]) this.hashesByActor[change.actor] = [];\n      this.hashesByActor[change.actor][change.seq - 1] = change.hash;\n      this.changeIndexByHash[change.hash] = this.changes.length - 1;\n      this.dependenciesByHash[change.hash] = change.deps;\n      this.dependentsByHash[change.hash] = [];\n\n      for (let dep of change.deps) {\n        if (!this.dependentsByHash[dep]) this.dependentsByHash[dep] = [];\n        this.dependentsByHash[dep].push(change.hash);\n      }\n\n      appendChange(this.changesEncoders, change, docState.actorIds, this.changeIndexByHash);\n    }\n\n    this.maxOp = docState.maxOp;\n    this.actorIds = docState.actorIds;\n    this.heads = docState.heads;\n    this.clock = docState.clock;\n    this.blocks = docState.blocks;\n    this.objectMeta = docState.objectMeta;\n    this.queue = queue;\n    this.binaryDoc = null;\n    this.initPatch = null;\n    let patch = {\n      maxOp: this.maxOp,\n      clock: this.clock,\n      deps: this.heads,\n      pendingChanges: this.queue.length,\n      diffs: patches._root\n    };\n\n    if (isLocal && decodedChanges.length === 1) {\n      patch.actor = decodedChanges[0].actor;\n      patch.seq = decodedChanges[0].seq;\n    }\n\n    return patch;\n  }\n  /**\n   * Reconstructs the full change history of a document, and initialises the variables that allow us\n   * to traverse the hash graph of changes and their dependencies. When a compressed document is\n   * loaded we defer the computation of this hash graph to make loading faster, but if the hash\n   * graph is later needed (e.g. for the sync protocol), this function fills it in.\n   */\n\n\n  computeHashGraph() {\n    const binaryDoc = this.save();\n    this.haveHashGraph = true;\n    this.changes = [];\n    this.changeIndexByHash = {};\n    this.dependenciesByHash = {};\n    this.dependentsByHash = {};\n    this.hashesByActor = {};\n    this.clock = {};\n\n    for (let change of decodeChanges([binaryDoc])) {\n      const binaryChange = encodeChange(change); // TODO: avoid decoding and re-encoding again\n\n      this.changes.push(binaryChange);\n      this.changeIndexByHash[change.hash] = this.changes.length - 1;\n      this.dependenciesByHash[change.hash] = change.deps;\n      this.dependentsByHash[change.hash] = [];\n\n      for (let dep of change.deps) this.dependentsByHash[dep].push(change.hash);\n\n      if (change.seq === 1) this.hashesByActor[change.actor] = [];\n      this.hashesByActor[change.actor].push(change.hash);\n      const expectedSeq = (this.clock[change.actor] || 0) + 1;\n\n      if (change.seq !== expectedSeq) {\n        throw new RangeError(`Expected seq ${expectedSeq}, got seq ${change.seq} from actor ${change.actor}`);\n      }\n\n      this.clock[change.actor] = change.seq;\n    }\n  }\n  /**\n   * Returns all the changes that need to be sent to another replica. `haveDeps` is a list of change\n   * hashes (as hex strings) of the heads that the other replica has. The changes in `haveDeps` and\n   * any of their transitive dependencies will not be returned; any changes later than or concurrent\n   * to the hashes in `haveDeps` will be returned. If `haveDeps` is an empty array, all changes are\n   * returned. Throws an exception if any of the given hashes are not known to this replica.\n   */\n\n\n  getChanges(haveDeps) {\n    if (!this.haveHashGraph) this.computeHashGraph(); // If the other replica has nothing, return all changes in history order\n\n    if (haveDeps.length === 0) {\n      return this.changes.slice();\n    } // Fast path for the common case where all new changes depend only on haveDeps\n\n\n    let stack = [],\n        seenHashes = {},\n        toReturn = [];\n\n    for (let hash of haveDeps) {\n      seenHashes[hash] = true;\n      const successors = this.dependentsByHash[hash];\n      if (!successors) throw new RangeError(`hash not found: ${hash}`);\n      stack.push(...successors);\n    } // Depth-first traversal of the hash graph to find all changes that depend on `haveDeps`\n\n\n    while (stack.length > 0) {\n      const hash = stack.pop();\n      seenHashes[hash] = true;\n      toReturn.push(hash);\n\n      if (!this.dependenciesByHash[hash].every(dep => seenHashes[dep])) {\n        // If a change depends on a hash we have not seen, abort the traversal and fall back to the\n        // slower algorithm. This will sometimes abort even if all new changes depend on `haveDeps`,\n        // because our depth-first traversal is not necessarily a topological sort of the graph.\n        break;\n      }\n\n      stack.push(...this.dependentsByHash[hash]);\n    } // If the traversal above has encountered all the heads, and was not aborted early due to\n    // a missing dependency, then the set of changes it has found is complete, so we can return it\n\n\n    if (stack.length === 0 && this.heads.every(head => seenHashes[head])) {\n      return toReturn.map(hash => this.changes[this.changeIndexByHash[hash]]);\n    } // If we haven't encountered all of the heads, we have to search harder. This will happen if\n    // changes were added that are concurrent to `haveDeps`\n\n\n    stack = haveDeps.slice();\n    seenHashes = {};\n\n    while (stack.length > 0) {\n      const hash = stack.pop();\n\n      if (!seenHashes[hash]) {\n        const deps = this.dependenciesByHash[hash];\n        if (!deps) throw new RangeError(`hash not found: ${hash}`);\n        stack.push(...deps);\n        seenHashes[hash] = true;\n      }\n    }\n\n    return this.changes.filter(change => !seenHashes[decodeChangeMeta(change, true).hash]);\n  }\n  /**\n   * Returns all changes that are present in this BackendDoc, but not present in the `other`\n   * BackendDoc.\n   */\n\n\n  getChangesAdded(other) {\n    if (!this.haveHashGraph) this.computeHashGraph(); // Depth-first traversal from the heads through the dependency graph,\n    // until we reach a change that is already present in opSet1\n\n    let stack = this.heads.slice(),\n        seenHashes = {},\n        toReturn = [];\n\n    while (stack.length > 0) {\n      const hash = stack.pop();\n\n      if (!seenHashes[hash] && other.changeIndexByHash[hash] === undefined) {\n        seenHashes[hash] = true;\n        toReturn.push(hash);\n        stack.push(...this.dependenciesByHash[hash]);\n      }\n    } // Return those changes in the reverse of the order in which the depth-first search\n    // found them. This is not necessarily a topological sort, but should usually be close.\n\n\n    return toReturn.reverse().map(hash => this.changes[this.changeIndexByHash[hash]]);\n  }\n\n  getChangeByHash(hash) {\n    if (!this.haveHashGraph) this.computeHashGraph();\n    return this.changes[this.changeIndexByHash[hash]];\n  }\n  /**\n   * Returns the hashes of any missing dependencies, i.e. where we have tried to apply a change that\n   * has a dependency on a change we have not seen.\n   *\n   * If the argument `heads` is given (an array of hexadecimal strings representing hashes as\n   * returned by `getHeads()`), this function also ensures that all of those hashes resolve to\n   * either a change that has been applied to the document, or that has been enqueued for later\n   * application once missing dependencies have arrived. Any missing heads hashes are included in\n   * the returned array.\n   */\n\n\n  getMissingDeps() {\n    let heads = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    if (!this.haveHashGraph) this.computeHashGraph();\n    let allDeps = new Set(heads),\n        inQueue = new Set();\n\n    for (let change of this.queue) {\n      inQueue.add(change.hash);\n\n      for (let dep of change.deps) allDeps.add(dep);\n    }\n\n    let missing = [];\n\n    for (let hash of allDeps) {\n      if (this.changeIndexByHash[hash] === undefined && !inQueue.has(hash)) missing.push(hash);\n    }\n\n    return missing.sort();\n  }\n  /**\n   * Serialises the current document state into a single byte array.\n   */\n\n\n  save() {\n    if (this.binaryDoc) return this.binaryDoc; // Getting the byte array for the changes columns finalises their encoders, after which we can\n    // no longer append values to them. We therefore copy their data over to fresh encoders.\n\n    const newEncoders = this.changesEncoders.map(col => ({\n      columnId: col.columnId,\n      encoder: encoderByColumnId(col.columnId)\n    }));\n    const decoders = this.changesEncoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);\n      return {\n        columnId: col.columnId,\n        decoder\n      };\n    });\n    copyColumns(newEncoders, decoders, this.changes.length);\n    this.binaryDoc = encodeDocumentHeader({\n      changesColumns: this.changesEncoders,\n      opsColumns: concatBlocks(this.blocks),\n      actorIds: this.actorIds,\n      // TODO: sort actorIds (requires transforming all actorId columns in opsColumns)\n      heads: this.heads,\n      headsIndexes: this.heads.map(hash => this.changeIndexByHash[hash]),\n      extraBytes: this.extraBytes\n    });\n    this.changesEncoders = newEncoders;\n    return this.binaryDoc;\n  }\n  /**\n   * Returns a patch from which we can initialise the current state of the backend.\n   */\n\n\n  getPatch() {\n    const objectMeta = {\n      _root: {\n        parentObj: null,\n        parentKey: null,\n        opId: null,\n        type: 'map',\n        children: {}\n      }\n    };\n    const docState = {\n      blocks: this.blocks,\n      actorIds: this.actorIds,\n      objectMeta,\n      maxOp: 0\n    };\n    const diffs = this.initPatch ? this.initPatch : documentPatch(docState);\n    return {\n      maxOp: this.maxOp,\n      clock: this.clock,\n      deps: this.heads,\n      pendingChanges: this.queue.length,\n      diffs\n    };\n  }\n\n}\n\nmodule.exports = {\n  MAX_BLOCK_SIZE,\n  BackendDoc,\n  bloomFilterContains\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/backend/new.js"],"names":["parseOpId","copyObject","require","COLUMN_TYPE","VALUE_TYPE","ACTIONS","OBJECT_TYPE","DOC_OPS_COLUMNS","CHANGE_COLUMNS","DOCUMENT_COLUMNS","encoderByColumnId","decoderByColumnId","makeDecoders","decodeValue","encodeChange","decodeChangeColumns","decodeChangeMeta","decodeChanges","decodeDocumentHeader","encodeDocumentHeader","MAX_BLOCK_SIZE","BLOOM_BITS_PER_ENTRY","BLOOM_NUM_PROBES","BLOOM_FILTER_SIZE","Math","floor","objActorIdx","objCtrIdx","keyActorIdx","keyCtrIdx","keyStrIdx","idActorIdx","idCtrIdx","insertIdx","actionIdx","valLenIdx","valRawIdx","predNumIdx","predActorIdx","predCtrIdx","succNumIdx","succActorIdx","succCtrIdx","PRED_COLUMN_IDS","filter","column","includes","columnName","map","columnId","deepCopyUpdate","objectTree","path","value","length","child","Object","assign","slice","seekWithinBlock","ops","docCols","actorIds","resumeInsertion","col","decoder","reset","objActor","objCtr","keyActor","keyCtr","keyStr","idActor","idCtr","insert","objActorD","objCtrD","keyStrD","idActorD","idCtrD","insertD","actionD","succNumD","skipCount","visibleCount","elemVisible","nextObjActor","nextObjCtr","nextIdActor","nextIdCtr","nextKeyStr","nextInsert","nextSuccNum","done","readValue","skipValues","found","objActorIndex","visibleListElements","docState","blockIndex","objActorNum","thisBlock","blocks","nextBlock","lastObjectActor","lastObjectCtr","numVisible","undefined","lastVisibleActor","firstVisibleActor","lastVisibleCtr","firstVisibleCtr","seekToOp","totalVisible","blockActor","blockCtr","lastKey","columns","insertAtHead","keyActorNum","indexOf","bloomFilterContains","bloom","RangeError","numOps","bloomFilterAdd","elemIdActor","elemIdCtr","modulo","byteLength","x","y","z","i","updateBlockMetadata","block","Uint8Array","keyActorD","keyCtrD","succNum","addBlockOperation","op","isChangeOp","splitBlock","numBlocks","ceil","opsSoFar","opsToCopy","encoders","encoder","copyColumns","decoders","buffer","newBlock","push","concatBlocks","outCols","inCols","count","inIndex","lastGroup","lastCardinality","valueColumn","valueBytes","outCol","inCol","buf","colCount","GROUP_CARD","copyFrom","sumValues","sum","appendValue","VALUE_LEN","sumShift","VALUE_RAW","appendRawBytes","readRawBytes","blankValue","BOOLEAN","readOperation","actorTable","operation","colValue","ACTOR_ID","appendOperation","Array","isArray","v","readNextDocOp","docOp","readNextChangeOp","changeState","changeIndex","changes","change","opCtr","startOp","updateBlockColumns","getActorTable","actorIndex","nextOp","maxOp","emptyObjectPatch","objectId","type","edits","props","opIdDelta","id1","id2","delta","parsed1","parsed2","actorId","counter","appendEdit","existingEdits","nextEdit","lastEdit","action","index","elemId","opId","datatype","values","appendUpdate","firstUpdate","pop","convertInsertToUpdate","updates","unshift","update","updatePatchProperty","patches","propState","listIndex","oldSuccNum","isWholeDoc","objectMeta","parentObj","parentKey","children","firstOp","visibleOps","hasChild","isOverwritten","prevChildren","keys","visible","objType","patchKey","patchValue","COUNTER","counterStates","counterState","succs","succOp","patch","mergeDocChangeOps","idActorIndex","foundListElem","docOpsConsumed","docOpOldSuccNum","changeOp","changeOps","changeCols","predSeen","lastChangeKey","objectIds","add","lastOp","isOverwrite","prevOp","inCorrectObject","keyMatches","listElemMatches","takeDocOp","takeChangeOps","opIndex","j","splice","deleted","applyOps","idActorNum","objId","resetFirstVisible","lastBlockIndex","lastBlock","copyAfterMerge","newBlocks","every","changeCol","find","docCol","allCols","sort","a","b","seq","concat","setupPatches","meta","childMeta","patchExists","hasChildren","edit","obj","elem","seekPos","entries","applyChanges","decodedChanges","throwExceptions","heads","Set","changeHashes","clock","applied","enqueued","changeIndexByHash","hash","has","expectedSeq","actor","causallyReady","dep","deps","depIndex","delete","documentPatch","_root","lastObjActor","lastObjCtr","readDocumentChanges","doc","changesColumns","actorD","seqD","depsNumD","depsIndexD","numChanges","actorNums","headIndexes","actorNum","depsNum","headActors","appendChange","time","message","extraBytes","BYTES","BackendDoc","constructor","haveHashGraph","dependenciesByHash","dependentsByHash","hashesByActor","queue","binaryDoc","changesEncoders","headsIndexes","head","opsColumns","initPatch","clone","copy","reduce","acc","k","changeBuffers","isLocal","decoded","allApplied","computeHashGraph","pendingChanges","diffs","save","binaryChange","getChanges","haveDeps","stack","seenHashes","toReturn","successors","getChangesAdded","other","reverse","getChangeByHash","getMissingDeps","allDeps","inQueue","missing","newEncoders","getPatch","module","exports"],"mappings":"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","sourcesContent":["const { parseOpId, copyObject } = require('../src/common')\nconst { COLUMN_TYPE, VALUE_TYPE, ACTIONS, OBJECT_TYPE, DOC_OPS_COLUMNS, CHANGE_COLUMNS, DOCUMENT_COLUMNS,\n  encoderByColumnId, decoderByColumnId, makeDecoders, decodeValue,\n  encodeChange, decodeChangeColumns, decodeChangeMeta, decodeChanges, decodeDocumentHeader, encodeDocumentHeader } = require('./columnar')\n\nconst MAX_BLOCK_SIZE = 600 // operations\nconst BLOOM_BITS_PER_ENTRY = 10, BLOOM_NUM_PROBES = 7 // 1% false positive rate\nconst BLOOM_FILTER_SIZE = Math.floor(BLOOM_BITS_PER_ENTRY * MAX_BLOCK_SIZE / 8) // bytes\n\nconst objActorIdx = 0, objCtrIdx = 1, keyActorIdx = 2, keyCtrIdx = 3, keyStrIdx = 4,\n  idActorIdx = 5, idCtrIdx = 6, insertIdx = 7, actionIdx = 8, valLenIdx = 9, valRawIdx = 10,\n  predNumIdx = 13, predActorIdx = 14, predCtrIdx = 15, succNumIdx = 13, succActorIdx = 14, succCtrIdx = 15\n\nconst PRED_COLUMN_IDS = CHANGE_COLUMNS\n  .filter(column => ['predNum', 'predActor', 'predCtr'].includes(column.columnName))\n  .map(column => column.columnId)\n\n/**\n * Updates `objectTree`, which is a tree of nested objects, so that afterwards\n * `objectTree[path[0]][path[1]][...] === value`. Only the root object is mutated, whereas any\n * nested objects are copied before updating. This means that once the root object has been\n * shallow-copied, this function can be used to update it without mutating the previous version.\n */\nfunction deepCopyUpdate(objectTree, path, value) {\n  if (path.length === 1) {\n    objectTree[path[0]] = value\n  } else {\n    let child = Object.assign({}, objectTree[path[0]])\n    deepCopyUpdate(child, path.slice(1), value)\n    objectTree[path[0]] = child\n  }\n}\n\n/**\n * Scans a block of document operations, encoded as columns `docCols`, to find the position at which\n * an operation (or sequence of operations) `ops` should be applied. `actorIds` is the array that\n * maps actor numbers to hexadecimal actor IDs. `resumeInsertion` is true if we're performing a list\n * insertion and we already found the reference element in a previous block, but we reached the end\n * of that previous block while scanning for the actual insertion position, and so we're continuing\n * the scan in a subsequent block.\n *\n * Returns an object with keys:\n * - `found`: false if we were scanning for a reference element in a list but couldn't find it;\n *    true otherwise.\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or applied.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\nfunction seekWithinBlock(ops, docCols, actorIds, resumeInsertion) {\n  for (let col of docCols) col.decoder.reset()\n  const { objActor, objCtr, keyActor, keyCtr, keyStr, idActor, idCtr, insert } = ops\n  const [objActorD, objCtrD, /* keyActorD */, /* keyCtrD */, keyStrD, idActorD, idCtrD, insertD, actionD,\n    /* valLenD */, /* valRawD */, /* chldActorD */, /* chldCtrD */, succNumD] = docCols.map(col => col.decoder)\n  let skipCount = 0, visibleCount = 0, elemVisible = false, nextObjActor = null, nextObjCtr = null\n  let nextIdActor = null, nextIdCtr = null, nextKeyStr = null, nextInsert = null, nextSuccNum = 0\n\n  // Seek to the beginning of the object being updated\n  if (objCtr !== null && !resumeInsertion) {\n    while (!objCtrD.done || !objActorD.done || !actionD.done) {\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      actionD.skipValues(1)\n      if (nextObjCtr === null || !nextObjActor || nextObjCtr < objCtr ||\n          (nextObjCtr === objCtr && nextObjActor < objActor)) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n  }\n  if ((nextObjCtr !== objCtr || nextObjActor !== objActor) && !resumeInsertion) {\n    return {found: true, skipCount, visibleCount}\n  }\n\n  // Seek to the appropriate key (if string key is used)\n  if (keyStr !== null) {\n    keyStrD.skipValues(skipCount)\n    while (!keyStrD.done) {\n      const objActorIndex = objActorD.readValue()\n      nextObjActor = objActorIndex === null ? null : actorIds[objActorIndex]\n      nextObjCtr = objCtrD.readValue()\n      nextKeyStr = keyStrD.readValue()\n      if (nextKeyStr !== null && nextKeyStr < keyStr &&\n          nextObjCtr === objCtr && nextObjActor === objActor) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n    return {found: true, skipCount, visibleCount}\n  }\n\n  idCtrD.skipValues(skipCount)\n  idActorD.skipValues(skipCount)\n  insertD.skipValues(skipCount)\n  succNumD.skipValues(skipCount)\n  nextIdCtr = idCtrD.readValue()\n  nextIdActor = actorIds[idActorD.readValue()]\n  nextInsert = insertD.readValue()\n  nextSuccNum = succNumD.readValue()\n\n  // If we are inserting into a list, an opId key is used, and we need to seek to a position *after*\n  // the referenced operation. Moreover, we need to skip over any existing operations with a greater\n  // opId than the new insertion, for CRDT convergence on concurrent insertions in the same place.\n  if (insert) {\n    // If insertion is not at the head, search for the reference element\n    if (!resumeInsertion && keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n      skipCount += 1\n      while (!idCtrD.done && !idActorD.done && (nextIdCtr !== keyCtr || nextIdActor !== keyActor)) {\n        if (nextInsert) elemVisible = false\n        if (nextSuccNum === 0 && !elemVisible) {\n          visibleCount += 1\n          elemVisible = true\n        }\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n        if (nextObjCtr === objCtr && nextObjActor === objActor) skipCount += 1; else break\n      }\n      if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr ||\n          nextIdActor !== keyActor || !nextInsert) {\n        return {found: false, skipCount, visibleCount}\n      }\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n\n      // Set up the next* variables to the operation following the reference element\n      if (idCtrD.done || idActorD.done) return {found: true, skipCount, visibleCount}\n      nextIdCtr = idCtrD.readValue()\n      nextIdActor = actorIds[idActorD.readValue()]\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      nextInsert = insertD.readValue()\n      nextSuccNum = succNumD.readValue()\n    }\n\n    // Skip over any list elements with greater ID than the new one, and any non-insertions\n    while ((!nextInsert || nextIdCtr > idCtr || (nextIdCtr === idCtr && nextIdActor > idActor)) &&\n           nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n      } else {\n        break\n      }\n    }\n\n  } else if (keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n    // If we are updating an existing list element, seek to just before the referenced ID\n    while ((!nextInsert || nextIdCtr !== keyCtr || nextIdActor !== keyActor) &&\n           nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n      } else {\n        break\n      }\n    }\n    if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr ||\n        nextIdActor !== keyActor || !nextInsert) {\n      return {found: false, skipCount, visibleCount}\n    }\n  }\n  return {found: true, skipCount, visibleCount}\n}\n\n/**\n * Returns the number of list elements that should be added to a list index when skipping over the\n * block with index `blockIndex` in the list object with object ID consisting of actor number\n * `objActorNum` and counter `objCtr`.\n */\nfunction visibleListElements(docState, blockIndex, objActorNum, objCtr) {\n  const thisBlock = docState.blocks[blockIndex]\n  const nextBlock = docState.blocks[blockIndex + 1]\n\n  if (thisBlock.lastObjectActor !== objActorNum || thisBlock.lastObjectCtr !== objCtr ||\n      thisBlock.numVisible === undefined) {\n    return 0\n\n    // If a list element is split across the block boundary, don't double-count it\n  } else if (thisBlock.lastVisibleActor === nextBlock.firstVisibleActor &&\n             thisBlock.lastVisibleActor !== undefined &&\n             thisBlock.lastVisibleCtr === nextBlock.firstVisibleCtr &&\n             thisBlock.lastVisibleCtr !== undefined) {\n    return thisBlock.numVisible - 1\n  } else {\n    return thisBlock.numVisible\n  }\n}\n\n/**\n * Scans the blocks of document operations to find the position where a new operation should be\n * inserted. Returns an object with keys:\n * - `blockIndex`: the index of the block into which we should insert the new operation\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or merged.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\nfunction seekToOp(docState, ops) {\n  const { objActor, objActorNum, objCtr, keyActor, keyCtr, keyStr } = ops\n  let blockIndex = 0, totalVisible = 0\n\n  // Skip any blocks that contain only objects with lower objectIds\n  if (objCtr !== null) {\n    while (blockIndex < docState.blocks.length - 1) {\n      const blockActor = docState.blocks[blockIndex].lastObjectActor === undefined ? undefined\n        : docState.actorIds[docState.blocks[blockIndex].lastObjectActor]\n      const blockCtr = docState.blocks[blockIndex].lastObjectCtr\n      if (blockCtr === null || blockCtr < objCtr || (blockCtr === objCtr && blockActor < objActor)) {\n        blockIndex++\n      } else {\n        break\n      }\n    }\n  }\n\n  if (keyStr !== null) {\n    // String key is used. First skip any blocks that contain only lower keys\n    while (blockIndex < docState.blocks.length - 1) {\n      const { lastObjectActor, lastObjectCtr, lastKey } = docState.blocks[blockIndex]\n      if (objCtr === lastObjectCtr && objActorNum === lastObjectActor &&\n          lastKey !== undefined && lastKey < keyStr) blockIndex++; else break\n    }\n\n    // When we have a candidate block, decode it to find the exact insertion position\n    const {skipCount} = seekWithinBlock(ops, docState.blocks[blockIndex].columns, docState.actorIds, false)\n    return {blockIndex, skipCount, visibleCount: 0}\n\n  } else {\n    // List operation\n    const insertAtHead = keyCtr === null || keyCtr === 0 || keyActor === null\n    const keyActorNum = keyActor === null ? null : docState.actorIds.indexOf(keyActor)\n    let resumeInsertion = false\n\n    while (true) {\n      // Search for the reference element, skipping any blocks whose Bloom filter does not contain\n      // the reference element. We only do this if not inserting at the head (in which case there is\n      // no reference element), or if we already found the reference element in an earlier block (in\n      // which case we have resumeInsertion === true). The latter case arises with concurrent\n      // insertions at the same position, and so we have to scan beyond the reference element to\n      // find the actual insertion position, and that further scan crosses a block boundary.\n      if (!insertAtHead && !resumeInsertion) {\n        while (blockIndex < docState.blocks.length - 1 &&\n               docState.blocks[blockIndex].lastObjectActor === objActorNum &&\n               docState.blocks[blockIndex].lastObjectCtr === objCtr &&\n               !bloomFilterContains(docState.blocks[blockIndex].bloom, keyActorNum, keyCtr)) {\n          // If we reach the end of the list object without a Bloom filter hit, the reference element\n          // doesn't exist\n          if (docState.blocks[blockIndex].lastObjectCtr > objCtr) {\n            throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`)\n          }\n\n          // Add up number of visible list elements in any blocks we skip, for list index computation\n          totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr)\n          blockIndex++\n        }\n      }\n\n      // We have a candidate block. Decode it to see whether it really contains the reference element\n      const {found, skipCount, visibleCount} = seekWithinBlock(ops,\n                                                               docState.blocks[blockIndex].columns,\n                                                               docState.actorIds,\n                                                               resumeInsertion)\n\n      if (blockIndex === docState.blocks.length - 1 ||\n          docState.blocks[blockIndex].lastObjectActor !== objActorNum ||\n          docState.blocks[blockIndex].lastObjectCtr !== objCtr) {\n        // Last block: if we haven't found the reference element by now, it's an error\n        if (found) {\n          return {blockIndex, skipCount, visibleCount: totalVisible + visibleCount}\n        } else {\n          throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`)\n        }\n\n      } else if (found && skipCount < docState.blocks[blockIndex].numOps) {\n        // The insertion position lies within the current block\n        return {blockIndex, skipCount, visibleCount: totalVisible + visibleCount}\n      }\n\n      // Reference element not found and there are still blocks left ==> it was probably a false positive.\n      // Reference element found, but we skipped all the way to the end of the block ==> we need to\n      // continue scanning the next block to find the actual insertion position.\n      // Either way, go back round the loop again to skip blocks until the next Bloom filter hit.\n      resumeInsertion = found && ops.insert\n      totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr)\n      blockIndex++\n    }\n  }\n}\n\n/**\n * Updates Bloom filter `bloom`, given as a Uint8Array, to contain the list element ID consisting of\n * counter `elemIdCtr` and actor number `elemIdActor`. We don't actually bother computing a hash\n * function, since those two integers serve perfectly fine as input. We turn the two integers into a\n * sequence of probe indexes using the triple hashing algorithm from the following paper:\n *\n * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.\n * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.\n * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf\n */\nfunction bloomFilterAdd(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo\n\n  // Use one step of FNV-1a to compute a third value from the two inputs.\n  // Taken from http://www.isthe.com/chongo/tech/comp/fnv/index.html\n  // The prime is just over 2^24, so elemIdCtr can be up to about 2^29 = 500 million before the\n  // result of the multiplication exceeds 2^53. And even if it does exceed 2^53 and loses precision,\n  // that shouldn't be a problem as it should still be deterministic, and the Bloom filter\n  // computation only needs to be internally consistent within this library.\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo\n\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    bloom[x >>> 3] |= 1 << (x & 7)\n    x = (x + y) % modulo\n    y = (y + z) % modulo\n  }\n}\n\n/**\n * Returns true if the list element ID consisting of counter `elemIdCtr` and actor number\n * `elemIdActor` is likely to be contained in the Bloom filter `bloom`.\n */\nfunction bloomFilterContains(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo\n\n  // See comments in the bloomFilterAdd function for an explanation\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    if ((bloom[x >>> 3] & (1 << (x & 7))) === 0) {\n      return false\n    }\n    x = (x + y) % modulo\n    y = (y + z) % modulo\n  }\n  return true\n}\n\n/**\n * Reads the relevant columns of a block of operations and updates that block to contain the\n * metadata we need to efficiently figure out where to insert new operations.\n */\nfunction updateBlockMetadata(block) {\n  block.bloom = new Uint8Array(BLOOM_FILTER_SIZE)\n  block.numOps = 0\n  block.lastKey = undefined\n  block.numVisible = undefined\n  block.lastObjectActor = undefined\n  block.lastObjectCtr = undefined\n  block.firstVisibleActor = undefined\n  block.firstVisibleCtr = undefined\n  block.lastVisibleActor = undefined\n  block.lastVisibleCtr = undefined\n\n  for (let col of block.columns) col.decoder.reset()\n  const [objActorD, objCtrD, keyActorD, keyCtrD, keyStrD, idActorD, idCtrD, insertD, /* actionD */,\n    /* valLenD */, /* valRawD */, /* chldActorD */, /* chldCtrD */, succNumD] = block.columns.map(col => col.decoder)\n\n  while (!idCtrD.done) {\n    block.numOps += 1\n    const objActor = objActorD.readValue(), objCtr = objCtrD.readValue()\n    const keyActor = keyActorD.readValue(), keyCtr = keyCtrD.readValue(), keyStr = keyStrD.readValue()\n    const idActor = idActorD.readValue(), idCtr = idCtrD.readValue()\n    const insert = insertD.readValue(), succNum = succNumD.readValue()\n\n    if (block.lastObjectActor !== objActor || block.lastObjectCtr !== objCtr) {\n      block.numVisible = 0\n      block.lastObjectActor = objActor\n      block.lastObjectCtr = objCtr\n    }\n\n    if (keyStr !== null) {\n      // Map key: for each object, record the highest key contained in the block\n      block.lastKey = keyStr\n    } else if (insert || keyCtr !== null) {\n      // List element\n      block.lastKey = undefined\n      const elemIdActor = insert ? idActor : keyActor\n      const elemIdCtr = insert ? idCtr : keyCtr\n      bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr)\n\n      // If the list element is visible, update the block metadata accordingly\n      if (succNum === 0) {\n        if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor\n        if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr\n        if (block.lastVisibleActor !== elemIdActor || block.lastVisibleCtr !== elemIdCtr) {\n          block.numVisible += 1\n          block.lastVisibleActor = elemIdActor\n          block.lastVisibleCtr = elemIdCtr\n        }\n      }\n    }\n  }\n}\n\n/**\n * Updates a block's metadata based on an operation being added to a block.\n */\nfunction addBlockOperation(block, op, actorIds, isChangeOp) {\n  if (op[keyStrIdx] !== null) {\n    // TODO this comparison should use UTF-8 encoding, not JavaScript's UTF-16\n    if (block.lastObjectCtr === op[objCtrIdx] && block.lastObjectActor === op[objActorIdx] &&\n        (block.lastKey === undefined || block.lastKey < op[keyStrIdx])) {\n      block.lastKey = op[keyStrIdx]\n    }\n  } else {\n    // List element\n    const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx]\n    const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx]\n    bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr)\n\n    // Set lastVisible on the assumption that this is the last op in the block; if there are further\n    // ops after this one in the block, lastVisible will be overwritten again later.\n    if (op[succNumIdx] === 0 || isChangeOp) {\n      if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor\n      if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr\n      block.lastVisibleActor = elemIdActor\n      block.lastVisibleCtr = elemIdCtr\n    }\n  }\n\n  // Keep track of the largest objectId contained within a block\n  if (block.lastObjectCtr === undefined ||\n      op[objActorIdx] !== null && op[objCtrIdx] !== null &&\n      (block.lastObjectCtr === null || block.lastObjectCtr < op[objCtrIdx] ||\n       (block.lastObjectCtr === op[objCtrIdx] && actorIds[block.lastObjectActor] < actorIds[op[objActorIdx]]))) {\n    block.lastObjectActor = op[objActorIdx]\n    block.lastObjectCtr = op[objCtrIdx]\n    block.lastKey = (op[keyStrIdx] !== null ? op[keyStrIdx] : undefined)\n    block.numVisible = 0\n  }\n}\n\n/**\n * Takes a block containing too many operations, and splits it into a sequence of adjacent blocks of\n * roughly equal size.\n */\nfunction splitBlock(block) {\n  for (let col of block.columns) col.decoder.reset()\n\n  // Make each of the resulting blocks between 50% and 80% full (leaving a bit of space in each\n  // block so that it doesn't get split again right away the next time an operation is added).\n  // The upper bound cannot be lower than 75% since otherwise we would end up with a block less than\n  // 50% full when going from two to three blocks.\n  const numBlocks = Math.ceil(block.numOps / (0.8 * MAX_BLOCK_SIZE))\n  let blocks = [], opsSoFar = 0\n\n  for (let i = 1; i <= numBlocks; i++) {\n    const opsToCopy = Math.ceil(i * block.numOps / numBlocks) - opsSoFar\n    const encoders = block.columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n    copyColumns(encoders, block.columns, opsToCopy)\n    const decoders = encoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n      return {columnId: col.columnId, decoder}\n    })\n\n    const newBlock = {columns: decoders}\n    updateBlockMetadata(newBlock)\n    blocks.push(newBlock)\n    opsSoFar += opsToCopy\n  }\n\n  return blocks\n}\n\n/**\n * Takes an array of blocks and concatenates the corresponding columns across all of the blocks.\n */\nfunction concatBlocks(blocks) {\n  const encoders = blocks[0].columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n\n  for (let block of blocks) {\n    for (let col of block.columns) col.decoder.reset()\n    copyColumns(encoders, block.columns, block.numOps)\n  }\n  return encoders\n}\n\n/**\n * Copies `count` rows from the set of input columns `inCols` to the set of output columns\n * `outCols`. The input columns are given as an array of `{columnId, decoder}` objects, and the\n * output columns are given as an array of `{columnId, encoder}` objects. Both are sorted in\n * increasing order of columnId. If there is no matching input column for a given output column, it\n * is filled in with `count` blank values (according to the column type).\n */\nfunction copyColumns(outCols, inCols, count) {\n  if (count === 0) return\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n    let inCol = null\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId &&\n        inCols[inIndex].decoder.buf.byteLength > 0) {\n      inCol = inCols[inIndex].decoder\n    }\n    const colCount = (outCol.columnId >> 4 === lastGroup) ? lastCardinality : count\n\n    if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4\n      if (inCol) {\n        lastCardinality = outCol.encoder.copyFrom(inCol, {count, sumValues: true}).sum\n      } else {\n        outCol.encoder.appendValue(0, count)\n        lastCardinality = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n      if (inCol) {\n        if (inIndex + 1 === inCols.length || inCols[inIndex + 1].columnId !== outCol.columnId + 1) {\n          throw new RangeError('VALUE_LEN column without accompanying VALUE_RAW column')\n        }\n        valueColumn = outCol.columnId + 1\n        valueBytes = outCol.encoder.copyFrom(inCol, {count: colCount, sumValues: true, sumShift: 4}).sum\n      } else {\n        outCol.encoder.appendValue(null, colCount)\n        valueColumn = outCol.columnId + 1\n        valueBytes = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (outCol.columnId !== valueColumn) {\n        throw new RangeError('VALUE_RAW column without accompanying VALUE_LEN column')\n      }\n      if (valueBytes > 0) {\n        outCol.encoder.appendRawBytes(inCol.readRawBytes(valueBytes))\n      }\n    } else { // ACTOR_ID, INT_RLE, INT_DELTA, BOOLEAN, or STRING_RLE\n      if (inCol) {\n        outCol.encoder.copyFrom(inCol, {count: colCount})\n      } else {\n        const blankValue = (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) ? false : null\n        outCol.encoder.appendValue(blankValue, colCount)\n      }\n    }\n  }\n}\n\n/**\n * Parses one operation from a set of columns. The argument `columns` contains a list of objects\n * with `columnId` and `decoder` properties. Returns an array in which the i'th element is the\n * value read from the i'th column in `columns`. Does not interpret datatypes; the only\n * interpretation of values is that if `actorTable` is given, a value `v` in a column of type\n * ACTOR_ID is replaced with `actorTable[v]`.\n */\nfunction readOperation(columns, actorTable) {\n  let operation = [], colValue, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let col of columns) {\n    if (col.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (col.columnId !== valueColumn) throw new RangeError('unexpected VALUE_RAW column')\n      colValue = col.decoder.readRawBytes(valueBytes)\n    } else if (col.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = col.columnId >> 4\n      lastCardinality = col.decoder.readValue() || 0\n      colValue = lastCardinality\n    } else if (col.columnId >> 4 === lastGroup) {\n      colValue = []\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = 0\n      }\n      for (let i = 0; i < lastCardinality; i++) {\n        let value = col.decoder.readValue()\n        if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof value === 'number') {\n          value = actorTable[value]\n        }\n        if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n          valueBytes += colValue >>> 4\n        }\n        colValue.push(value)\n      }\n    } else {\n      colValue = col.decoder.readValue()\n      if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof colValue === 'number') {\n        colValue = actorTable[colValue]\n      }\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = colValue >>> 4\n      }\n    }\n\n    operation.push(colValue)\n  }\n  return operation\n}\n\n/**\n * Appends `operation`, in the form returned by `readOperation()`, to the columns in `outCols`. The\n * argument `inCols` provides metadata about the types of columns in `operation`; the value\n * `operation[i]` comes from the column `inCols[i]`.\n */\nfunction appendOperation(outCols, inCols, operation) {\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId) {\n      const colValue = operation[inIndex]\n      if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        lastGroup = outCol.columnId >> 4\n        lastCardinality = colValue\n        outCol.encoder.appendValue(colValue)\n      } else if (outCol.columnId >> 4 === lastGroup) {\n        if (!Array.isArray(colValue) || colValue.length !== lastCardinality) {\n          throw new RangeError('bad group value')\n        }\n        for (let v of colValue) outCol.encoder.appendValue(v)\n      } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n        if (colValue) outCol.encoder.appendRawBytes(colValue)\n      } else {\n        outCol.encoder.appendValue(colValue)\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4\n      lastCardinality = 0\n      outCol.encoder.appendValue(0)\n    } else if (outCol.columnId % 8 !== COLUMN_TYPE.VALUE_RAW) {\n      const count = (outCol.columnId >> 4 === lastGroup) ? lastCardinality : 1\n      let blankValue = null\n      if (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) blankValue = false\n      if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) blankValue = 0\n      outCol.encoder.appendValue(blankValue, count)\n    }\n  }\n}\n\n/**\n * Parses the next operation from block `blockIndex` of the document. Returns an object of the form\n * `{docOp, blockIndex}` where `docOp` is an operation in the form returned by `readOperation()`,\n * and `blockIndex` is the block number to use on the next call (it moves on to the next block when\n * we reach the end of the current block). `docOp` is null if there are no more operations.\n */\nfunction readNextDocOp(docState, blockIndex) {\n  let block = docState.blocks[blockIndex]\n  if (!block.columns[actionIdx].decoder.done) {\n    return {docOp: readOperation(block.columns), blockIndex}\n  } else if (blockIndex === docState.blocks.length - 1) {\n    return {docOp: null, blockIndex}\n  } else {\n    blockIndex += 1\n    block = docState.blocks[blockIndex]\n    for (let col of block.columns) col.decoder.reset()\n    return {docOp: readOperation(block.columns), blockIndex}\n  }\n}\n\n/**\n * Parses the next operation from a sequence of changes. `changeState` serves as the state of this\n * pseudo-iterator, and it is mutated to reflect the new operation. In particular,\n * `changeState.nextOp` is set to the operation that was read, and `changeState.done` is set to true\n * when we have finished reading the last operation in the last change.\n */\nfunction readNextChangeOp(docState, changeState) {\n  // If we've finished reading one change, move to the next change that contains at least one op\n  while (changeState.changeIndex < changeState.changes.length - 1 &&\n         (!changeState.columns || changeState.columns[actionIdx].decoder.done)) {\n    changeState.changeIndex += 1\n    const change = changeState.changes[changeState.changeIndex]\n    changeState.columns = makeDecoders(change.columns, CHANGE_COLUMNS)\n    changeState.opCtr = change.startOp\n\n    // Update docState based on the information in the change\n    updateBlockColumns(docState, changeState.columns)\n    const {actorIds, actorTable} = getActorTable(docState.actorIds, change)\n    docState.actorIds = actorIds\n    changeState.actorTable = actorTable\n    changeState.actorIndex = docState.actorIds.indexOf(change.actorIds[0])\n  }\n\n  // Reached the end of the last change?\n  if (changeState.columns[actionIdx].decoder.done) {\n    changeState.done = true\n    changeState.nextOp = null\n    return\n  }\n\n  changeState.nextOp = readOperation(changeState.columns, changeState.actorTable)\n  changeState.nextOp[idActorIdx] = changeState.actorIndex\n  changeState.nextOp[idCtrIdx] = changeState.opCtr\n  changeState.changes[changeState.changeIndex].maxOp = changeState.opCtr\n  if (changeState.opCtr > docState.maxOp) docState.maxOp = changeState.opCtr\n  changeState.opCtr += 1\n\n  const op = changeState.nextOp\n  if ((op[objCtrIdx] === null && op[objActorIdx] !== null) ||\n      (op[objCtrIdx] !== null && op[objActorIdx] === null)) {\n    throw new RangeError(`Mismatched object reference: (${op[objCtrIdx]}, ${op[objActorIdx]})`)\n  }\n  if ((op[keyCtrIdx] === null && op[keyActorIdx] !== null) ||\n      (op[keyCtrIdx] === 0    && op[keyActorIdx] !== null) ||\n      (op[keyCtrIdx] >   0    && op[keyActorIdx] === null)) {\n    throw new RangeError(`Mismatched operation key: (${op[keyCtrIdx]}, ${op[keyActorIdx]})`)\n  }\n}\n\nfunction emptyObjectPatch(objectId, type) {\n  if (type === 'list' || type === 'text') {\n    return {objectId, type, edits: []}\n  } else {\n    return {objectId, type, props: {}}\n  }\n}\n\n/**\n * Returns true if the two given operation IDs have the same actor ID, and the counter of `id2` is\n * exactly `delta` greater than the counter of `id1`.\n */\nfunction opIdDelta(id1, id2, delta = 1) {\n  const parsed1 = parseOpId(id1), parsed2 = parseOpId(id2)\n  return parsed1.actorId === parsed2.actorId && parsed1.counter + delta === parsed2.counter\n}\n\n/**\n * Appends a list edit operation (insert, update, remove) to an array of existing operations. If the\n * last existing operation can be extended (as a multi-op), we do that.\n */\nfunction appendEdit(existingEdits, nextEdit) {\n  if (existingEdits.length === 0) {\n    existingEdits.push(nextEdit)\n    return\n  }\n\n  let lastEdit = existingEdits[existingEdits.length - 1]\n  if (lastEdit.action === 'insert' && nextEdit.action === 'insert' &&\n      lastEdit.index === nextEdit.index - 1 &&\n      lastEdit.value.type === 'value' && nextEdit.value.type === 'value' &&\n      lastEdit.elemId === lastEdit.opId && nextEdit.elemId === nextEdit.opId &&\n      opIdDelta(lastEdit.elemId, nextEdit.elemId, 1) &&\n      lastEdit.value.datatype === nextEdit.value.datatype &&\n      typeof lastEdit.value.value === typeof nextEdit.value.value) {\n    lastEdit.action = 'multi-insert'\n    if (nextEdit.value.datatype) lastEdit.datatype = nextEdit.value.datatype\n    lastEdit.values = [lastEdit.value.value, nextEdit.value.value]\n    delete lastEdit.value\n    delete lastEdit.opId\n\n  } else if (lastEdit.action === 'multi-insert' && nextEdit.action === 'insert' &&\n             lastEdit.index + lastEdit.values.length === nextEdit.index &&\n             nextEdit.value.type === 'value' && nextEdit.elemId === nextEdit.opId &&\n             opIdDelta(lastEdit.elemId, nextEdit.elemId, lastEdit.values.length) &&\n             lastEdit.datatype === nextEdit.value.datatype &&\n             typeof lastEdit.values[0] === typeof nextEdit.value.value) {\n    lastEdit.values.push(nextEdit.value.value)\n\n  } else if (lastEdit.action === 'remove' && nextEdit.action === 'remove' &&\n             lastEdit.index === nextEdit.index) {\n    lastEdit.count += nextEdit.count\n\n  } else {\n    existingEdits.push(nextEdit)\n  }\n}\n\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. This function appends an UpdateEdit to this array. A conflict is represented by\n * having several consecutive edits with the same index, and this can be realised by calling\n * `appendUpdate` several times for the same list element. On the first such call, `firstUpdate`\n * must be true.\n *\n * It is possible that coincidentally the previous edit (potentially arising from a different\n * change) is for the same index. If this is the case, to avoid accidentally treating consecutive\n * updates for the same index as a conflict, we remove the previous edit for the same index. This is\n * safe because the previous edit is overwritten by the new edit being appended, and we know that\n * it's for the same list elements because there are no intervening insertions/deletions that could\n * have changed the indexes.\n */\nfunction appendUpdate(edits, index, elemId, opId, value, firstUpdate) {\n  let insert = false\n  if (firstUpdate) {\n    // Pop all edits for the same index off the end of the edits array. This sequence may begin with\n    // either an insert or an update. If it's an insert, we remember that fact, and use it below.\n    while (!insert && edits.length > 0) {\n      const lastEdit = edits[edits.length - 1]\n      if ((lastEdit.action === 'insert' || lastEdit.action === 'update') && lastEdit.index === index) {\n        edits.pop()\n        insert = (lastEdit.action === 'insert')\n      } else if (lastEdit.action === 'multi-insert' && lastEdit.index + lastEdit.values.length - 1 === index) {\n        lastEdit.values.pop()\n        insert = true\n      } else {\n        break\n      }\n    }\n  }\n\n  // If we popped an insert edit off the edits array, we need to turn the new update into an insert\n  // in order to ensure the list element still gets inserted (just with a new value).\n  if (insert) {\n    appendEdit(edits, {action: 'insert', index, elemId, opId, value})\n  } else {\n    appendEdit(edits, {action: 'update', index, opId, value})\n  }\n}\n\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. We assume that there is a suffix of this array that consists of an insertion at\n * position `index`, followed by zero or more UpdateEdits at the same index. This function rewrites\n * that suffix to be all updates instead. This is needed because sometimes when generating a patch\n * we think we are performing a list insertion, but then it later turns out that there was already\n * an existing value at that list element, and so we actually need to do an update, not an insert.\n *\n * If the suffix is preceded by one or more updates at the same index, those earlier updates are\n * removed by `appendUpdate()` to ensure we don't inadvertently treat them as part of the same\n * conflict.\n */\nfunction convertInsertToUpdate(edits, index, elemId) {\n  let updates = []\n  while (edits.length > 0) {\n    let lastEdit = edits[edits.length - 1]\n    if (lastEdit.action === 'insert') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index')\n      updates.unshift(edits.pop())\n      break\n    } else if (lastEdit.action === 'update') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index')\n      updates.unshift(edits.pop())\n    } else {\n      // It's impossible to encounter a remove edit here because the state machine in\n      // updatePatchProperty() ensures that a property can have either an insert or a remove edit,\n      // but not both. It's impossible to encounter a multi-insert here because multi-inserts always\n      // have equal elemId and opId (i.e. they can only be used for the operation that first inserts\n      // an element, but not for any subsequent assignments to that list element); moreover,\n      // convertInsertToUpdate is only called if an insert action is followed by a non-overwritten\n      // document op. The fact that there is a non-overwritten document op after another op on the\n      // same list element implies that the original insertion op for that list element must be\n      // overwritten, and thus the original insertion op cannot have given rise to a multi-insert.\n      throw new RangeError('last edit has unexpected action')\n    }\n  }\n\n  // Now take the edits we popped off and push them back onto the list again\n  let firstUpdate = true\n  for (let update of updates) {\n    appendUpdate(edits, index, elemId, update.opId, update.value, firstUpdate)\n    firstUpdate = false\n  }\n}\n\n/**\n * Updates `patches` to reflect the operation `op` within the document with state `docState`.\n * Can be called multiple times if there are multiple operations for the same property (e.g. due\n * to a conflict). `propState` is an object that carries over state between such successive\n * invocations for the same property. If the current object is a list, `listIndex` is the index\n * into that list (counting only visible elements). If the operation `op` was already previously\n * in the document, `oldSuccNum` is the value of `op[succNumIdx]` before the current change was\n * applied (allowing us to determine whether this operation was overwritten or deleted in the\n * current change). `oldSuccNum` must be undefined if the operation came from the current change.\n * If we are creating an incremental patch as a result of applying one or more changes, `newBlock`\n * is the block to which the operations are getting written; we will update the metadata on this\n * block. `newBlock` should be null if we are creating a patch for the whole document.\n */\nfunction updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex, oldSuccNum) {\n  const isWholeDoc = !newBlock\n  const type = op[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[op[actionIdx]]] : null\n  const opId = `${op[idCtrIdx]}@${docState.actorIds[op[idActorIdx]]}`\n  const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx]\n  const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx]\n  const elemId = op[keyStrIdx] ? op[keyStrIdx] : `${elemIdCtr}@${docState.actorIds[elemIdActor]}`\n\n  // When the change contains a new make* operation (i.e. with an even-numbered action), record the\n  // new parent-child relationship in objectMeta. TODO: also handle link/move operations.\n  if (op[actionIdx] % 2 === 0 && !docState.objectMeta[opId]) {\n    docState.objectMeta[opId] = {parentObj: objectId, parentKey: elemId, opId, type, children: {}}\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId, opId], {objectId: opId, type, props: {}})\n  }\n\n  // firstOp is true if the current operation is the first of a sequence of ops for the same key\n  const firstOp = !propState[elemId]\n  if (!propState[elemId]) propState[elemId] = {visibleOps: [], hasChild: false}\n\n  // An operation is overwritten if it is a document operation that has at least one successor\n  const isOverwritten = (oldSuccNum !== undefined && op[succNumIdx] > 0)\n\n  // Record all visible values for the property, and whether it has any child object\n  if (!isOverwritten) {\n    propState[elemId].visibleOps.push(op)\n    propState[elemId].hasChild = propState[elemId].hasChild || (op[actionIdx] % 2) === 0 // even-numbered action == make* operation\n  }\n\n  // If one or more of the values of the property is a child object, we update objectMeta to store\n  // all of the visible values of the property (even the non-child-object values). Then, when we\n  // subsequently process an update within that child object, we can construct the patch to\n  // contain the conflicting values.\n  const prevChildren = docState.objectMeta[objectId].children[elemId]\n  if (propState[elemId].hasChild || (prevChildren && Object.keys(prevChildren).length > 0)) {\n    let values = {}\n    for (let visible of propState[elemId].visibleOps) {\n      const opId = `${visible[idCtrIdx]}@${docState.actorIds[visible[idActorIdx]]}`\n      if (ACTIONS[visible[actionIdx]] === 'set') {\n        values[opId] = Object.assign({type: 'value'}, decodeValue(visible[valLenIdx], visible[valRawIdx]))\n      } else if (visible[actionIdx] % 2 === 0) {\n        const objType = visible[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[visible[actionIdx]]] : null\n        values[opId] = emptyObjectPatch(opId, objType)\n      }\n    }\n\n    // Copy so that objectMeta is not modified if an exception is thrown while applying change\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId], values)\n  }\n\n  let patchKey, patchValue\n\n  // For counters, increment operations are succs to the set operation that created the counter,\n  // but in this case we want to add the values rather than overwriting them.\n  if (isOverwritten && ACTIONS[op[actionIdx]] === 'set' && (op[valLenIdx] & 0x0f) === VALUE_TYPE.COUNTER) {\n    // This is the initial set operation that creates a counter. Initialise the counter state\n    // to contain all successors of the set operation. Only if we later find that each of these\n    // successor operations is an increment, we make the counter visible in the patch.\n    if (!propState[elemId]) propState[elemId] = {visibleOps: [], hasChild: false}\n    if (!propState[elemId].counterStates) propState[elemId].counterStates = {}\n    let counterStates = propState[elemId].counterStates\n    let counterState = {opId, value: decodeValue(op[valLenIdx], op[valRawIdx]).value, succs: {}}\n\n    for (let i = 0; i < op[succNumIdx]; i++) {\n      const succOp = `${op[succCtrIdx][i]}@${docState.actorIds[op[succActorIdx][i]]}`\n      counterStates[succOp] = counterState\n      counterState.succs[succOp] = true\n    }\n\n  } else if (ACTIONS[op[actionIdx]] === 'inc') {\n    // Incrementing a previously created counter.\n    if (!propState[elemId] || !propState[elemId].counterStates || !propState[elemId].counterStates[opId]) {\n      throw new RangeError(`increment operation ${opId} for unknown counter`)\n    }\n    let counterState = propState[elemId].counterStates[opId]\n    counterState.value += decodeValue(op[valLenIdx], op[valRawIdx]).value\n    delete counterState.succs[opId]\n\n    if (Object.keys(counterState.succs).length === 0) {\n      patchKey = counterState.opId\n      patchValue = {type: 'value', datatype: 'counter', value: counterState.value}\n      // TODO if the counter is in a list element, we need to add a 'remove' action when deleted\n    }\n\n  } else if (!isOverwritten) {\n    // Add the value to the patch if it is not overwritten (i.e. if it has no succs).\n    if (ACTIONS[op[actionIdx]] === 'set') {\n      patchKey = opId\n      patchValue = Object.assign({type: 'value'}, decodeValue(op[valLenIdx], op[valRawIdx]))\n    } else if (op[actionIdx] % 2 === 0) { // even-numbered action == make* operation\n      if (!patches[opId]) patches[opId] = emptyObjectPatch(opId, type)\n      patchKey = opId\n      patchValue = patches[opId]\n    }\n  }\n\n  if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, docState.objectMeta[objectId].type)\n  const patch = patches[objectId]\n\n  // Updating a list or text object (with elemId key)\n  if (op[keyStrIdx] === null) {\n    // If we come across any document op that was previously non-overwritten/non-deleted, that\n    // means the current list element already had a value before this change was applied, and\n    // therefore the current element cannot be an insert. If we already registered an insert, we\n    // have to convert it into an update.\n    if (oldSuccNum === 0 && !isWholeDoc && propState[elemId].action === 'insert') {\n      propState[elemId].action = 'update'\n      convertInsertToUpdate(patch.edits, listIndex, elemId)\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1\n      }\n    }\n\n    if (patchValue) {\n      // If the op has a non-overwritten value and it came from the change, it's an insert.\n      // (It's not necessarily the case that op[insertIdx] is true: if a list element is concurrently\n      // deleted and updated, the node that first processes the deletion and then the update will\n      // observe the update as a re-insertion of the deleted list element.)\n      if (!propState[elemId].action && (oldSuccNum === undefined || isWholeDoc)) {\n        propState[elemId].action = 'insert'\n        appendEdit(patch.edits, {action: 'insert', index: listIndex, elemId, opId: patchKey, value: patchValue})\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1\n        }\n\n      // If the property has a value and it's not an insert, then it must be an update.\n      // We might have previously registered it as a remove, in which case we convert it to update.\n      } else if (propState[elemId].action === 'remove') {\n        let lastEdit = patch.edits[patch.edits.length - 1]\n        if (lastEdit.action !== 'remove') throw new RangeError('last edit has unexpected type')\n        if (lastEdit.count > 1) lastEdit.count -= 1; else patch.edits.pop()\n        propState[elemId].action = 'update'\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, true)\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1\n        }\n\n      } else {\n        // A 'normal' update\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, !propState[elemId].action)\n        if (!propState[elemId].action) propState[elemId].action = 'update'\n      }\n\n    } else if (oldSuccNum === 0 && !propState[elemId].action) {\n      // If the property used to have a non-overwritten/non-deleted value, but no longer, it's a remove\n      propState[elemId].action = 'remove'\n      appendEdit(patch.edits, {action: 'remove', index: listIndex, count: 1})\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1\n      }\n    }\n\n  } else if (patchValue || !isWholeDoc) {\n    // Updating a map or table (with string key)\n    if (firstOp || !patch.props[op[keyStrIdx]]) patch.props[op[keyStrIdx]] = {}\n    if (patchValue) patch.props[op[keyStrIdx]][patchKey] = patchValue\n  }\n}\n\n/**\n * Applies operations (from one or more changes) to the document by merging the sequence of change\n * ops into the sequence of document ops. The two inputs are `changeState` and `docState`\n * respectively. Assumes that the decoders of both sets of columns are at the position where we want\n * to start merging. `patches` is mutated to reflect the effect of the change operations. `ops` is\n * the operation sequence to apply (as decoded by `groupRelatedOps()`). `docState` is as\n * documented in `applyOps()`. If the operations are updating a list or text object, `listIndex`\n * is the number of visible elements that precede the position at which we start merging.\n * `blockIndex` is the document block number from which we are currently reading.\n */\nfunction mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, listIndex, blockIndex) {\n  const firstOp = changeState.nextOp, insert = firstOp[insertIdx]\n  const objActor = firstOp[objActorIdx], objCtr = firstOp[objCtrIdx]\n  const objectId = objActor === null ? '_root' : `${objCtr}@${docState.actorIds[objActor]}`\n  const idActorIndex = changeState.actorIndex, idActor = docState.actorIds[idActorIndex]\n  let foundListElem = false, elemVisible = false, propState = {}, docOp\n  ;({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n  let docOpsConsumed = (docOp === null ? 0 : 1)\n  let docOpOldSuccNum = (docOp === null ? 0 : docOp[succNumIdx])\n  let changeOp = null, changeOps = [], changeCols = [], predSeen = [], lastChangeKey = null\n  changeState.objectIds.add(objectId)\n\n  // Merge the two inputs: the sequence of ops in the doc, and the sequence of ops in the change.\n  // At each iteration, we either output the doc's op (possibly updated based on the change's ops)\n  // or output an op from the change.\n  while (true) {\n    // The array `changeOps` contains operations from the change(s) we're applying. When the array\n    // is empty, we load changes from the change. Typically we load only a single operation at a\n    // time, with two exceptions: 1. all operations that update the same key or list element in the\n    // same object are put into changeOps at the same time (this is needed so that we can update the\n    // succ columns of the document ops correctly); 2. a run of consecutive insertions is also\n    // placed into changeOps in one go.\n    //\n    // When we have processed all the ops in changeOps we try to see whether there are further\n    // operations that we can also process while we're at it. Those operations must be for the same\n    // object, they must be for a key or list element that appears later in the document, they must\n    // either all be insertions or all be non-insertions, and if insertions, they must be\n    // consecutive. If these conditions are satisfied, that means the operations can be processed in\n    // the same pass. If we encounter an operation that does not meet these conditions, we leave\n    // changeOps empty, and this function returns after having processed any remaining document ops.\n    //\n    // Any operations that could not be processed in a single pass remain in changeState; applyOps\n    // will seek to the appropriate position and then call mergeDocChangeOps again.\n    if (changeOps.length === 0) {\n      foundListElem = false\n\n      let nextOp = changeState.nextOp\n      while (!changeState.done && nextOp[idActorIdx] === idActorIndex && nextOp[insertIdx] === insert &&\n             nextOp[objActorIdx] === firstOp[objActorIdx] && nextOp[objCtrIdx] === firstOp[objCtrIdx]) {\n\n        // Check if the operation's pred references a previous operation in changeOps\n        const lastOp = (changeOps.length > 0) ? changeOps[changeOps.length - 1] : null\n        let isOverwrite = false\n        for (let i = 0; i < nextOp[predNumIdx]; i++) {\n          for (let prevOp of changeOps) {\n            if (nextOp[predActorIdx][i] === prevOp[idActorIdx] && nextOp[predCtrIdx][i] === prevOp[idCtrIdx]) {\n              isOverwrite = true\n            }\n          }\n        }\n\n        // If any of the following `if` statements is true, we add `nextOp` to `changeOps`. If they\n        // are all false, we break out of the loop and stop adding to `changeOps`.\n        if (nextOp === firstOp) {\n          // First change operation in a mergeDocChangeOps call is always used\n        } else if (insert && lastOp !== null && nextOp[keyStrIdx] === null &&\n                   nextOp[keyActorIdx] === lastOp[idActorIdx] &&\n                   nextOp[keyCtrIdx] === lastOp[idCtrIdx]) {\n          // Collect consecutive insertions\n        } else if (!insert && lastOp !== null && nextOp[keyStrIdx] !== null &&\n                   nextOp[keyStrIdx] === lastOp[keyStrIdx] && !isOverwrite) {\n          // Collect several updates to the same key\n        } else if (!insert && lastOp !== null &&\n                   nextOp[keyStrIdx] === null && lastOp[keyStrIdx] === null &&\n                   nextOp[keyActorIdx] === lastOp[keyActorIdx] &&\n                   nextOp[keyCtrIdx] === lastOp[keyCtrIdx] && !isOverwrite) {\n          // Collect several updates to the same list element\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] === null &&\n                   docOp && docOp[insertIdx] && docOp[keyStrIdx] === null &&\n                   docOp[idActorIdx] === nextOp[keyActorIdx] &&\n                   docOp[idCtrIdx] === nextOp[keyCtrIdx]) {\n          // When updating/deleting list elements, keep going if the next elemId in the change\n          // equals the next elemId in the doc (i.e. we're updating several consecutive elements)\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] !== null &&\n                   lastChangeKey !== null && lastChangeKey < nextOp[keyStrIdx]) {\n          // Allow a single mergeDocChangeOps call to process changes to several keys in the same\n          // object, provided that they appear in ascending order\n        } else break\n\n        lastChangeKey = (nextOp !== null) ? nextOp[keyStrIdx] : null\n        changeOps.push(changeState.nextOp)\n        changeCols.push(changeState.columns)\n        predSeen.push(new Array(changeState.nextOp[predNumIdx]))\n        readNextChangeOp(docState, changeState)\n        nextOp = changeState.nextOp\n      }\n    }\n\n    if (changeOps.length > 0) changeOp = changeOps[0]\n    const inCorrectObject = docOp && docOp[objActorIdx] === changeOp[objActorIdx] && docOp[objCtrIdx] === changeOp[objCtrIdx]\n    const keyMatches      = docOp && docOp[keyStrIdx] !== null && docOp[keyStrIdx] === changeOp[keyStrIdx]\n    const listElemMatches = docOp && docOp[keyStrIdx] === null && changeOp[keyStrIdx] === null &&\n      ((!docOp[insertIdx] && docOp[keyActorIdx] === changeOp[keyActorIdx] && docOp[keyCtrIdx] === changeOp[keyCtrIdx]) ||\n        (docOp[insertIdx] && docOp[idActorIdx]  === changeOp[keyActorIdx] && docOp[idCtrIdx]  === changeOp[keyCtrIdx]))\n\n    // We keep going until we run out of ops in the change, except that even when we run out, we\n    // keep going until we have processed all doc ops for the current key/list element.\n    if (changeOps.length === 0 && !(inCorrectObject && (keyMatches || listElemMatches))) break\n\n    let takeDocOp = false, takeChangeOps = 0\n\n    // The change operations come first if we are inserting list elements (seekToOp already\n    // determines the correct insertion position), if there is no document operation, if the next\n    // document operation is for a different object, or if the change op's string key is\n    // lexicographically first (TODO check ordering of keys beyond the basic multilingual plane).\n    if (insert || !inCorrectObject ||\n        (docOp[keyStrIdx] === null && changeOp[keyStrIdx] !== null) ||\n        (docOp[keyStrIdx] !== null && changeOp[keyStrIdx] !== null && changeOp[keyStrIdx] < docOp[keyStrIdx])) {\n      // Take the operations from the change\n      takeChangeOps = changeOps.length\n      if (!inCorrectObject && !foundListElem && changeOp[keyStrIdx] === null && !changeOp[insertIdx]) {\n        // This can happen if we first update one list element, then another one earlier in the\n        // list. That is not allowed: list element updates must occur in ascending order.\n        throw new RangeError(\"could not find list element with ID: \" +\n                             `${changeOp[keyCtrIdx]}@${docState.actorIds[changeOp[keyActorIdx]]}`)\n      }\n\n    } else if (keyMatches || listElemMatches || foundListElem) {\n      // The doc operation is for the same key or list element in the same object as the change\n      // ops, so we merge them. First, if any of the change ops' `pred` matches the opId of the\n      // document operation, we update the document operation's `succ` accordingly.\n      for (let opIndex = 0; opIndex < changeOps.length; opIndex++) {\n        const op = changeOps[opIndex]\n        for (let i = 0; i < op[predNumIdx]; i++) {\n          if (op[predActorIdx][i] === docOp[idActorIdx] && op[predCtrIdx][i] === docOp[idCtrIdx]) {\n            // Insert into the doc op's succ list such that the lists remains sorted\n            let j = 0\n            while (j < docOp[succNumIdx] && (docOp[succCtrIdx][j] < op[idCtrIdx] ||\n                   docOp[succCtrIdx][j] === op[idCtrIdx] && docState.actorIds[docOp[succActorIdx][j]] < idActor)) j++\n            docOp[succCtrIdx].splice(j, 0, op[idCtrIdx])\n            docOp[succActorIdx].splice(j, 0, idActorIndex)\n            docOp[succNumIdx]++\n            predSeen[opIndex][i] = true\n            break\n          }\n        }\n      }\n\n      if (listElemMatches) foundListElem = true\n\n      if (foundListElem && !listElemMatches) {\n        // If the previous docOp was for the correct list element, and the current docOp is for\n        // the wrong list element, then place the current changeOp before the docOp.\n        takeChangeOps = changeOps.length\n\n      } else if (changeOps.length === 0 || docOp[idCtrIdx] < changeOp[idCtrIdx] ||\n          (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] < idActor)) {\n        // When we have several operations for the same object and the same key, we want to keep\n        // them sorted in ascending order by opId. Here we have docOp with a lower opId, so we\n        // output it first.\n        takeDocOp = true\n        updatePatchProperty(patches, newBlock, objectId, docOp, docState, propState, listIndex, docOpOldSuccNum)\n\n        // A deletion op in the change is represented in the document only by its entries in the\n        // succ list of the operations it overwrites; it has no separate row in the set of ops.\n        for (let i = changeOps.length - 1; i >= 0; i--) {\n          let deleted = true\n          for (let j = 0; j < changeOps[i][predNumIdx]; j++) {\n            if (!predSeen[i][j]) deleted = false\n          }\n          if (ACTIONS[changeOps[i][actionIdx]] === 'del' && deleted) {\n            changeOps.splice(i, 1)\n            changeCols.splice(i, 1)\n            predSeen.splice(i, 1)\n          }\n        }\n\n      } else if (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] === idActor) {\n        throw new RangeError(`duplicate operation ID: ${changeOp[idCtrIdx]}@${idActor}`)\n      } else {\n        // The changeOp has the lower opId, so we output it first.\n        takeChangeOps = 1\n      }\n    } else {\n      // The document operation comes first if its string key is lexicographically first, or if\n      // we're using opId keys and the keys don't match (i.e. we scan the document until we find a\n      // matching key).\n      takeDocOp = true\n    }\n\n    if (takeDocOp) {\n      appendOperation(outCols, docState.blocks[blockIndex].columns, docOp)\n      addBlockOperation(newBlock, docOp, docState.actorIds, false)\n\n      if (docOp[insertIdx] && elemVisible) {\n        elemVisible = false\n        listIndex++\n      }\n      if (docOp[succNumIdx] === 0) elemVisible = true\n      newBlock.numOps++\n      ;({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n      if (docOp !== null) {\n        docOpsConsumed++\n        docOpOldSuccNum = docOp[succNumIdx]\n      }\n    }\n\n    if (takeChangeOps > 0) {\n      for (let i = 0; i < takeChangeOps; i++) {\n        let op = changeOps[i]\n        // Check that we've seen all ops mentioned in `pred` (they must all have lower opIds than\n        // the change op's own opId, so we must have seen them already)\n        for (let j = 0; j < op[predNumIdx]; j++) {\n          if (!predSeen[i][j]) {\n            throw new RangeError(`no matching operation for pred: ${op[predCtrIdx][j]}@${docState.actorIds[op[predActorIdx][j]]}`)\n          }\n        }\n        appendOperation(outCols, changeCols[i], op)\n        addBlockOperation(newBlock, op, docState.actorIds, true)\n        updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex)\n\n        if (op[insertIdx]) {\n          elemVisible = false\n          listIndex++\n        } else {\n          elemVisible = true\n        }\n      }\n\n      if (takeChangeOps === changeOps.length) {\n        changeOps.length = 0\n        changeCols.length = 0\n        predSeen.length = 0\n      } else {\n        changeOps.splice(0, takeChangeOps)\n        changeCols.splice(0, takeChangeOps)\n        predSeen.splice(0, takeChangeOps)\n      }\n      newBlock.numOps += takeChangeOps\n    }\n  }\n\n  if (docOp) {\n    appendOperation(outCols, docState.blocks[blockIndex].columns, docOp)\n    newBlock.numOps++\n    addBlockOperation(newBlock, docOp, docState.actorIds, false)\n  }\n  return {docOpsConsumed, blockIndex}\n}\n\n/**\n * Applies operations from the change (or series of changes) in `changeState` to the document\n * `docState`. Passing `changeState` to `readNextChangeOp` allows iterating over the change ops.\n * `docState` is an object with keys:\n *   - `actorIds` is an array of actorIds (as hex strings) occurring in the document (values in\n *     the document's objActor/keyActor/idActor/... columns are indexes into this array).\n *   - `blocks` is an array of all the blocks of operations in the document.\n *   - `objectMeta` is a map from objectId to metadata about that object.\n *\n * `docState` is mutated to contain the updated document state.\n * `patches` is a patch object that is mutated to reflect the operations applied by this function.\n */\nfunction applyOps(patches, changeState, docState) {\n  const [objActorNum, objCtr, keyActorNum, keyCtr, keyStr, idActorNum, idCtr, insert] = changeState.nextOp\n  const objActor = objActorNum === null ? null : docState.actorIds[objActorNum]\n  const keyActor = keyActorNum === null ? null : docState.actorIds[keyActorNum]\n  const ops = {\n    objActor, objActorNum, objCtr, keyActor, keyActorNum, keyCtr, keyStr,\n    idActor: docState.actorIds[idActorNum], idCtr, insert,\n    objId: objActor === null ? '_root' : `${objCtr}@${objActor}`\n  }\n\n  const {blockIndex, skipCount, visibleCount} = seekToOp(docState, ops)\n  const block = docState.blocks[blockIndex]\n  for (let col of block.columns) col.decoder.reset()\n\n  const resetFirstVisible = (skipCount === 0) || (block.firstVisibleActor === undefined) ||\n    (!insert && block.firstVisibleActor === keyActorNum && block.firstVisibleCtr === keyCtr)\n  const newBlock = {\n    columns: undefined,\n    bloom: new Uint8Array(block.bloom),\n    numOps: skipCount,\n    lastKey: block.lastKey,\n    numVisible: block.numVisible,\n    lastObjectActor: block.lastObjectActor,\n    lastObjectCtr: block.lastObjectCtr,\n    firstVisibleActor: resetFirstVisible ? undefined : block.firstVisibleActor,\n    firstVisibleCtr: resetFirstVisible ? undefined : block.firstVisibleCtr,\n    lastVisibleActor: undefined,\n    lastVisibleCtr: undefined\n  }\n\n  // Copy the operations up to the insertion position (the first skipCount operations)\n  const outCols = block.columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n  copyColumns(outCols, block.columns, skipCount)\n\n  // Apply the operations from the change. This may cause blockIndex to move forwards if the\n  // property being updated straddles a block boundary.\n  const {blockIndex: lastBlockIndex, docOpsConsumed} =\n    mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, visibleCount, blockIndex)\n\n  // Copy the remaining operations after the insertion position\n  const lastBlock = docState.blocks[lastBlockIndex]\n  let copyAfterMerge = -skipCount - docOpsConsumed\n  for (let i = blockIndex; i <= lastBlockIndex; i++) copyAfterMerge += docState.blocks[i].numOps\n  copyColumns(outCols, lastBlock.columns, copyAfterMerge)\n  newBlock.numOps += copyAfterMerge\n\n  for (let col of lastBlock.columns) {\n    if (!col.decoder.done) throw new RangeError(`excess ops in column ${col.columnId}`)\n  }\n\n  newBlock.columns = outCols.map(col => {\n    const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n    return {columnId: col.columnId, decoder}\n  })\n\n  if (blockIndex === lastBlockIndex && newBlock.numOps <= MAX_BLOCK_SIZE) {\n    // The result is just one output block\n    if (copyAfterMerge > 0 && block.lastVisibleActor !== undefined && block.lastVisibleCtr !== undefined) {\n      // It's possible that none of the ops after the merge point are visible, in which case the\n      // lastVisible may not be strictly correct, because it may refer to an operation before the\n      // merge point rather than a list element inserted by the current change. However, this doesn't\n      // matter, because the only purpose for which we need it is to check whether one block ends with\n      // the same visible element as the next block starts with (to avoid double-counting its index);\n      // if the last list element of a block is invisible, the exact value of lastVisible doesn't\n      // matter since it will be different from the next block's firstVisible in any case.\n      newBlock.lastVisibleActor = block.lastVisibleActor\n      newBlock.lastVisibleCtr = block.lastVisibleCtr\n    }\n\n    docState.blocks[blockIndex] = newBlock\n\n  } else {\n    // Oversized output block must be split into smaller blocks\n    const newBlocks = splitBlock(newBlock)\n    docState.blocks.splice(blockIndex, lastBlockIndex - blockIndex + 1, ...newBlocks)\n  }\n}\n\n/**\n * Updates the columns in a document's operation blocks to contain all the columns in a change\n * (including any column types we don't recognise, which have been generated by a future version\n * of Automerge).\n */\nfunction updateBlockColumns(docState, changeCols) {\n  // Check that the columns of a change appear at the index at which we expect them to be\n  if (changeCols[objActorIdx ].columnId !== CHANGE_COLUMNS[objActorIdx ].columnId || CHANGE_COLUMNS[objActorIdx ].columnName !== 'objActor'  ||\n      changeCols[objCtrIdx   ].columnId !== CHANGE_COLUMNS[objCtrIdx   ].columnId || CHANGE_COLUMNS[objCtrIdx   ].columnName !== 'objCtr'    ||\n      changeCols[keyActorIdx ].columnId !== CHANGE_COLUMNS[keyActorIdx ].columnId || CHANGE_COLUMNS[keyActorIdx ].columnName !== 'keyActor'  ||\n      changeCols[keyCtrIdx   ].columnId !== CHANGE_COLUMNS[keyCtrIdx   ].columnId || CHANGE_COLUMNS[keyCtrIdx   ].columnName !== 'keyCtr'    ||\n      changeCols[keyStrIdx   ].columnId !== CHANGE_COLUMNS[keyStrIdx   ].columnId || CHANGE_COLUMNS[keyStrIdx   ].columnName !== 'keyStr'    ||\n      changeCols[idActorIdx  ].columnId !== CHANGE_COLUMNS[idActorIdx  ].columnId || CHANGE_COLUMNS[idActorIdx  ].columnName !== 'idActor'   ||\n      changeCols[idCtrIdx    ].columnId !== CHANGE_COLUMNS[idCtrIdx    ].columnId || CHANGE_COLUMNS[idCtrIdx    ].columnName !== 'idCtr'     ||\n      changeCols[insertIdx   ].columnId !== CHANGE_COLUMNS[insertIdx   ].columnId || CHANGE_COLUMNS[insertIdx   ].columnName !== 'insert'    ||\n      changeCols[actionIdx   ].columnId !== CHANGE_COLUMNS[actionIdx   ].columnId || CHANGE_COLUMNS[actionIdx   ].columnName !== 'action'    ||\n      changeCols[valLenIdx   ].columnId !== CHANGE_COLUMNS[valLenIdx   ].columnId || CHANGE_COLUMNS[valLenIdx   ].columnName !== 'valLen'    ||\n      changeCols[valRawIdx   ].columnId !== CHANGE_COLUMNS[valRawIdx   ].columnId || CHANGE_COLUMNS[valRawIdx   ].columnName !== 'valRaw'    ||\n      changeCols[predNumIdx  ].columnId !== CHANGE_COLUMNS[predNumIdx  ].columnId || CHANGE_COLUMNS[predNumIdx  ].columnName !== 'predNum'   ||\n      changeCols[predActorIdx].columnId !== CHANGE_COLUMNS[predActorIdx].columnId || CHANGE_COLUMNS[predActorIdx].columnName !== 'predActor' ||\n      changeCols[predCtrIdx  ].columnId !== CHANGE_COLUMNS[predCtrIdx  ].columnId || CHANGE_COLUMNS[predCtrIdx  ].columnName !== 'predCtr') {\n    throw new RangeError('unexpected columnId')\n  }\n\n  // Check if there any columns in the change that are not in the document, apart from pred*\n  const docCols = docState.blocks[0].columns\n  if (!changeCols.every(changeCol => PRED_COLUMN_IDS.includes(changeCol.columnId) ||\n                                     docCols.find(docCol => docCol.columnId === changeCol.columnId))) {\n    let allCols = docCols.map(docCol => ({columnId: docCol.columnId}))\n    for (let changeCol of changeCols) {\n      const { columnId } = changeCol\n      if (!PRED_COLUMN_IDS.includes(columnId) && !docCols.find(docCol => docCol.columnId === columnId)) {\n        allCols.push({columnId})\n      }\n    }\n    allCols.sort((a, b) => a.columnId - b.columnId)\n\n    for (let blockIndex = 0; blockIndex < docState.blocks.length; blockIndex++) {\n      let block = copyObject(docState.blocks[blockIndex])\n      block.columns = makeDecoders(block.columns.map(col => ({columnId: col.columnId, buffer: col.decoder.buf})), allCols)\n      docState.blocks[blockIndex] = block\n    }\n  }\n}\n\n/**\n * Takes a decoded change header, including an array of actorIds. Returns an object of the form\n * `{actorIds, actorTable}`, where `actorIds` is an updated array of actorIds appearing in the\n * document (including the new change's actorId). `actorTable` is an array of integers where\n * `actorTable[i]` contains the document's actor index for the actor that has index `i` in the\n * change (`i == 0` is the author of the change).\n */\nfunction getActorTable(actorIds, change) {\n  if (actorIds.indexOf(change.actorIds[0]) < 0) {\n    if (change.seq !== 1) {\n      throw new RangeError(`Seq ${change.seq} is the first change for actor ${change.actorIds[0]}`)\n    }\n    // Use concat, not push, so that the original array is not mutated\n    actorIds = actorIds.concat([change.actorIds[0]])\n  }\n  const actorTable = [] // translate from change's actor index to doc's actor index\n  for (let actorId of change.actorIds) {\n    const index = actorIds.indexOf(actorId)\n    if (index < 0) {\n      throw new RangeError(`actorId ${actorId} is not known to document`)\n    }\n    actorTable.push(index)\n  }\n  return {actorIds, actorTable}\n}\n\n/**\n * Finalises the patch for a change. `patches` is a map from objectIds to patch for that\n * particular object, `objectIds` is the array of IDs of objects that are created or updated in the\n * change, and `docState` is an object containing various bits of document state, including\n * `objectMeta`, a map from objectIds to metadata about that object (such as its parent in the\n * document tree). Mutates `patches` such that child objects are linked into their parent object,\n * all the way to the root object.\n */\nfunction setupPatches(patches, objectIds, docState) {\n  for (let objectId of objectIds) {\n    let meta = docState.objectMeta[objectId], childMeta = null, patchExists = false\n    while (true) {\n      const hasChildren = childMeta && Object.keys(meta.children[childMeta.parentKey]).length > 0\n      if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, meta.type)\n\n      if (childMeta && hasChildren) {\n        if (meta.type === 'list' || meta.type === 'text') {\n          // In list/text objects, parentKey is an elemID. First see if it already appears in an edit\n          for (let edit of patches[objectId].edits) {\n            if (edit.opId && meta.children[childMeta.parentKey][edit.opId]) {\n              patchExists = true\n            }\n          }\n\n          // If we need to add an edit, we first have to translate the elemId into an index\n          if (!patchExists) {\n            const obj = parseOpId(objectId), elem = parseOpId(childMeta.parentKey)\n            const seekPos = {\n              objActor: obj.actorId,  objCtr: obj.counter,\n              keyActor: elem.actorId, keyCtr: elem.counter,\n              objActorNum: docState.actorIds.indexOf(obj.actorId),\n              keyActorNum: docState.actorIds.indexOf(elem.actorId),\n              keyStr:   null,         insert: false,\n              objId:    objectId\n            }\n            const { visibleCount } = seekToOp(docState, seekPos)\n\n            for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n              let patchValue = value\n              if (value.objectId) {\n                if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type)\n                patchValue = patches[value.objectId]\n              }\n              const edit = {action: 'update', index: visibleCount, opId, value: patchValue}\n              appendEdit(patches[objectId].edits, edit)\n            }\n          }\n\n        } else {\n          // Non-list object: parentKey is the name of the property being updated (a string)\n          if (!patches[objectId].props[childMeta.parentKey]) {\n            patches[objectId].props[childMeta.parentKey] = {}\n          }\n          let values = patches[objectId].props[childMeta.parentKey]\n\n          for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n            if (values[opId]) {\n              patchExists = true\n            } else if (value.objectId) {\n              if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type)\n              values[opId] = patches[value.objectId]\n            } else {\n              values[opId] = value\n            }\n          }\n        }\n      }\n\n      if (patchExists || !meta.parentObj || (childMeta && !hasChildren)) break\n      childMeta = meta\n      objectId = meta.parentObj\n      meta = docState.objectMeta[objectId]\n    }\n  }\n  return patches\n}\n\n/**\n * Takes an array of decoded changes and applies them to a document. `docState` contains a bunch of\n * fields describing the document state. This function mutates `docState` to contain the updated\n * document state, and mutates `patches` to contain a patch to return to the frontend. Only the\n * top-level `docState` object is mutated; all nested objects within it are treated as immutable.\n * `objectIds` is mutated to contain the IDs of objects that are updated in any of the changes.\n *\n * The function detects duplicate changes that we've already applied by looking up each change's\n * hash in `docState.changeIndexByHash`. If we deferred the hash graph computation, that structure\n * will be incomplete, and we run the risk of applying the same change twice. However, we still have\n * the sequence numbers for detecting duplicates. If `throwExceptions` is true, we assume that the\n * set of change hashes is complete, and therefore a duplicate sequence number indicates illegal\n * behaviour. If `throwExceptions` is false, and we detect a possible sequence number reuse, we\n * don't throw an exception but instead enqueue all of the changes. This gives us a chance to\n * recompute the hash graph and eliminate duplicates before raising an error to the application.\n *\n * Returns a two-element array `[applied, enqueued]`, where `applied` is an array of changes that\n * have been applied to the document, and `enqueued` is an array of changes that have not yet been\n * applied because they are missing a dependency.\n */\nfunction applyChanges(patches, decodedChanges, docState, objectIds, throwExceptions) {\n  let heads = new Set(docState.heads), changeHashes = new Set()\n  let clock = copyObject(docState.clock)\n  let applied = [], enqueued = []\n\n  for (let change of decodedChanges) {\n    // Skip any duplicate changes that we have already seen\n    if (docState.changeIndexByHash[change.hash] !== undefined || changeHashes.has(change.hash)) continue\n\n    const expectedSeq = (clock[change.actor] || 0) + 1\n    let causallyReady = true\n\n    for (let dep of change.deps) {\n      const depIndex = docState.changeIndexByHash[dep]\n      if ((depIndex === undefined || depIndex === -1) && !changeHashes.has(dep)) {\n        causallyReady = false\n      }\n    }\n\n    if (!causallyReady) {\n      enqueued.push(change)\n    } else if (change.seq < expectedSeq) {\n      if (throwExceptions) {\n        throw new RangeError(`Reuse of sequence number ${change.seq} for actor ${change.actor}`)\n      } else {\n        return [[], decodedChanges]\n      }\n    } else if (change.seq > expectedSeq) {\n      throw new RangeError(`Skipped sequence number ${expectedSeq} for actor ${change.actor}`)\n    } else {\n      clock[change.actor] = change.seq\n      changeHashes.add(change.hash)\n      for (let dep of change.deps) heads.delete(dep)\n      heads.add(change.hash)\n      applied.push(change)\n    }\n  }\n\n  if (applied.length > 0) {\n    let changeState = {changes: applied, changeIndex: -1, objectIds}\n    readNextChangeOp(docState, changeState)\n    while (!changeState.done) applyOps(patches, changeState, docState)\n\n    docState.heads = [...heads].sort()\n    docState.clock = clock\n  }\n  return [applied, enqueued]\n}\n\n/**\n * Scans the operations in a document and generates a patch that can be sent to the frontend to\n * instantiate the current state of the document. `objectMeta` is mutated to contain information\n * about the parent and children of each object in the document.\n */\nfunction documentPatch(docState) {\n  for (let col of docState.blocks[0].columns) col.decoder.reset()\n  let propState = {}, docOp = null, blockIndex = 0\n  let patches = {_root: {objectId: '_root', type: 'map', props: {}}}\n  let lastObjActor = null, lastObjCtr = null, objectId = '_root', elemVisible = false, listIndex = 0\n\n  while (true) {\n    ({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n    if (docOp === null) break\n    if (docOp[objActorIdx] !== lastObjActor || docOp[objCtrIdx] !== lastObjCtr) {\n      objectId = `${docOp[objCtrIdx]}@${docState.actorIds[docOp[objActorIdx]]}`\n      lastObjActor = docOp[objActorIdx]\n      lastObjCtr = docOp[objCtrIdx]\n      propState = {}\n      listIndex = 0\n      elemVisible = false\n    }\n\n    if (docOp[insertIdx] && elemVisible) {\n      elemVisible = false\n      listIndex++\n    }\n    if (docOp[succNumIdx] === 0) elemVisible = true\n    if (docOp[idCtrIdx] > docState.maxOp) docState.maxOp = docOp[idCtrIdx]\n    for (let i = 0; i < docOp[succNumIdx]; i++) {\n      if (docOp[succCtrIdx][i] > docState.maxOp) docState.maxOp = docOp[succCtrIdx][i]\n    }\n\n    updatePatchProperty(patches, null, objectId, docOp, docState, propState, listIndex, docOp[succNumIdx])\n  }\n  return patches._root\n}\n\n/**\n * Takes an encoded document whose headers have been parsed using `decodeDocumentHeader()` and reads\n * from it the list of changes. Returns the document's current vector clock, i.e. an object mapping\n * each actor ID (as a hex string) to the number of changes seen from that actor. Also returns an\n * array of the actorIds whose most recent change has no dependents (i.e. the actors that\n * contributed the current heads of the document), and an array of encoders that has been\n * initialised to contain the columns of the changes list.\n */\nfunction readDocumentChanges(doc) {\n  const columns = makeDecoders(doc.changesColumns, DOCUMENT_COLUMNS)\n  const actorD = columns[0].decoder, seqD = columns[1].decoder\n  const depsNumD = columns[5].decoder, depsIndexD = columns[6].decoder\n  if (columns[0].columnId !== DOCUMENT_COLUMNS[0].columnId || DOCUMENT_COLUMNS[0].columnName !== 'actor' ||\n      columns[1].columnId !== DOCUMENT_COLUMNS[1].columnId || DOCUMENT_COLUMNS[1].columnName !== 'seq' ||\n      columns[5].columnId !== DOCUMENT_COLUMNS[5].columnId || DOCUMENT_COLUMNS[5].columnName !== 'depsNum' ||\n      columns[6].columnId !== DOCUMENT_COLUMNS[6].columnId || DOCUMENT_COLUMNS[6].columnName !== 'depsIndex') {\n    throw new RangeError('unexpected columnId')\n  }\n\n  let numChanges = 0, clock = {}, actorNums = [], headIndexes = new Set()\n  while (!actorD.done) {\n    const actorNum = actorD.readValue(), seq = seqD.readValue(), depsNum = depsNumD.readValue()\n    const actorId = doc.actorIds[actorNum]\n    if (seq !== 1 && seq !== clock[actorId] + 1) {\n      throw new RangeError(`Expected seq ${clock[actorId] + 1}, got ${seq} for actor ${actorId}`)\n    }\n    actorNums.push(actorNum)\n    clock[actorId] = seq\n    headIndexes.add(numChanges)\n    for (let j = 0; j < depsNum; j++) headIndexes.delete(depsIndexD.readValue())\n    numChanges++\n  }\n  const headActors = [...headIndexes].map(index => doc.actorIds[actorNums[index]]).sort()\n\n  for (let col of columns) col.decoder.reset()\n  const encoders = columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n  copyColumns(encoders, columns, numChanges)\n  return {clock, headActors, encoders, numChanges}\n}\n\n/**\n * Records the metadata about a change in the appropriate columns.\n */\nfunction appendChange(columns, change, actorIds, changeIndexByHash) {\n  appendOperation(columns, DOCUMENT_COLUMNS, [\n    actorIds.indexOf(change.actor), // actor\n    change.seq, // seq\n    change.maxOp, // maxOp\n    change.time, // time\n    change.message, // message\n    change.deps.length, // depsNum\n    change.deps.map(dep => changeIndexByHash[dep]), // depsIndex\n    change.extraBytes ? (change.extraBytes.byteLength << 4 | VALUE_TYPE.BYTES) : VALUE_TYPE.BYTES, // extraLen\n    change.extraBytes // extraRaw\n  ])\n}\n\nclass BackendDoc {\n  constructor(buffer) {\n    this.maxOp = 0\n    this.haveHashGraph = false\n    this.changes = []\n    this.changeIndexByHash = {}\n    this.dependenciesByHash = {}\n    this.dependentsByHash = {}\n    this.hashesByActor = {}\n    this.actorIds = []\n    this.heads = []\n    this.clock = {}\n    this.queue = []\n    this.objectMeta = {_root: {parentObj: null, parentKey: null, opId: null, type: 'map', children: {}}}\n\n    if (buffer) {\n      const doc = decodeDocumentHeader(buffer)\n      const {clock, headActors, encoders, numChanges} = readDocumentChanges(doc)\n      this.binaryDoc = buffer\n      this.changes = new Array(numChanges)\n      this.actorIds = doc.actorIds\n      this.heads = doc.heads\n      this.clock = clock\n      this.changesEncoders = encoders\n      this.extraBytes = doc.extraBytes\n\n      // If there is a single head, we can unambiguously point at the actorId and sequence number of\n      // the head hash without having to reconstruct the hash graph\n      if (doc.heads.length === 1 && headActors.length === 1) {\n        this.hashesByActor[headActors[0]] = []\n        this.hashesByActor[headActors[0]][clock[headActors[0]] - 1] = doc.heads[0]\n      }\n\n      // The encoded document gives each change an index, and expresses dependencies in terms of\n      // those indexes. Initialise the translation table from hash to index.\n      if (doc.heads.length === doc.headsIndexes.length) {\n        for (let i = 0; i < doc.heads.length; i++) {\n          this.changeIndexByHash[doc.heads[i]] = doc.headsIndexes[i]\n        }\n      } else if (doc.heads.length === 1) {\n        // If there is only one head, it must be the last change\n        this.changeIndexByHash[doc.heads[0]] = numChanges - 1\n      } else {\n        // We know the heads hashes, but not their indexes\n        for (let head of doc.heads) this.changeIndexByHash[head] = -1\n      }\n\n      this.blocks = [{columns: makeDecoders(doc.opsColumns, DOC_OPS_COLUMNS)}]\n      updateBlockMetadata(this.blocks[0])\n      if (this.blocks[0].numOps > MAX_BLOCK_SIZE) {\n        this.blocks = splitBlock(this.blocks[0])\n      }\n\n      let docState = {blocks: this.blocks, actorIds: this.actorIds, objectMeta: this.objectMeta, maxOp: 0}\n      this.initPatch = documentPatch(docState)\n      this.maxOp = docState.maxOp\n\n    } else {\n      this.haveHashGraph = true\n      this.changesEncoders = DOCUMENT_COLUMNS.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n      this.blocks = [{\n        columns: makeDecoders([], DOC_OPS_COLUMNS),\n        bloom: new Uint8Array(BLOOM_FILTER_SIZE),\n        numOps: 0,\n        lastKey: undefined,\n        numVisible: undefined,\n        lastObjectActor: undefined,\n        lastObjectCtr: undefined,\n        firstVisibleActor: undefined,\n        firstVisibleCtr: undefined,\n        lastVisibleActor: undefined,\n        lastVisibleCtr: undefined\n      }]\n    }\n  }\n\n  /**\n   * Makes a copy of this BackendDoc that can be independently modified.\n   */\n  clone() {\n    let copy = new BackendDoc()\n    copy.maxOp = this.maxOp\n    copy.haveHashGraph = this.haveHashGraph\n    copy.changes = this.changes.slice()\n    copy.changeIndexByHash = copyObject(this.changeIndexByHash)\n    copy.dependenciesByHash = copyObject(this.dependenciesByHash)\n    copy.dependentsByHash = Object.entries(this.dependentsByHash).reduce((acc, [k, v]) => { acc[k] = v.slice(); return acc }, {})\n    copy.hashesByActor = Object.entries(this.hashesByActor).reduce((acc, [k, v]) => { acc[k] = v.slice(); return acc }, {})\n    copy.actorIds = this.actorIds // immutable, no copying needed\n    copy.heads = this.heads // immutable, no copying needed\n    copy.clock = this.clock // immutable, no copying needed\n    copy.blocks = this.blocks // immutable, no copying needed\n    copy.objectMeta = this.objectMeta // immutable, no copying needed\n    copy.queue = this.queue // immutable, no copying needed\n    return copy\n  }\n\n  /**\n   * Parses the changes given as Uint8Arrays in `changeBuffers`, and applies them to the current\n   * document. Returns a patch to apply to the frontend. If an exception is thrown, the document\n   * object is not modified.\n   */\n  applyChanges(changeBuffers, isLocal = false) {\n    // decoded change has the form { actor, seq, startOp, time, message, deps, actorIds, hash, columns, buffer }\n    let decodedChanges = changeBuffers.map(buffer => {\n      const decoded = decodeChangeColumns(buffer)\n      decoded.buffer = buffer\n      return decoded\n    })\n\n    let patches = {_root: {objectId: '_root', type: 'map', props: {}}}\n    let docState = {\n      maxOp: this.maxOp,\n      changeIndexByHash: this.changeIndexByHash,\n      actorIds: this.actorIds,\n      heads: this.heads,\n      clock: this.clock,\n      blocks: this.blocks.slice(),\n      objectMeta: Object.assign({}, this.objectMeta)\n    }\n    let queue = (this.queue.length === 0) ? decodedChanges : decodedChanges.concat(this.queue)\n    let allApplied = [], objectIds = new Set()\n\n    while (true) {\n      const [applied, enqueued] = applyChanges(patches, queue, docState, objectIds, this.haveHashGraph)\n      queue = enqueued\n      if (applied.length > 0) allApplied = allApplied.concat(applied)\n      if (queue.length === 0) break\n\n      // If we are missing a dependency, and we haven't computed the hash graph yet, first compute\n      // the hashes to see if we actually have it already\n      if (applied.length === 0) {\n        if (this.haveHashGraph) break\n        this.computeHashGraph()\n        docState.changeIndexByHash = this.changeIndexByHash\n      }\n    }\n\n    setupPatches(patches, objectIds, docState)\n\n    // Update the document state only if `applyChanges` does not throw an exception\n    for (let change of allApplied) {\n      this.changes.push(change.buffer)\n      if (!this.hashesByActor[change.actor]) this.hashesByActor[change.actor] = []\n      this.hashesByActor[change.actor][change.seq - 1] = change.hash\n      this.changeIndexByHash[change.hash] = this.changes.length - 1\n      this.dependenciesByHash[change.hash] = change.deps\n      this.dependentsByHash[change.hash] = []\n      for (let dep of change.deps) {\n        if (!this.dependentsByHash[dep]) this.dependentsByHash[dep] = []\n        this.dependentsByHash[dep].push(change.hash)\n      }\n      appendChange(this.changesEncoders, change, docState.actorIds, this.changeIndexByHash)\n    }\n\n    this.maxOp        = docState.maxOp\n    this.actorIds     = docState.actorIds\n    this.heads        = docState.heads\n    this.clock        = docState.clock\n    this.blocks       = docState.blocks\n    this.objectMeta   = docState.objectMeta\n    this.queue        = queue\n    this.binaryDoc    = null\n    this.initPatch    = null\n\n    let patch = {\n      maxOp: this.maxOp, clock: this.clock, deps: this.heads,\n      pendingChanges: this.queue.length, diffs: patches._root\n    }\n    if (isLocal && decodedChanges.length === 1) {\n      patch.actor = decodedChanges[0].actor\n      patch.seq = decodedChanges[0].seq\n    }\n    return patch\n  }\n\n  /**\n   * Reconstructs the full change history of a document, and initialises the variables that allow us\n   * to traverse the hash graph of changes and their dependencies. When a compressed document is\n   * loaded we defer the computation of this hash graph to make loading faster, but if the hash\n   * graph is later needed (e.g. for the sync protocol), this function fills it in.\n   */\n  computeHashGraph() {\n    const binaryDoc = this.save()\n    this.haveHashGraph = true\n    this.changes = []\n    this.changeIndexByHash = {}\n    this.dependenciesByHash = {}\n    this.dependentsByHash = {}\n    this.hashesByActor = {}\n    this.clock = {}\n\n    for (let change of decodeChanges([binaryDoc])) {\n      const binaryChange = encodeChange(change) // TODO: avoid decoding and re-encoding again\n      this.changes.push(binaryChange)\n      this.changeIndexByHash[change.hash] = this.changes.length - 1\n      this.dependenciesByHash[change.hash] = change.deps\n      this.dependentsByHash[change.hash] = []\n      for (let dep of change.deps) this.dependentsByHash[dep].push(change.hash)\n      if (change.seq === 1) this.hashesByActor[change.actor] = []\n      this.hashesByActor[change.actor].push(change.hash)\n      const expectedSeq = (this.clock[change.actor] || 0) + 1\n      if (change.seq !== expectedSeq) {\n        throw new RangeError(`Expected seq ${expectedSeq}, got seq ${change.seq} from actor ${change.actor}`)\n      }\n      this.clock[change.actor] = change.seq\n    }\n  }\n\n  /**\n   * Returns all the changes that need to be sent to another replica. `haveDeps` is a list of change\n   * hashes (as hex strings) of the heads that the other replica has. The changes in `haveDeps` and\n   * any of their transitive dependencies will not be returned; any changes later than or concurrent\n   * to the hashes in `haveDeps` will be returned. If `haveDeps` is an empty array, all changes are\n   * returned. Throws an exception if any of the given hashes are not known to this replica.\n   */\n  getChanges(haveDeps) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    // If the other replica has nothing, return all changes in history order\n    if (haveDeps.length === 0) {\n      return this.changes.slice()\n    }\n\n    // Fast path for the common case where all new changes depend only on haveDeps\n    let stack = [], seenHashes = {}, toReturn = []\n    for (let hash of haveDeps) {\n      seenHashes[hash] = true\n      const successors = this.dependentsByHash[hash]\n      if (!successors) throw new RangeError(`hash not found: ${hash}`)\n      stack.push(...successors)\n    }\n\n    // Depth-first traversal of the hash graph to find all changes that depend on `haveDeps`\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      seenHashes[hash] = true\n      toReturn.push(hash)\n      if (!this.dependenciesByHash[hash].every(dep => seenHashes[dep])) {\n        // If a change depends on a hash we have not seen, abort the traversal and fall back to the\n        // slower algorithm. This will sometimes abort even if all new changes depend on `haveDeps`,\n        // because our depth-first traversal is not necessarily a topological sort of the graph.\n        break\n      }\n      stack.push(...this.dependentsByHash[hash])\n    }\n\n    // If the traversal above has encountered all the heads, and was not aborted early due to\n    // a missing dependency, then the set of changes it has found is complete, so we can return it\n    if (stack.length === 0 && this.heads.every(head => seenHashes[head])) {\n      return toReturn.map(hash => this.changes[this.changeIndexByHash[hash]])\n    }\n\n    // If we haven't encountered all of the heads, we have to search harder. This will happen if\n    // changes were added that are concurrent to `haveDeps`\n    stack = haveDeps.slice()\n    seenHashes = {}\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      if (!seenHashes[hash]) {\n        const deps = this.dependenciesByHash[hash]\n        if (!deps) throw new RangeError(`hash not found: ${hash}`)\n        stack.push(...deps)\n        seenHashes[hash] = true\n      }\n    }\n\n    return this.changes.filter(change => !seenHashes[decodeChangeMeta(change, true).hash])\n  }\n\n  /**\n   * Returns all changes that are present in this BackendDoc, but not present in the `other`\n   * BackendDoc.\n   */\n  getChangesAdded(other) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    // Depth-first traversal from the heads through the dependency graph,\n    // until we reach a change that is already present in opSet1\n    let stack = this.heads.slice(), seenHashes = {}, toReturn = []\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      if (!seenHashes[hash] && other.changeIndexByHash[hash] === undefined) {\n        seenHashes[hash] = true\n        toReturn.push(hash)\n        stack.push(...this.dependenciesByHash[hash])\n      }\n    }\n\n    // Return those changes in the reverse of the order in which the depth-first search\n    // found them. This is not necessarily a topological sort, but should usually be close.\n    return toReturn.reverse().map(hash => this.changes[this.changeIndexByHash[hash]])\n  }\n\n  getChangeByHash(hash) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n    return this.changes[this.changeIndexByHash[hash]]\n  }\n\n  /**\n   * Returns the hashes of any missing dependencies, i.e. where we have tried to apply a change that\n   * has a dependency on a change we have not seen.\n   *\n   * If the argument `heads` is given (an array of hexadecimal strings representing hashes as\n   * returned by `getHeads()`), this function also ensures that all of those hashes resolve to\n   * either a change that has been applied to the document, or that has been enqueued for later\n   * application once missing dependencies have arrived. Any missing heads hashes are included in\n   * the returned array.\n   */\n  getMissingDeps(heads = []) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    let allDeps = new Set(heads), inQueue = new Set()\n    for (let change of this.queue) {\n      inQueue.add(change.hash)\n      for (let dep of change.deps) allDeps.add(dep)\n    }\n\n    let missing = []\n    for (let hash of allDeps) {\n      if (this.changeIndexByHash[hash] === undefined && !inQueue.has(hash)) missing.push(hash)\n    }\n    return missing.sort()\n  }\n\n  /**\n   * Serialises the current document state into a single byte array.\n   */\n  save() {\n    if (this.binaryDoc) return this.binaryDoc\n\n    // Getting the byte array for the changes columns finalises their encoders, after which we can\n    // no longer append values to them. We therefore copy their data over to fresh encoders.\n    const newEncoders = this.changesEncoders.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n    const decoders = this.changesEncoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n      return {columnId: col.columnId, decoder}\n    })\n    copyColumns(newEncoders, decoders, this.changes.length)\n\n    this.binaryDoc = encodeDocumentHeader({\n      changesColumns: this.changesEncoders,\n      opsColumns: concatBlocks(this.blocks),\n      actorIds: this.actorIds, // TODO: sort actorIds (requires transforming all actorId columns in opsColumns)\n      heads: this.heads,\n      headsIndexes: this.heads.map(hash => this.changeIndexByHash[hash]),\n      extraBytes: this.extraBytes\n    })\n    this.changesEncoders = newEncoders\n    return this.binaryDoc\n  }\n\n  /**\n   * Returns a patch from which we can initialise the current state of the backend.\n   */\n  getPatch() {\n    const objectMeta = {_root: {parentObj: null, parentKey: null, opId: null, type: 'map', children: {}}}\n    const docState = {blocks: this.blocks, actorIds: this.actorIds, objectMeta, maxOp: 0}\n    const diffs = this.initPatch ? this.initPatch : documentPatch(docState)\n    return {\n      maxOp: this.maxOp, clock: this.clock, deps: this.heads,\n      pendingChanges: this.queue.length, diffs\n    }\n  }\n}\n\nmodule.exports = { MAX_BLOCK_SIZE, BackendDoc, bloomFilterContains }\n"]},"metadata":{},"sourceType":"script"}