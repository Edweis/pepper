{"ast":null,"code":"const {\n  OBJECT_ID,\n  CONFLICTS\n} = require('./constants');\n\nconst {\n  isObject,\n  copyObject\n} = require('../src/common');\n\nfunction compareRows(properties, row1, row2) {\n  for (let prop of properties) {\n    if (row1[prop] === row2[prop]) continue;\n\n    if (typeof row1[prop] === 'number' && typeof row2[prop] === 'number') {\n      return row1[prop] - row2[prop];\n    } else {\n      const prop1 = '' + row1[prop],\n            prop2 = '' + row2[prop];\n      if (prop1 === prop2) continue;\n      if (prop1 < prop2) return -1;else return +1;\n    }\n  }\n\n  return 0;\n}\n/**\n * A relational-style unordered collection of records (rows). Each row is an\n * object that maps column names to values. The set of rows is represented by\n * a map from UUID to row object.\n */\n\n\nclass Table {\n  /**\n   * This constructor is used by application code when creating a new Table\n   * object within a change callback.\n   */\n  constructor() {\n    this.entries = Object.freeze({});\n    this.opIds = Object.freeze({});\n    Object.freeze(this);\n  }\n  /**\n   * Looks up a row in the table by its unique ID.\n   */\n\n\n  byId(id) {\n    return this.entries[id];\n  }\n  /**\n   * Returns an array containing the unique IDs of all rows in the table, in no\n   * particular order.\n   */\n\n\n  get ids() {\n    return Object.keys(this.entries).filter(key => {\n      const entry = this.entries[key];\n      return isObject(entry) && entry.id === key;\n    });\n  }\n  /**\n   * Returns the number of rows in the table.\n   */\n\n\n  get count() {\n    return this.ids.length;\n  }\n  /**\n   * Returns an array containing all of the rows in the table, in no particular\n   * order.\n   */\n\n\n  get rows() {\n    return this.ids.map(id => this.byId(id));\n  }\n  /**\n   * The standard JavaScript `filter()` method, which passes each row to the\n   * callback function and returns all rows for which the it returns true.\n   */\n\n\n  filter(callback, thisArg) {\n    return this.rows.filter(callback, thisArg);\n  }\n  /**\n   * The standard JavaScript `find()` method, which passes each row to the\n   * callback function and returns the first row for which it returns true.\n   */\n\n\n  find(callback, thisArg) {\n    return this.rows.find(callback, thisArg);\n  }\n  /**\n   * The standard JavaScript `map()` method, which passes each row to the\n   * callback function and returns a list of its return values.\n   */\n\n\n  map(callback, thisArg) {\n    return this.rows.map(callback, thisArg);\n  }\n  /**\n  * Returns the list of rows, sorted by one of the following:\n  * - If a function argument is given, it compares rows as per\n  *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description\n  * - If a string argument is given, it is interpreted as a column name and\n  *   rows are sorted according to that column.\n  * - If an array of strings is given, it is interpreted as a list of column\n  *   names, and rows are sorted lexicographically by those columns.\n  * - If no argument is given, it sorts by row ID by default.\n  */\n\n\n  sort(arg) {\n    if (typeof arg === 'function') {\n      return this.rows.sort(arg);\n    } else if (typeof arg === 'string') {\n      return this.rows.sort((row1, row2) => compareRows([arg], row1, row2));\n    } else if (Array.isArray(arg)) {\n      return this.rows.sort((row1, row2) => compareRows(arg, row1, row2));\n    } else if (arg === undefined) {\n      return this.rows.sort((row1, row2) => compareRows(['id'], row1, row2));\n    } else {\n      throw new TypeError(`Unsupported sorting argument: ${arg}`);\n    }\n  }\n  /**\n   * When iterating over a table, you get all rows in the table, in no\n   * particular order.\n   */\n\n\n  [Symbol.iterator]() {\n    let rows = this.rows,\n        index = -1;\n    return {\n      next() {\n        index += 1;\n\n        if (index < rows.length) {\n          return {\n            done: false,\n            value: rows[index]\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n\n    };\n  }\n  /**\n   * Returns a shallow clone of this object. This clone is used while applying\n   * a patch to the table, and `freeze()` is called on it when we have finished\n   * applying the patch.\n   */\n\n\n  _clone() {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('clone() requires the objectId to be set');\n    }\n\n    return instantiateTable(this[OBJECT_ID], copyObject(this.entries), copyObject(this.opIds));\n  }\n  /**\n   * Sets the entry with key `id` to `value`. `opId` is the ID of the operation\n   * performing this assignment. This method is for internal use only; it is\n   * not part of the public API of Automerge.Table.\n   */\n\n\n  _set(id, value, opId) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function');\n    }\n\n    if (isObject(value) && !Array.isArray(value)) {\n      Object.defineProperty(value, 'id', {\n        value: id,\n        enumerable: true\n      });\n    }\n\n    this.entries[id] = value;\n    this.opIds[id] = opId;\n  }\n  /**\n   * Removes the row with unique ID `id` from the table.\n   */\n\n\n  remove(id) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function');\n    }\n\n    delete this.entries[id];\n    delete this.opIds[id];\n  }\n  /**\n   * Makes this object immutable. This is called after a change has been made.\n   */\n\n\n  _freeze() {\n    Object.freeze(this.entries);\n    Object.freeze(this.opIds);\n    Object.freeze(this);\n  }\n  /**\n   * Returns a writeable instance of this table. This instance is returned when\n   * the table is accessed within a change callback. `context` is the proxy\n   * context that keeps track of the mutations.\n   */\n\n\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set');\n    }\n\n    const instance = Object.create(WriteableTable.prototype);\n    instance[OBJECT_ID] = this[OBJECT_ID];\n    instance.context = context;\n    instance.entries = this.entries;\n    instance.opIds = this.opIds;\n    instance.path = path;\n    return instance;\n  }\n  /**\n   * Returns an object containing the table entries, indexed by objectID,\n   * for serializing an Automerge document to JSON.\n   */\n\n\n  toJSON() {\n    const rows = {};\n\n    for (let id of this.ids) rows[id] = this.byId(id);\n\n    return rows;\n  }\n\n}\n/**\n * An instance of this class is used when a table is accessed within a change\n * callback.\n */\n\n\nclass WriteableTable extends Table {\n  /**\n   * Returns a proxied version of the row with ID `id`. This row object can be\n   * modified within a change callback.\n   */\n  byId(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      const objectId = this.entries[id][OBJECT_ID];\n      const path = this.path.concat([{\n        key: id,\n        objectId\n      }]);\n      return this.context.instantiateObject(path, objectId, ['id']);\n    }\n  }\n  /**\n   * Adds a new row to the table. The row is given as a map from\n   * column name to value. Returns the objectId of the new row.\n   */\n\n\n  add(row) {\n    return this.context.addTableRow(this.path, row);\n  }\n  /**\n   * Removes the row with ID `id` from the table. Throws an exception if the row\n   * does not exist in the table.\n   */\n\n\n  remove(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      this.context.deleteTableRow(this.path, id, this.opIds[id]);\n    } else {\n      throw new RangeError(`There is no row with ID ${id} in this table`);\n    }\n  }\n\n}\n/**\n * This function is used to instantiate a Table object in the context of\n * applying a patch (see apply_patch.js).\n */\n\n\nfunction instantiateTable(objectId, entries, opIds) {\n  const instance = Object.create(Table.prototype);\n\n  if (!objectId) {\n    throw new RangeError('instantiateTable requires an objectId to be given');\n  }\n\n  instance[OBJECT_ID] = objectId;\n  instance[CONFLICTS] = Object.freeze({});\n  instance.entries = entries || {};\n  instance.opIds = opIds || {};\n  return instance;\n}\n\nmodule.exports = {\n  Table,\n  instantiateTable\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/table.js"],"names":["OBJECT_ID","CONFLICTS","require","isObject","copyObject","compareRows","properties","row1","row2","prop","prop1","prop2","Table","constructor","entries","Object","freeze","opIds","byId","id","ids","keys","filter","key","entry","count","length","rows","map","callback","thisArg","find","sort","arg","Array","isArray","undefined","TypeError","Symbol","iterator","index","next","done","value","_clone","RangeError","instantiateTable","_set","opId","isFrozen","Error","defineProperty","enumerable","remove","_freeze","getWriteable","context","path","instance","create","WriteableTable","prototype","toJSON","objectId","concat","instantiateObject","add","row","addTableRow","deleteTableRow","module","exports"],"mappings":"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","sourcesContent":["const { OBJECT_ID, CONFLICTS } = require('./constants')\nconst { isObject, copyObject } = require('../src/common')\n\nfunction compareRows(properties, row1, row2) {\n  for (let prop of properties) {\n    if (row1[prop] === row2[prop]) continue\n\n    if (typeof row1[prop] === 'number' && typeof row2[prop] === 'number') {\n      return row1[prop] - row2[prop]\n    } else {\n      const prop1 = '' + row1[prop], prop2 = '' + row2[prop]\n      if (prop1 === prop2) continue\n      if (prop1 < prop2) return -1; else return +1\n    }\n  }\n  return 0\n}\n\n\n/**\n * A relational-style unordered collection of records (rows). Each row is an\n * object that maps column names to values. The set of rows is represented by\n * a map from UUID to row object.\n */\nclass Table {\n  /**\n   * This constructor is used by application code when creating a new Table\n   * object within a change callback.\n   */\n  constructor() {\n    this.entries = Object.freeze({})\n    this.opIds = Object.freeze({})\n    Object.freeze(this)\n  }\n\n  /**\n   * Looks up a row in the table by its unique ID.\n   */\n  byId(id) {\n    return this.entries[id]\n  }\n\n  /**\n   * Returns an array containing the unique IDs of all rows in the table, in no\n   * particular order.\n   */\n  get ids() {\n    return Object.keys(this.entries).filter(key => {\n      const entry = this.entries[key]\n      return isObject(entry) && entry.id === key\n    })\n  }\n\n  /**\n   * Returns the number of rows in the table.\n   */\n  get count() {\n    return this.ids.length\n  }\n\n  /**\n   * Returns an array containing all of the rows in the table, in no particular\n   * order.\n   */\n  get rows() {\n    return this.ids.map(id => this.byId(id))\n  }\n\n  /**\n   * The standard JavaScript `filter()` method, which passes each row to the\n   * callback function and returns all rows for which the it returns true.\n   */\n  filter(callback, thisArg) {\n    return this.rows.filter(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `find()` method, which passes each row to the\n   * callback function and returns the first row for which it returns true.\n   */\n  find(callback, thisArg) {\n    return this.rows.find(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `map()` method, which passes each row to the\n   * callback function and returns a list of its return values.\n   */\n  map(callback, thisArg) {\n    return this.rows.map(callback, thisArg)\n  }\n\n  /**\n  * Returns the list of rows, sorted by one of the following:\n  * - If a function argument is given, it compares rows as per\n  *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description\n  * - If a string argument is given, it is interpreted as a column name and\n  *   rows are sorted according to that column.\n  * - If an array of strings is given, it is interpreted as a list of column\n  *   names, and rows are sorted lexicographically by those columns.\n  * - If no argument is given, it sorts by row ID by default.\n  */\n  sort(arg) {\n    if (typeof arg === 'function') {\n      return this.rows.sort(arg)\n    } else if (typeof arg === 'string') {\n      return this.rows.sort((row1, row2) => compareRows([arg], row1, row2))\n    } else if (Array.isArray(arg)) {\n      return this.rows.sort((row1, row2) => compareRows(arg, row1, row2))\n    } else if (arg === undefined) {\n      return this.rows.sort((row1, row2) => compareRows(['id'], row1, row2))\n    } else {\n      throw new TypeError(`Unsupported sorting argument: ${arg}`)\n    }\n  }\n\n  /**\n   * When iterating over a table, you get all rows in the table, in no\n   * particular order.\n   */\n  [Symbol.iterator] () {\n    let rows = this.rows, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < rows.length) {\n          return {done: false, value: rows[index]}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a shallow clone of this object. This clone is used while applying\n   * a patch to the table, and `freeze()` is called on it when we have finished\n   * applying the patch.\n   */\n  _clone() {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('clone() requires the objectId to be set')\n    }\n    return instantiateTable(this[OBJECT_ID], copyObject(this.entries), copyObject(this.opIds))\n  }\n\n  /**\n   * Sets the entry with key `id` to `value`. `opId` is the ID of the operation\n   * performing this assignment. This method is for internal use only; it is\n   * not part of the public API of Automerge.Table.\n   */\n  _set(id, value, opId) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    if (isObject(value) && !Array.isArray(value)) {\n      Object.defineProperty(value, 'id', {value: id, enumerable: true})\n    }\n    this.entries[id] = value\n    this.opIds[id] = opId\n  }\n\n  /**\n   * Removes the row with unique ID `id` from the table.\n   */\n  remove(id) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    delete this.entries[id]\n    delete this.opIds[id]\n  }\n\n  /**\n   * Makes this object immutable. This is called after a change has been made.\n   */\n  _freeze() {\n    Object.freeze(this.entries)\n    Object.freeze(this.opIds)\n    Object.freeze(this)\n  }\n\n  /**\n   * Returns a writeable instance of this table. This instance is returned when\n   * the table is accessed within a change callback. `context` is the proxy\n   * context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = Object.create(WriteableTable.prototype)\n    instance[OBJECT_ID] = this[OBJECT_ID]\n    instance.context = context\n    instance.entries = this.entries\n    instance.opIds = this.opIds\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Returns an object containing the table entries, indexed by objectID,\n   * for serializing an Automerge document to JSON.\n   */\n  toJSON() {\n    const rows = {}\n    for (let id of this.ids) rows[id] = this.byId(id)\n    return rows\n  }\n}\n\n/**\n * An instance of this class is used when a table is accessed within a change\n * callback.\n */\nclass WriteableTable extends Table {\n  /**\n   * Returns a proxied version of the row with ID `id`. This row object can be\n   * modified within a change callback.\n   */\n  byId(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      const objectId = this.entries[id][OBJECT_ID]\n      const path = this.path.concat([{key: id, objectId}])\n      return this.context.instantiateObject(path, objectId, ['id'])\n    }\n  }\n\n  /**\n   * Adds a new row to the table. The row is given as a map from\n   * column name to value. Returns the objectId of the new row.\n   */\n  add(row) {\n    return this.context.addTableRow(this.path, row)\n  }\n\n  /**\n   * Removes the row with ID `id` from the table. Throws an exception if the row\n   * does not exist in the table.\n   */\n  remove(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      this.context.deleteTableRow(this.path, id, this.opIds[id])\n    } else {\n      throw new RangeError(`There is no row with ID ${id} in this table`)\n    }\n  }\n}\n\n/**\n * This function is used to instantiate a Table object in the context of\n * applying a patch (see apply_patch.js).\n */\nfunction instantiateTable(objectId, entries, opIds) {\n  const instance = Object.create(Table.prototype)\n  if (!objectId) {\n    throw new RangeError('instantiateTable requires an objectId to be given')\n  }\n  instance[OBJECT_ID] = objectId\n  instance[CONFLICTS] = Object.freeze({})\n  instance.entries = entries || {}\n  instance.opIds = opIds || {}\n  return instance\n}\n\nmodule.exports = { Table, instantiateTable }\n"]},"metadata":{},"sourceType":"script"}