{"ast":null,"code":"const {\n  OBJECT_ID\n} = require('./constants');\n\nconst {\n  isObject\n} = require('../src/common');\n\nclass Text {\n  constructor(text) {\n    if (typeof text === 'string') {\n      const elems = [...text].map(value => ({\n        value\n      }));\n      return instantiateText(undefined, elems); // eslint-disable-line\n    } else if (Array.isArray(text)) {\n      const elems = text.map(value => ({\n        value\n      }));\n      return instantiateText(undefined, elems); // eslint-disable-line\n    } else if (text === undefined) {\n      return instantiateText(undefined, []); // eslint-disable-line\n    } else {\n      throw new TypeError(`Unsupported initial value for Text: ${text}`);\n    }\n  }\n\n  get length() {\n    return this.elems.length;\n  }\n\n  get(index) {\n    const value = this.elems[index].value;\n\n    if (this.context && isObject(value)) {\n      const objectId = value[OBJECT_ID];\n      const path = this.path.concat([{\n        key: index,\n        objectId\n      }]);\n      return this.context.instantiateObject(path, objectId);\n    } else {\n      return value;\n    }\n  }\n\n  getElemId(index) {\n    return this.elems[index].elemId;\n  }\n  /**\n   * Iterates over the text elements character by character, including any\n   * inline objects.\n   */\n\n\n  [Symbol.iterator]() {\n    let elems = this.elems,\n        index = -1;\n    return {\n      next() {\n        index += 1;\n\n        if (index < elems.length) {\n          return {\n            done: false,\n            value: elems[index].value\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n\n    };\n  }\n  /**\n   * Returns the content of the Text object as a simple string, ignoring any\n   * non-character elements.\n   */\n\n\n  toString() {\n    // Concatting to a string is faster than creating an array and then\n    // .join()ing for small (<100KB) arrays.\n    // https://jsperf.com/join-vs-loop-w-type-test\n    let str = '';\n\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') str += elem.value;\n    }\n\n    return str;\n  }\n  /**\n   * Returns the content of the Text object as a sequence of strings,\n   * interleaved with non-character elements.\n   *\n   * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:\n   * => ['ab', {x: 3}, 'cd']\n   */\n\n\n  toSpans() {\n    let spans = [];\n    let chars = '';\n\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') {\n        chars += elem.value;\n      } else {\n        if (chars.length > 0) {\n          spans.push(chars);\n          chars = '';\n        }\n\n        spans.push(elem.value);\n      }\n    }\n\n    if (chars.length > 0) {\n      spans.push(chars);\n    }\n\n    return spans;\n  }\n  /**\n   * Returns the content of the Text object as a simple string, so that the\n   * JSON serialization of an Automerge document represents text nicely.\n   */\n\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Returns a writeable instance of this object. This instance is returned when\n   * the text object is accessed within a change callback. `context` is the\n   * proxy context that keeps track of the mutations.\n   */\n\n\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set');\n    }\n\n    const instance = instantiateText(this[OBJECT_ID], this.elems);\n    instance.context = context;\n    instance.path = path;\n    return instance;\n  }\n  /**\n   * Updates the list item at position `index` to a new value `value`.\n   */\n\n\n  set(index, value) {\n    if (this.context) {\n      this.context.setListIndex(this.path, index, value);\n    } else if (!this[OBJECT_ID]) {\n      this.elems[index].value = value;\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n  /**\n   * Inserts new list items `values` starting at position `index`.\n   */\n\n\n  insertAt(index) {\n    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      values[_key - 1] = arguments[_key];\n    }\n\n    if (this.context) {\n      this.context.splice(this.path, index, 0, values);\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, 0, ...values.map(value => ({\n        value\n      })));\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n  /**\n   * Deletes `numDelete` list items starting at position `index`.\n   * if `numDelete` is not given, one item is deleted.\n   */\n\n\n  deleteAt(index) {\n    let numDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if (this.context) {\n      this.context.splice(this.path, index, numDelete, []);\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, numDelete);\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block');\n    }\n\n    return this;\n  }\n\n} // Read-only methods that can delegate to the JavaScript built-in array\n\n\nfor (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'toLocaleString']) {\n  Text.prototype[method] = function () {\n    const array = [...this];\n    return array[method](...arguments);\n  };\n}\n\nfunction instantiateText(objectId, elems) {\n  const instance = Object.create(Text.prototype);\n  instance[OBJECT_ID] = objectId;\n  instance.elems = elems;\n  return instance;\n}\n\nmodule.exports = {\n  Text,\n  instantiateText\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/text.js"],"names":["OBJECT_ID","require","isObject","Text","constructor","text","elems","map","value","instantiateText","undefined","Array","isArray","TypeError","length","get","index","context","objectId","path","concat","key","instantiateObject","getElemId","elemId","Symbol","iterator","next","done","toString","str","elem","toSpans","spans","chars","push","toJSON","getWriteable","RangeError","instance","set","setListIndex","insertAt","values","splice","deleteAt","numDelete","method","prototype","array","Object","create","module","exports"],"mappings":"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","sourcesContent":["const { OBJECT_ID } = require('./constants')\nconst { isObject } = require('../src/common')\n\nclass Text {\n  constructor (text) {\n    if (typeof text === 'string') {\n      const elems = [...text].map(value => ({value}))\n      return instantiateText(undefined, elems) // eslint-disable-line\n    } else if (Array.isArray(text)) {\n      const elems = text.map(value => ({value}))\n      return instantiateText(undefined, elems) // eslint-disable-line\n    } else if (text === undefined) {\n      return instantiateText(undefined, []) // eslint-disable-line\n    } else {\n      throw new TypeError(`Unsupported initial value for Text: ${text}`)\n    }\n  }\n\n  get length () {\n    return this.elems.length\n  }\n\n  get (index) {\n    const value = this.elems[index].value\n    if (this.context && isObject(value)) {\n      const objectId = value[OBJECT_ID]\n      const path = this.path.concat([{key: index, objectId}])\n      return this.context.instantiateObject(path, objectId)\n    } else {\n      return value\n    }\n  }\n\n  getElemId (index) {\n    return this.elems[index].elemId\n  }\n\n  /**\n   * Iterates over the text elements character by character, including any\n   * inline objects.\n   */\n  [Symbol.iterator] () {\n    let elems = this.elems, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < elems.length) {\n          return {done: false, value: elems[index].value}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, ignoring any\n   * non-character elements.\n   */\n  toString() {\n    // Concatting to a string is faster than creating an array and then\n    // .join()ing for small (<100KB) arrays.\n    // https://jsperf.com/join-vs-loop-w-type-test\n    let str = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') str += elem.value\n    }\n    return str\n  }\n\n  /**\n   * Returns the content of the Text object as a sequence of strings,\n   * interleaved with non-character elements.\n   *\n   * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:\n   * => ['ab', {x: 3}, 'cd']\n   */\n  toSpans() {\n    let spans = []\n    let chars = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') {\n        chars += elem.value\n      } else {\n        if (chars.length > 0) {\n          spans.push(chars)\n          chars = ''\n        }\n        spans.push(elem.value)\n      }\n    }\n    if (chars.length > 0) {\n      spans.push(chars)\n    }\n    return spans\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, so that the\n   * JSON serialization of an Automerge document represents text nicely.\n   */\n  toJSON() {\n    return this.toString()\n  }\n\n  /**\n   * Returns a writeable instance of this object. This instance is returned when\n   * the text object is accessed within a change callback. `context` is the\n   * proxy context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = instantiateText(this[OBJECT_ID], this.elems)\n    instance.context = context\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Updates the list item at position `index` to a new value `value`.\n   */\n  set (index, value) {\n    if (this.context) {\n      this.context.setListIndex(this.path, index, value)\n    } else if (!this[OBJECT_ID]) {\n      this.elems[index].value = value\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Inserts new list items `values` starting at position `index`.\n   */\n  insertAt(index, ...values) {\n    if (this.context) {\n      this.context.splice(this.path, index, 0, values)\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, 0, ...values.map(value => ({value})))\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Deletes `numDelete` list items starting at position `index`.\n   * if `numDelete` is not given, one item is deleted.\n   */\n  deleteAt(index, numDelete = 1) {\n    if (this.context) {\n      this.context.splice(this.path, index, numDelete, [])\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, numDelete)\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n}\n\n// Read-only methods that can delegate to the JavaScript built-in array\nfor (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                    'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                    'slice', 'some', 'toLocaleString']) {\n  Text.prototype[method] = function (...args) {\n    const array = [...this]\n    return array[method](...args)\n  }\n}\n\nfunction instantiateText(objectId, elems) {\n  const instance = Object.create(Text.prototype)\n  instance[OBJECT_ID] = objectId\n  instance.elems = elems\n  return instance\n}\n\nmodule.exports = { Text, instantiateText }\n"]},"metadata":{},"sourceType":"script"}