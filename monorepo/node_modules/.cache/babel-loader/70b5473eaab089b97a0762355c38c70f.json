{"ast":null,"code":"const {\n  encodeChange\n} = require('./columnar');\n\nconst {\n  BackendDoc\n} = require('./new');\n\nconst {\n  backendState\n} = require('./util');\n/**\n * Returns an empty node state.\n */\n\n\nfunction init() {\n  return {\n    state: new BackendDoc(),\n    heads: []\n  };\n}\n\nfunction clone(backend) {\n  return {\n    state: backendState(backend).clone(),\n    heads: backend.heads\n  };\n}\n\nfunction free(backend) {\n  backend.state = null;\n  backend.frozen = true;\n}\n/**\n * Applies a list of `changes` from remote nodes to the node state `backend`.\n * Returns a two-element array `[state, patch]` where `state` is the updated\n * node state, and `patch` describes the modifications that need to be made\n * to the document objects to reflect these changes.\n */\n\n\nfunction applyChanges(backend, changes) {\n  const state = backendState(backend);\n  const patch = state.applyChanges(changes);\n  backend.frozen = true;\n  return [{\n    state,\n    heads: state.heads\n  }, patch];\n}\n\nfunction hashByActor(state, actorId, index) {\n  if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n    return state.hashesByActor[actorId][index];\n  }\n\n  if (!state.haveHashGraph) {\n    state.computeHashGraph();\n\n    if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n      return state.hashesByActor[actorId][index];\n    }\n  }\n\n  throw new RangeError(`Unknown change: actorId = ${actorId}, seq = ${index + 1}`);\n}\n/**\n * Takes a single change request `request` made by the local user, and applies\n * it to the node state `backend`. Returns a three-element array `[backend, patch, binaryChange]`\n * where `backend` is the updated node state,`patch` confirms the\n * modifications to the document objects, and `binaryChange` is a binary-encoded form of\n * the change submitted.\n */\n\n\nfunction applyLocalChange(backend, change) {\n  const state = backendState(backend);\n\n  if (change.seq <= state.clock[change.actor] || 0) {\n    throw new RangeError('Change request has already been applied');\n  } // Add the local actor's last change hash to deps. We do this because when frontend\n  // and backend are on separate threads, the frontend may fire off several local\n  // changes in sequence before getting a response from the backend; since the binary\n  // encoding and hashing is done by the backend, the frontend does not know the hash\n  // of its own last change in this case. Rather than handle this situation as a\n  // special case, we say that the frontend includes only specifies other actors'\n  // deps in changes it generates, and the dependency from the local actor's last\n  // change is always added here in the backend.\n  //\n  // Strictly speaking, we should check whether the local actor's last change is\n  // indirectly reachable through a different actor's change; in that case, it is not\n  // necessary to add this dependency. However, it doesn't do any harm either (only\n  // using a few extra bytes of storage).\n\n\n  if (change.seq > 1) {\n    const lastHash = hashByActor(state, change.actor, change.seq - 2);\n\n    if (!lastHash) {\n      throw new RangeError(`Cannot find hash of localChange before seq=${change.seq}`);\n    }\n\n    let deps = {\n      [lastHash]: true\n    };\n\n    for (let hash of change.deps) deps[hash] = true;\n\n    change.deps = Object.keys(deps).sort();\n  }\n\n  const binaryChange = encodeChange(change);\n  const patch = state.applyChanges([binaryChange], true);\n  backend.frozen = true; // On the patch we send out, omit the last local change hash\n\n  const lastHash = hashByActor(state, change.actor, change.seq - 1);\n  patch.deps = patch.deps.filter(head => head !== lastHash);\n  return [{\n    state,\n    heads: state.heads\n  }, patch, binaryChange];\n}\n/**\n * Returns the state of the document serialised to an Uint8Array.\n */\n\n\nfunction save(backend) {\n  return backendState(backend).save();\n}\n/**\n * Loads the document and/or changes contained in an Uint8Array, and returns a\n * backend initialised with this state.\n */\n\n\nfunction load(data) {\n  const state = new BackendDoc(data);\n  return {\n    state,\n    heads: state.heads\n  };\n}\n/**\n * Applies a list of `changes` to the node state `backend`, and returns the updated\n * state with those changes incorporated. Unlike `applyChanges()`, this function\n * does not produce a patch describing the incremental modifications, making it\n * a little faster when loading a document from disk. When all the changes have\n * been loaded, you can use `getPatch()` to construct the latest document state.\n */\n\n\nfunction loadChanges(backend, changes) {\n  const state = backendState(backend);\n  state.applyChanges(changes);\n  backend.frozen = true;\n  return {\n    state,\n    heads: state.heads\n  };\n}\n/**\n * Returns a patch that, when applied to an empty document, constructs the\n * document tree in the state described by the node state `backend`.\n */\n\n\nfunction getPatch(backend) {\n  return backendState(backend).getPatch();\n}\n/**\n * Returns an array of hashes of the current \"head\" changes (i.e. those changes\n * that no other change depends on).\n */\n\n\nfunction getHeads(backend) {\n  return backend.heads;\n}\n/**\n * Returns the full history of changes that have been applied to a document.\n */\n\n\nfunction getAllChanges(backend) {\n  return getChanges(backend, []);\n}\n/**\n * Returns all changes that are newer than or concurrent to the changes\n * identified by the hashes in `haveDeps`. If `haveDeps` is an empty array, all\n * changes are returned. Throws an exception if any of the given hashes is unknown.\n */\n\n\nfunction getChanges(backend, haveDeps) {\n  if (!Array.isArray(haveDeps)) {\n    throw new TypeError('Pass an array of hashes to Backend.getChanges()');\n  }\n\n  return backendState(backend).getChanges(haveDeps);\n}\n/**\n * Returns all changes that are present in `backend2` but not in `backend1`.\n * Intended for use in situations where the two backends are for different actors.\n * To get the changes added between an older and a newer document state of the same\n * actor, use `getChanges()` instead. `getChangesAdded()` throws an exception if\n * one of the backend states is frozen (i.e. if it is not the latest state of that\n * backend instance; this distinction matters when the backend is mutable).\n */\n\n\nfunction getChangesAdded(backend1, backend2) {\n  return backendState(backend2).getChangesAdded(backendState(backend1));\n}\n/**\n * If the backend has applied a change with the given `hash` (given as a\n * hexadecimal string), returns that change (as a byte array). Returns undefined\n * if no change with that hash has been applied. A change with missing\n * dependencies does not count as having been applied.\n */\n\n\nfunction getChangeByHash(backend, hash) {\n  return backendState(backend).getChangeByHash(hash);\n}\n/**\n * Returns the hashes of any missing dependencies, i.e. where we have applied a\n * change that has a dependency on a change we have not seen.\n *\n * If the argument `heads` is given (an array of hexadecimal strings representing\n * hashes as returned by `getHeads()`), this function also ensures that all of\n * those hashes resolve to either a change that has been applied to the document,\n * or that has been enqueued for later application once missing dependencies have\n * arrived. Any missing heads hashes are included in the returned array.\n */\n\n\nfunction getMissingDeps(backend) {\n  let heads = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return backendState(backend).getMissingDeps(heads);\n}\n\nmodule.exports = {\n  init,\n  clone,\n  free,\n  applyChanges,\n  applyLocalChange,\n  save,\n  load,\n  loadChanges,\n  getPatch,\n  getHeads,\n  getAllChanges,\n  getChanges,\n  getChangesAdded,\n  getChangeByHash,\n  getMissingDeps\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/backend/backend.js"],"names":["encodeChange","require","BackendDoc","backendState","init","state","heads","clone","backend","free","frozen","applyChanges","changes","patch","hashByActor","actorId","index","hashesByActor","haveHashGraph","computeHashGraph","RangeError","applyLocalChange","change","seq","clock","actor","lastHash","deps","hash","Object","keys","sort","binaryChange","filter","head","save","load","data","loadChanges","getPatch","getHeads","getAllChanges","getChanges","haveDeps","Array","isArray","TypeError","getChangesAdded","backend1","backend2","getChangeByHash","getMissingDeps","module","exports"],"mappings":"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","sourcesContent":["const { encodeChange } = require('./columnar')\nconst { BackendDoc } = require('./new')\nconst { backendState } = require('./util')\n\n/**\n * Returns an empty node state.\n */\nfunction init() {\n  return {state: new BackendDoc(), heads: []}\n}\n\nfunction clone(backend) {\n  return {state: backendState(backend).clone(), heads: backend.heads}\n}\n\nfunction free(backend) {\n  backend.state = null\n  backend.frozen = true\n}\n\n/**\n * Applies a list of `changes` from remote nodes to the node state `backend`.\n * Returns a two-element array `[state, patch]` where `state` is the updated\n * node state, and `patch` describes the modifications that need to be made\n * to the document objects to reflect these changes.\n */\nfunction applyChanges(backend, changes) {\n  const state = backendState(backend)\n  const patch = state.applyChanges(changes)\n  backend.frozen = true\n  return [{state, heads: state.heads}, patch]\n}\n\nfunction hashByActor(state, actorId, index) {\n  if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n    return state.hashesByActor[actorId][index]\n  }\n  if (!state.haveHashGraph) {\n    state.computeHashGraph()\n    if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n      return state.hashesByActor[actorId][index]\n    }\n  }\n  throw new RangeError(`Unknown change: actorId = ${actorId}, seq = ${index + 1}`)\n}\n\n/**\n * Takes a single change request `request` made by the local user, and applies\n * it to the node state `backend`. Returns a three-element array `[backend, patch, binaryChange]`\n * where `backend` is the updated node state,`patch` confirms the\n * modifications to the document objects, and `binaryChange` is a binary-encoded form of\n * the change submitted.\n */\nfunction applyLocalChange(backend, change) {\n  const state = backendState(backend)\n  if (change.seq <= state.clock[change.actor] || 0) {\n    throw new RangeError('Change request has already been applied')\n  }\n\n  // Add the local actor's last change hash to deps. We do this because when frontend\n  // and backend are on separate threads, the frontend may fire off several local\n  // changes in sequence before getting a response from the backend; since the binary\n  // encoding and hashing is done by the backend, the frontend does not know the hash\n  // of its own last change in this case. Rather than handle this situation as a\n  // special case, we say that the frontend includes only specifies other actors'\n  // deps in changes it generates, and the dependency from the local actor's last\n  // change is always added here in the backend.\n  //\n  // Strictly speaking, we should check whether the local actor's last change is\n  // indirectly reachable through a different actor's change; in that case, it is not\n  // necessary to add this dependency. However, it doesn't do any harm either (only\n  // using a few extra bytes of storage).\n  if (change.seq > 1) {\n    const lastHash = hashByActor(state, change.actor, change.seq - 2)\n    if (!lastHash) {\n      throw new RangeError(`Cannot find hash of localChange before seq=${change.seq}`)\n    }\n    let deps = {[lastHash]: true}\n    for (let hash of change.deps) deps[hash] = true\n    change.deps = Object.keys(deps).sort()\n  }\n\n  const binaryChange = encodeChange(change)\n  const patch = state.applyChanges([binaryChange], true)\n  backend.frozen = true\n\n  // On the patch we send out, omit the last local change hash\n  const lastHash = hashByActor(state, change.actor, change.seq - 1)\n  patch.deps = patch.deps.filter(head => head !== lastHash)\n  return [{state, heads: state.heads}, patch, binaryChange]\n}\n\n/**\n * Returns the state of the document serialised to an Uint8Array.\n */\nfunction save(backend) {\n  return backendState(backend).save()\n}\n\n/**\n * Loads the document and/or changes contained in an Uint8Array, and returns a\n * backend initialised with this state.\n */\nfunction load(data) {\n  const state = new BackendDoc(data)\n  return {state, heads: state.heads}\n}\n\n/**\n * Applies a list of `changes` to the node state `backend`, and returns the updated\n * state with those changes incorporated. Unlike `applyChanges()`, this function\n * does not produce a patch describing the incremental modifications, making it\n * a little faster when loading a document from disk. When all the changes have\n * been loaded, you can use `getPatch()` to construct the latest document state.\n */\nfunction loadChanges(backend, changes) {\n  const state = backendState(backend)\n  state.applyChanges(changes)\n  backend.frozen = true\n  return {state, heads: state.heads}\n}\n\n/**\n * Returns a patch that, when applied to an empty document, constructs the\n * document tree in the state described by the node state `backend`.\n */\nfunction getPatch(backend) {\n  return backendState(backend).getPatch()\n}\n\n/**\n * Returns an array of hashes of the current \"head\" changes (i.e. those changes\n * that no other change depends on).\n */\nfunction getHeads(backend) {\n  return backend.heads\n}\n\n/**\n * Returns the full history of changes that have been applied to a document.\n */\nfunction getAllChanges(backend) {\n  return getChanges(backend, [])\n}\n\n/**\n * Returns all changes that are newer than or concurrent to the changes\n * identified by the hashes in `haveDeps`. If `haveDeps` is an empty array, all\n * changes are returned. Throws an exception if any of the given hashes is unknown.\n */\nfunction getChanges(backend, haveDeps) {\n  if (!Array.isArray(haveDeps)) {\n    throw new TypeError('Pass an array of hashes to Backend.getChanges()')\n  }\n  return backendState(backend).getChanges(haveDeps)\n}\n\n/**\n * Returns all changes that are present in `backend2` but not in `backend1`.\n * Intended for use in situations where the two backends are for different actors.\n * To get the changes added between an older and a newer document state of the same\n * actor, use `getChanges()` instead. `getChangesAdded()` throws an exception if\n * one of the backend states is frozen (i.e. if it is not the latest state of that\n * backend instance; this distinction matters when the backend is mutable).\n */\nfunction getChangesAdded(backend1, backend2) {\n  return backendState(backend2).getChangesAdded(backendState(backend1))\n}\n\n/**\n * If the backend has applied a change with the given `hash` (given as a\n * hexadecimal string), returns that change (as a byte array). Returns undefined\n * if no change with that hash has been applied. A change with missing\n * dependencies does not count as having been applied.\n */\nfunction getChangeByHash(backend, hash) {\n  return backendState(backend).getChangeByHash(hash)\n}\n\n/**\n * Returns the hashes of any missing dependencies, i.e. where we have applied a\n * change that has a dependency on a change we have not seen.\n *\n * If the argument `heads` is given (an array of hexadecimal strings representing\n * hashes as returned by `getHeads()`), this function also ensures that all of\n * those hashes resolve to either a change that has been applied to the document,\n * or that has been enqueued for later application once missing dependencies have\n * arrived. Any missing heads hashes are included in the returned array.\n */\nfunction getMissingDeps(backend, heads = []) {\n  return backendState(backend).getMissingDeps(heads)\n}\n\nmodule.exports = {\n  init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch,\n  getHeads, getAllChanges, getChanges, getChangesAdded, getChangeByHash, getMissingDeps\n}\n"]},"metadata":{},"sourceType":"script"}