{"ast":null,"code":"const {\n  isObject,\n  copyObject,\n  parseOpId\n} = require('../src/common');\n\nconst {\n  OBJECT_ID,\n  CONFLICTS,\n  ELEM_IDS\n} = require('./constants');\n\nconst {\n  instantiateText\n} = require('./text');\n\nconst {\n  instantiateTable\n} = require('./table');\n\nconst {\n  Counter\n} = require('./counter');\n/**\n * Reconstructs the value from the patch object `patch`.\n */\n\n\nfunction getValue(patch, object, updated) {\n  if (patch.objectId) {\n    // If the objectId of the existing object does not match the objectId in the patch,\n    // that means the patch is replacing the object with a new one made from scratch\n    if (object && object[OBJECT_ID] !== patch.objectId) {\n      object = undefined;\n    }\n\n    return interpretPatch(patch, object, updated);\n  } else if (patch.datatype === 'timestamp') {\n    // Timestamp: value is milliseconds since 1970 epoch\n    return new Date(patch.value);\n  } else if (patch.datatype === 'counter') {\n    return new Counter(patch.value);\n  } else {\n    // Primitive value (int, uint, float64, string, boolean, or null)\n    return patch.value;\n  }\n}\n/**\n * Compares two strings, interpreted as Lamport timestamps of the form\n * 'counter@actorId'. Returns 1 if ts1 is greater, or -1 if ts2 is greater.\n */\n\n\nfunction lamportCompare(ts1, ts2) {\n  const regex = /^(\\d+)@(.*)$/;\n  const time1 = regex.test(ts1) ? parseOpId(ts1) : {\n    counter: 0,\n    actorId: ts1\n  };\n  const time2 = regex.test(ts2) ? parseOpId(ts2) : {\n    counter: 0,\n    actorId: ts2\n  };\n  if (time1.counter < time2.counter) return -1;\n  if (time1.counter > time2.counter) return 1;\n  if (time1.actorId < time2.actorId) return -1;\n  if (time1.actorId > time2.actorId) return 1;\n  return 0;\n}\n/**\n * `props` is an object of the form:\n * `{key1: {opId1: {...}, opId2: {...}}, key2: {opId3: {...}}}`\n * where the outer object is a mapping from property names to inner objects,\n * and the inner objects are a mapping from operation ID to sub-patch.\n * This function interprets that structure and updates the objects `object` and\n * `conflicts` to reflect it. For each key, the greatest opId (by Lamport TS\n * order) is chosen as the default resolution; that op's value is assigned\n * to `object[key]`. Moreover, all the opIds and values are packed into a\n * conflicts object of the form `{opId1: value1, opId2: value2}` and assigned\n * to `conflicts[key]`. If there is no conflict, the conflicts object contains\n * just a single opId-value mapping.\n */\n\n\nfunction applyProperties(props, object, conflicts, updated) {\n  if (!props) return;\n\n  for (let key of Object.keys(props)) {\n    const values = {},\n          opIds = Object.keys(props[key]).sort(lamportCompare).reverse();\n\n    for (let opId of opIds) {\n      const subpatch = props[key][opId];\n\n      if (conflicts[key] && conflicts[key][opId]) {\n        values[opId] = getValue(subpatch, conflicts[key][opId], updated);\n      } else {\n        values[opId] = getValue(subpatch, undefined, updated);\n      }\n    }\n\n    if (opIds.length === 0) {\n      delete object[key];\n      delete conflicts[key];\n    } else {\n      object[key] = values[opIds[0]];\n      conflicts[key] = values;\n    }\n  }\n}\n/**\n * Creates a writable copy of an immutable map object. If `originalObject`\n * is undefined, creates an empty object with ID `objectId`.\n */\n\n\nfunction cloneMapObject(originalObject, objectId) {\n  const object = copyObject(originalObject);\n  const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : undefined);\n  Object.defineProperty(object, OBJECT_ID, {\n    value: objectId\n  });\n  Object.defineProperty(object, CONFLICTS, {\n    value: conflicts\n  });\n  return object;\n}\n/**\n * Updates the map object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateMapObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = cloneMapObject(obj, objectId);\n  }\n\n  const object = updated[objectId];\n  applyProperties(patch.props, object, object[CONFLICTS], updated);\n  return object;\n}\n/**\n * Updates the table object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateTableObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = obj ? obj._clone() : instantiateTable(objectId);\n  }\n\n  const object = updated[objectId];\n\n  for (let key of Object.keys(patch.props || {})) {\n    const opIds = Object.keys(patch.props[key]);\n\n    if (opIds.length === 0) {\n      object.remove(key);\n    } else if (opIds.length === 1) {\n      const subpatch = patch.props[key][opIds[0]];\n\n      object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0]);\n    } else {\n      throw new RangeError('Conflicts are not supported on properties of a table');\n    }\n  }\n\n  return object;\n}\n/**\n * Creates a writable copy of an immutable list object. If `originalList` is\n * undefined, creates an empty list with ID `objectId`.\n */\n\n\nfunction cloneListObject(originalList, objectId) {\n  const list = originalList ? originalList.slice() : []; // slice() makes a shallow clone\n\n  const conflicts = originalList && originalList[CONFLICTS] ? originalList[CONFLICTS].slice() : [];\n  const elemIds = originalList && originalList[ELEM_IDS] ? originalList[ELEM_IDS].slice() : [];\n  Object.defineProperty(list, OBJECT_ID, {\n    value: objectId\n  });\n  Object.defineProperty(list, CONFLICTS, {\n    value: conflicts\n  });\n  Object.defineProperty(list, ELEM_IDS, {\n    value: elemIds\n  });\n  return list;\n}\n/**\n * Updates the list object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateListObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n\n  if (!updated[objectId]) {\n    updated[objectId] = cloneListObject(obj, objectId);\n  }\n\n  const list = updated[objectId],\n        conflicts = list[CONFLICTS],\n        elemIds = list[ELEM_IDS];\n\n  for (let i = 0; i < patch.edits.length; i++) {\n    const edit = patch.edits[i];\n\n    if (edit.action === 'insert' || edit.action === 'update') {\n      const oldValue = conflicts[edit.index] && conflicts[edit.index][edit.opId];\n      let lastValue = getValue(edit.value, oldValue, updated);\n      let values = {\n        [edit.opId]: lastValue\n      }; // Successive updates for the same index are an indication of a conflict on that list element.\n      // Edits are sorted in increasing order by Lamport timestamp, so the last value (with the\n      // greatest timestamp) is the default resolution of the conflict.\n\n      while (i < patch.edits.length - 1 && patch.edits[i + 1].index === edit.index && patch.edits[i + 1].action === 'update') {\n        i++;\n        const conflict = patch.edits[i];\n        const oldValue2 = conflicts[conflict.index] && conflicts[conflict.index][conflict.opId];\n        lastValue = getValue(conflict.value, oldValue2, updated);\n        values[conflict.opId] = lastValue;\n      }\n\n      if (edit.action === 'insert') {\n        list.splice(edit.index, 0, lastValue);\n        conflicts.splice(edit.index, 0, values);\n        elemIds.splice(edit.index, 0, edit.elemId);\n      } else {\n        list[edit.index] = lastValue;\n        conflicts[edit.index] = values;\n      }\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId),\n            newElems = [],\n            newValues = [],\n            newConflicts = [];\n      const datatype = edit.datatype;\n      edit.values.forEach((value, index) => {\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;\n        value = getValue({\n          value,\n          datatype\n        }, undefined, updated);\n        newValues.push(value);\n        newConflicts.push({\n          [elemId]: {\n            value,\n            datatype,\n            type: 'value'\n          }\n        });\n        newElems.push(elemId);\n      });\n      list.splice(edit.index, 0, ...newValues);\n      conflicts.splice(edit.index, 0, ...newConflicts);\n      elemIds.splice(edit.index, 0, ...newElems);\n    } else if (edit.action === 'remove') {\n      list.splice(edit.index, edit.count);\n      conflicts.splice(edit.index, edit.count);\n      elemIds.splice(edit.index, edit.count);\n    }\n  }\n\n  return list;\n}\n/**\n * Updates the text object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\n\n\nfunction updateTextObject(patch, obj, updated) {\n  const objectId = patch.objectId;\n  let elems;\n\n  if (updated[objectId]) {\n    elems = updated[objectId].elems;\n  } else if (obj) {\n    elems = obj.elems.slice();\n  } else {\n    elems = [];\n  }\n\n  for (const edit of patch.edits) {\n    if (edit.action === 'insert') {\n      const value = getValue(edit.value, undefined, updated);\n      const elem = {\n        elemId: edit.elemId,\n        pred: [edit.opId],\n        value\n      };\n      elems.splice(edit.index, 0, elem);\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId);\n      const datatype = edit.datatype;\n      const newElems = edit.values.map((value, index) => {\n        value = getValue({\n          datatype,\n          value\n        }, undefined, updated);\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;\n        return {\n          elemId,\n          pred: [elemId],\n          value\n        };\n      });\n      elems.splice(edit.index, 0, ...newElems);\n    } else if (edit.action === 'update') {\n      const elemId = elems[edit.index].elemId;\n      const value = getValue(edit.value, elems[edit.index].value, updated);\n      elems[edit.index] = {\n        elemId,\n        pred: [edit.opId],\n        value\n      };\n    } else if (edit.action === 'remove') {\n      elems.splice(edit.index, edit.count);\n    }\n  }\n\n  updated[objectId] = instantiateText(objectId, elems);\n  return updated[objectId];\n}\n/**\n * Applies the patch object `patch` to the read-only document object `obj`.\n * Clones a writable copy of `obj` and places it in `updated` (indexed by\n * objectId), if that has not already been done. Returns the updated object.\n */\n\n\nfunction interpretPatch(patch, obj, updated) {\n  // Return original object if it already exists and isn't being modified\n  if (isObject(obj) && (!patch.props || Object.keys(patch.props).length === 0) && (!patch.edits || patch.edits.length === 0) && !updated[patch.objectId]) {\n    return obj;\n  }\n\n  if (patch.type === 'map') {\n    return updateMapObject(patch, obj, updated);\n  } else if (patch.type === 'table') {\n    return updateTableObject(patch, obj, updated);\n  } else if (patch.type === 'list') {\n    return updateListObject(patch, obj, updated);\n  } else if (patch.type === 'text') {\n    return updateTextObject(patch, obj, updated);\n  } else {\n    throw new TypeError(`Unknown object type: ${patch.type}`);\n  }\n}\n/**\n * Creates a writable copy of the immutable document root object `root`.\n */\n\n\nfunction cloneRootObject(root) {\n  if (root[OBJECT_ID] !== '_root') {\n    throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`);\n  }\n\n  return cloneMapObject(root, '_root');\n}\n\nmodule.exports = {\n  interpretPatch,\n  cloneRootObject\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/apply_patch.js"],"names":["isObject","copyObject","parseOpId","require","OBJECT_ID","CONFLICTS","ELEM_IDS","instantiateText","instantiateTable","Counter","getValue","patch","object","updated","objectId","undefined","interpretPatch","datatype","Date","value","lamportCompare","ts1","ts2","regex","time1","test","counter","actorId","time2","applyProperties","props","conflicts","key","Object","keys","values","opIds","sort","reverse","opId","subpatch","length","cloneMapObject","originalObject","defineProperty","updateMapObject","obj","updateTableObject","_clone","remove","_set","byId","RangeError","cloneListObject","originalList","list","slice","elemIds","updateListObject","i","edits","edit","action","oldValue","index","lastValue","conflict","oldValue2","splice","elemId","startElemId","newElems","newValues","newConflicts","forEach","push","type","count","updateTextObject","elems","elem","pred","map","TypeError","cloneRootObject","root","module","exports"],"mappings":"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","sourcesContent":["const { isObject, copyObject, parseOpId } = require('../src/common')\nconst { OBJECT_ID, CONFLICTS, ELEM_IDS } = require('./constants')\nconst { instantiateText } = require('./text')\nconst { instantiateTable } = require('./table')\nconst { Counter } = require('./counter')\n\n/**\n * Reconstructs the value from the patch object `patch`.\n */\nfunction getValue(patch, object, updated) {\n  if (patch.objectId) {\n    // If the objectId of the existing object does not match the objectId in the patch,\n    // that means the patch is replacing the object with a new one made from scratch\n    if (object && object[OBJECT_ID] !== patch.objectId) {\n      object = undefined\n    }\n    return interpretPatch(patch, object, updated)\n  } else if (patch.datatype === 'timestamp') {\n    // Timestamp: value is milliseconds since 1970 epoch\n    return new Date(patch.value)\n  } else if (patch.datatype === 'counter') {\n    return new Counter(patch.value)\n  } else {\n    // Primitive value (int, uint, float64, string, boolean, or null)\n    return patch.value\n  }\n}\n\n/**\n * Compares two strings, interpreted as Lamport timestamps of the form\n * 'counter@actorId'. Returns 1 if ts1 is greater, or -1 if ts2 is greater.\n */\nfunction lamportCompare(ts1, ts2) {\n  const regex = /^(\\d+)@(.*)$/\n  const time1 = regex.test(ts1) ? parseOpId(ts1) : {counter: 0, actorId: ts1}\n  const time2 = regex.test(ts2) ? parseOpId(ts2) : {counter: 0, actorId: ts2}\n  if (time1.counter < time2.counter) return -1\n  if (time1.counter > time2.counter) return  1\n  if (time1.actorId < time2.actorId) return -1\n  if (time1.actorId > time2.actorId) return  1\n  return 0\n}\n\n/**\n * `props` is an object of the form:\n * `{key1: {opId1: {...}, opId2: {...}}, key2: {opId3: {...}}}`\n * where the outer object is a mapping from property names to inner objects,\n * and the inner objects are a mapping from operation ID to sub-patch.\n * This function interprets that structure and updates the objects `object` and\n * `conflicts` to reflect it. For each key, the greatest opId (by Lamport TS\n * order) is chosen as the default resolution; that op's value is assigned\n * to `object[key]`. Moreover, all the opIds and values are packed into a\n * conflicts object of the form `{opId1: value1, opId2: value2}` and assigned\n * to `conflicts[key]`. If there is no conflict, the conflicts object contains\n * just a single opId-value mapping.\n */\nfunction applyProperties(props, object, conflicts, updated) {\n  if (!props) return\n\n  for (let key of Object.keys(props)) {\n    const values = {}, opIds = Object.keys(props[key]).sort(lamportCompare).reverse()\n    for (let opId of opIds) {\n      const subpatch = props[key][opId]\n      if (conflicts[key] && conflicts[key][opId]) {\n        values[opId] = getValue(subpatch, conflicts[key][opId], updated)\n      } else {\n        values[opId] = getValue(subpatch, undefined, updated)\n      }\n    }\n\n    if (opIds.length === 0) {\n      delete object[key]\n      delete conflicts[key]\n    } else {\n      object[key] = values[opIds[0]]\n      conflicts[key] = values\n    }\n  }\n}\n\n/**\n * Creates a writable copy of an immutable map object. If `originalObject`\n * is undefined, creates an empty object with ID `objectId`.\n */\nfunction cloneMapObject(originalObject, objectId) {\n  const object    = copyObject(originalObject)\n  const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : undefined)\n  Object.defineProperty(object, OBJECT_ID, {value: objectId})\n  Object.defineProperty(object, CONFLICTS, {value: conflicts})\n  return object\n}\n\n/**\n * Updates the map object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateMapObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneMapObject(obj, objectId)\n  }\n\n  const object = updated[objectId]\n  applyProperties(patch.props, object, object[CONFLICTS], updated)\n  return object\n}\n\n/**\n * Updates the table object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTableObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = obj ? obj._clone() : instantiateTable(objectId)\n  }\n\n  const object = updated[objectId]\n\n  for (let key of Object.keys(patch.props || {})) {\n    const opIds = Object.keys(patch.props[key])\n\n    if (opIds.length === 0) {\n      object.remove(key)\n    } else if (opIds.length === 1) {\n      const subpatch = patch.props[key][opIds[0]]\n      object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0])\n    } else {\n      throw new RangeError('Conflicts are not supported on properties of a table')\n    }\n  }\n  return object\n}\n\n/**\n * Creates a writable copy of an immutable list object. If `originalList` is\n * undefined, creates an empty list with ID `objectId`.\n */\nfunction cloneListObject(originalList, objectId) {\n  const list = originalList ? originalList.slice() : [] // slice() makes a shallow clone\n  const conflicts = (originalList && originalList[CONFLICTS]) ? originalList[CONFLICTS].slice() : []\n  const elemIds = (originalList && originalList[ELEM_IDS]) ? originalList[ELEM_IDS].slice() : []\n  Object.defineProperty(list, OBJECT_ID, {value: objectId})\n  Object.defineProperty(list, CONFLICTS, {value: conflicts})\n  Object.defineProperty(list, ELEM_IDS,  {value: elemIds})\n  return list\n}\n\n/**\n * Updates the list object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateListObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneListObject(obj, objectId)\n  }\n\n  const list = updated[objectId], conflicts = list[CONFLICTS], elemIds = list[ELEM_IDS]\n  for (let i = 0; i < patch.edits.length; i++) {\n    const edit = patch.edits[i]\n\n    if (edit.action === 'insert' || edit.action === 'update') {\n      const oldValue = conflicts[edit.index] && conflicts[edit.index][edit.opId]\n      let lastValue = getValue(edit.value, oldValue, updated)\n      let values = {[edit.opId]: lastValue}\n\n      // Successive updates for the same index are an indication of a conflict on that list element.\n      // Edits are sorted in increasing order by Lamport timestamp, so the last value (with the\n      // greatest timestamp) is the default resolution of the conflict.\n      while (i < patch.edits.length - 1 && patch.edits[i + 1].index === edit.index &&\n             patch.edits[i + 1].action === 'update') {\n        i++\n        const conflict = patch.edits[i]\n        const oldValue2 = conflicts[conflict.index] && conflicts[conflict.index][conflict.opId]\n        lastValue = getValue(conflict.value, oldValue2, updated)\n        values[conflict.opId] = lastValue\n      }\n\n      if (edit.action === 'insert') {\n        list.splice(edit.index, 0, lastValue)\n        conflicts.splice(edit.index, 0, values)\n        elemIds.splice(edit.index, 0, edit.elemId)\n      } else {\n        list[edit.index] = lastValue\n        conflicts[edit.index] = values\n      }\n\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId), newElems = [], newValues = [], newConflicts = []\n      const datatype = edit.datatype\n      edit.values.forEach((value, index) => {\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`\n        value = getValue({ value, datatype }, undefined, updated)\n        newValues.push(value)\n        newConflicts.push({[elemId]: {value, datatype, type: 'value'}})\n        newElems.push(elemId)\n      })\n      list.splice(edit.index, 0, ...newValues)\n      conflicts.splice(edit.index, 0, ...newConflicts)\n      elemIds.splice(edit.index, 0, ...newElems)\n\n    } else if (edit.action === 'remove') {\n      list.splice(edit.index, edit.count)\n      conflicts.splice(edit.index, edit.count)\n      elemIds.splice(edit.index, edit.count)\n    }\n  }\n  return list\n}\n\n/**\n * Updates the text object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTextObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  let elems\n  if (updated[objectId]) {\n    elems = updated[objectId].elems\n  } else if (obj) {\n    elems = obj.elems.slice()\n  } else {\n    elems = []\n  }\n\n  for (const edit of patch.edits) {\n    if (edit.action === 'insert') {\n      const value = getValue(edit.value, undefined, updated)\n      const elem = {elemId: edit.elemId, pred: [edit.opId], value}\n      elems.splice(edit.index, 0, elem)\n\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId)\n      const datatype = edit.datatype\n      const newElems = edit.values.map((value, index) => {\n        value = getValue({ datatype, value }, undefined, updated)\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`\n        return {elemId, pred: [elemId], value}\n      })\n      elems.splice(edit.index, 0, ...newElems)\n\n    } else if (edit.action === 'update') {\n      const elemId = elems[edit.index].elemId\n      const value = getValue(edit.value, elems[edit.index].value, updated)\n      elems[edit.index] = {elemId, pred: [edit.opId], value}\n\n    } else if (edit.action === 'remove') {\n      elems.splice(edit.index, edit.count)\n    }\n  }\n\n  updated[objectId] = instantiateText(objectId, elems)\n  return updated[objectId]\n}\n\n/**\n * Applies the patch object `patch` to the read-only document object `obj`.\n * Clones a writable copy of `obj` and places it in `updated` (indexed by\n * objectId), if that has not already been done. Returns the updated object.\n */\nfunction interpretPatch(patch, obj, updated) {\n  // Return original object if it already exists and isn't being modified\n  if (isObject(obj) && (!patch.props || Object.keys(patch.props).length === 0) &&\n      (!patch.edits || patch.edits.length === 0) && !updated[patch.objectId]) {\n    return obj\n  }\n\n  if (patch.type === 'map') {\n    return updateMapObject(patch, obj, updated)\n  } else if (patch.type === 'table') {\n    return updateTableObject(patch, obj, updated)\n  } else if (patch.type === 'list') {\n    return updateListObject(patch, obj, updated)\n  } else if (patch.type === 'text') {\n    return updateTextObject(patch, obj, updated)\n  } else {\n    throw new TypeError(`Unknown object type: ${patch.type}`)\n  }\n}\n\n/**\n * Creates a writable copy of the immutable document root object `root`.\n */\nfunction cloneRootObject(root) {\n  if (root[OBJECT_ID] !== '_root') {\n    throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`)\n  }\n  return cloneMapObject(root, '_root')\n}\n\nmodule.exports = {\n  interpretPatch, cloneRootObject\n}\n"]},"metadata":{},"sourceType":"script"}