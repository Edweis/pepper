{"ast":null,"code":"const {\n  OPTIONS,\n  CACHE,\n  STATE,\n  OBJECT_ID,\n  CONFLICTS,\n  CHANGE,\n  ELEM_IDS\n} = require('./constants');\n\nconst {\n  isObject,\n  copyObject\n} = require('../src/common');\n\nconst uuid = require('../src/uuid');\n\nconst {\n  interpretPatch,\n  cloneRootObject\n} = require('./apply_patch');\n\nconst {\n  rootObjectProxy\n} = require('./proxies');\n\nconst {\n  Context\n} = require('./context');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nconst {\n  Counter\n} = require('./counter');\n\nconst {\n  Float64,\n  Int,\n  Uint\n} = require('./numbers');\n\nconst {\n  Observable\n} = require('./observable');\n/**\n * Actor IDs must consist only of hexadecimal digits so that they can be encoded\n * compactly in binary form.\n */\n\n\nfunction checkActorId(actorId) {\n  if (typeof actorId !== 'string') {\n    throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`);\n  }\n\n  if (!/^[0-9a-f]+$/.test(actorId)) {\n    throw new RangeError('actorId must consist only of lowercase hex digits');\n  }\n\n  if (actorId.length % 2 !== 0) {\n    throw new RangeError('actorId must consist of an even number of digits');\n  }\n}\n/**\n * Takes a set of objects that have been updated (in `updated`) and an updated state object\n * `state`, and returns a new immutable document root object based on `doc` that reflects\n * those updates.\n */\n\n\nfunction updateRootObject(doc, updated, state) {\n  let newDoc = updated._root;\n\n  if (!newDoc) {\n    newDoc = cloneRootObject(doc[CACHE]._root);\n    updated._root = newDoc;\n  }\n\n  Object.defineProperty(newDoc, OPTIONS, {\n    value: doc[OPTIONS]\n  });\n  Object.defineProperty(newDoc, CACHE, {\n    value: updated\n  });\n  Object.defineProperty(newDoc, STATE, {\n    value: state\n  });\n\n  if (doc[OPTIONS].freeze) {\n    for (let objectId of Object.keys(updated)) {\n      if (updated[objectId] instanceof Table) {\n        updated[objectId]._freeze();\n      } else if (updated[objectId] instanceof Text) {\n        Object.freeze(updated[objectId].elems);\n        Object.freeze(updated[objectId]);\n      } else {\n        Object.freeze(updated[objectId]);\n        Object.freeze(updated[objectId][CONFLICTS]);\n      }\n    }\n  }\n\n  for (let objectId of Object.keys(doc[CACHE])) {\n    if (!updated[objectId]) {\n      updated[objectId] = doc[CACHE][objectId];\n    }\n  }\n\n  if (doc[OPTIONS].freeze) {\n    Object.freeze(updated);\n  }\n\n  return newDoc;\n}\n/**\n * Adds a new change request to the list of pending requests, and returns an\n * updated document root object.\n * The details of the change are taken from the context object `context`.\n * `options` contains properties that may affect how the change is processed; in\n * particular, the `message` property of `options` is an optional human-readable\n * string describing the change.\n */\n\n\nfunction makeChange(doc, context, options) {\n  const actor = getActorId(doc);\n\n  if (!actor) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  const state = copyObject(doc[STATE]);\n  state.seq += 1;\n  const change = {\n    actor,\n    seq: state.seq,\n    startOp: state.maxOp + 1,\n    deps: state.deps,\n    time: options && typeof options.time === 'number' ? options.time : Math.round(new Date().getTime() / 1000),\n    message: options && typeof options.message === 'string' ? options.message : '',\n    ops: context.ops\n  };\n\n  if (doc[OPTIONS].backend) {\n    const [backendState, patch, binaryChange] = doc[OPTIONS].backend.applyLocalChange(state.backendState, change);\n    state.backendState = backendState;\n    state.lastLocalChange = binaryChange; // NOTE: When performing a local change, the patch is effectively applied twice -- once by the\n    // context invoking interpretPatch as soon as any change is made, and the second time here\n    // (after a round-trip through the backend). This is perhaps more robust, as changes only take\n    // effect in the form processed by the backend, but the downside is a performance cost.\n    // Should we change this?\n\n    const newDoc = applyPatchToDoc(doc, patch, state, true);\n    const patchCallback = options && options.patchCallback || doc[OPTIONS].patchCallback;\n    if (patchCallback) patchCallback(patch, doc, newDoc, true, [binaryChange]);\n    return [newDoc, change];\n  } else {\n    const queuedRequest = {\n      actor,\n      seq: change.seq,\n      before: doc\n    };\n    state.requests = state.requests.concat([queuedRequest]);\n    state.maxOp = state.maxOp + countOps(change.ops);\n    state.deps = [];\n    return [updateRootObject(doc, context ? context.updated : {}, state), change];\n  }\n}\n\nfunction countOps(ops) {\n  let count = 0;\n\n  for (const op of ops) {\n    if (op.action === 'set' && op.values) {\n      count += op.values.length;\n    } else {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n/**\n * Returns the binary encoding of the last change made by the local actor.\n */\n\n\nfunction getLastLocalChange(doc) {\n  return doc[STATE] && doc[STATE].lastLocalChange ? doc[STATE].lastLocalChange : null;\n}\n/**\n * Applies the changes described in `patch` to the document with root object\n * `doc`. The state object `state` is attached to the new root object.\n * `fromBackend` should be set to `true` if the patch came from the backend,\n * and to `false` if the patch is a transient local (optimistically applied)\n * change from the frontend.\n */\n\n\nfunction applyPatchToDoc(doc, patch, state, fromBackend) {\n  const actor = getActorId(doc);\n  const updated = {};\n  interpretPatch(patch.diffs, doc, updated);\n\n  if (fromBackend) {\n    if (!patch.clock) throw new RangeError('patch is missing clock field');\n\n    if (patch.clock[actor] && patch.clock[actor] > state.seq) {\n      state.seq = patch.clock[actor];\n    }\n\n    state.clock = patch.clock;\n    state.deps = patch.deps;\n    state.maxOp = Math.max(state.maxOp, patch.maxOp);\n  }\n\n  return updateRootObject(doc, updated, state);\n}\n/**\n * Creates an empty document object with no changes.\n */\n\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {\n      actorId: options\n    };\n  } else if (typeof options === 'undefined') {\n    options = {};\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported value for init() options: ${options}`);\n  }\n\n  if (!options.deferActorId) {\n    if (options.actorId === undefined) {\n      options.actorId = uuid();\n    }\n\n    checkActorId(options.actorId);\n  }\n\n  if (options.observable) {\n    const patchCallback = options.patchCallback,\n          observable = options.observable;\n\n    options.patchCallback = (patch, before, after, local, changes) => {\n      if (patchCallback) patchCallback(patch, before, after, local, changes);\n      observable.patchCallback(patch, before, after, local, changes);\n    };\n  }\n\n  const root = {},\n        cache = {\n    _root: root\n  };\n  const state = {\n    seq: 0,\n    maxOp: 0,\n    requests: [],\n    clock: {},\n    deps: []\n  };\n\n  if (options.backend) {\n    state.backendState = options.backend.init();\n    state.lastLocalChange = null;\n  }\n\n  Object.defineProperty(root, OBJECT_ID, {\n    value: '_root'\n  });\n  Object.defineProperty(root, OPTIONS, {\n    value: Object.freeze(options)\n  });\n  Object.defineProperty(root, CONFLICTS, {\n    value: Object.freeze({})\n  });\n  Object.defineProperty(root, CACHE, {\n    value: Object.freeze(cache)\n  });\n  Object.defineProperty(root, STATE, {\n    value: Object.freeze(state)\n  });\n  return Object.freeze(root);\n}\n/**\n * Returns a new document object initialized with the given state.\n */\n\n\nfunction from(initialState, options) {\n  return change(init(options), 'Initialization', doc => Object.assign(doc, initialState));\n}\n/**\n * Changes a document `doc` according to actions taken by the local user.\n * `options` is an object that can contain the following properties:\n *  - `message`: an optional descriptive string that is attached to the change.\n * If `options` is a string, it is treated as `message`.\n *\n * The actual change is made within the callback function `callback`, which is\n * given a mutable version of the document as argument. Returns a two-element\n * array `[doc, request]` where `doc` is the updated document, and `request`\n * is the change request to send to the backend. If nothing was actually\n * changed, returns the original `doc` and a `null` change request.\n */\n\n\nfunction change(doc, options, callback) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.change must be the document root');\n  }\n\n  if (doc[CHANGE]) {\n    throw new TypeError('Calls to Automerge.change cannot be nested');\n  }\n\n  if (typeof options === 'function' && callback === undefined) {\n    [options, callback] = [callback, options];\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      message: options\n    };\n  }\n\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options');\n  }\n\n  const actorId = getActorId(doc);\n\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  const context = new Context(doc, actorId);\n  callback(rootObjectProxy(context));\n\n  if (Object.keys(context.updated).length === 0) {\n    // If the callback didn't change anything, return the original document object unchanged\n    return [doc, null];\n  } else {\n    return makeChange(doc, context, options);\n  }\n}\n/**\n * Triggers a new change request on the document `doc` without actually\n * modifying its data. `options` is an object as described in the documentation\n * for the `change` function. This function can be useful for acknowledging the\n * receipt of some message (as it's incorported into the `deps` field of the\n * change). Returns a two-element array `[doc, request]` where `doc` is the\n * updated document, and `request` is the change request to send to the backend.\n */\n\n\nfunction emptyChange(doc, options) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.emptyChange must be the document root');\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      message: options\n    };\n  }\n\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options');\n  }\n\n  const actorId = getActorId(doc);\n\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change');\n  }\n\n  return makeChange(doc, new Context(doc, actorId), options);\n}\n/**\n * Applies `patch` to the document root object `doc`. This patch must come\n * from the backend; it may be the result of a local change or a remote change.\n * If it is the result of a local change, the `seq` field from the change\n * request should be included in the patch, so that we can match them up here.\n */\n\n\nfunction applyPatch(doc, patch) {\n  let backendState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Frontend.applyPatch must be the document root');\n  }\n\n  const state = copyObject(doc[STATE]);\n\n  if (doc[OPTIONS].backend) {\n    if (!backendState) {\n      throw new RangeError('applyPatch must be called with the updated backend state');\n    }\n\n    state.backendState = backendState;\n    return applyPatchToDoc(doc, patch, state, true);\n  }\n\n  let baseDoc;\n\n  if (state.requests.length > 0) {\n    baseDoc = state.requests[0].before;\n\n    if (patch.actor === getActorId(doc)) {\n      if (state.requests[0].seq !== patch.seq) {\n        throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`);\n      }\n\n      state.requests = state.requests.slice(1);\n    } else {\n      state.requests = state.requests.slice();\n    }\n  } else {\n    baseDoc = doc;\n    state.requests = [];\n  }\n\n  let newDoc = applyPatchToDoc(baseDoc, patch, state, true);\n\n  if (state.requests.length === 0) {\n    return newDoc;\n  } else {\n    state.requests[0] = copyObject(state.requests[0]);\n    state.requests[0].before = newDoc;\n    return updateRootObject(doc, {}, state);\n  }\n}\n/**\n * Returns the Automerge object ID of the given object.\n */\n\n\nfunction getObjectId(object) {\n  return object[OBJECT_ID];\n}\n/**\n * Returns the object with the given Automerge object ID. Note: when called\n * within a change callback, the returned object is read-only (not a mutable\n * proxy object).\n */\n\n\nfunction getObjectById(doc, objectId) {\n  // It would be nice to return a proxied object in a change callback.\n  // However, that requires knowing the path from the root to the current\n  // object, which we don't have if we jumped straight to the object by its ID.\n  // If we maintained an index from object ID to parent ID we could work out the path.\n  if (doc[CHANGE]) {\n    throw new TypeError('Cannot use getObjectById in a change callback');\n  }\n\n  return doc[CACHE][objectId];\n}\n/**\n * Returns the Automerge actor ID of the given document.\n */\n\n\nfunction getActorId(doc) {\n  return doc[STATE].actorId || doc[OPTIONS].actorId;\n}\n/**\n * Sets the Automerge actor ID on the document object `doc`, returning a\n * document object with updated metadata.\n */\n\n\nfunction setActorId(doc, actorId) {\n  checkActorId(actorId);\n  const state = Object.assign({}, doc[STATE], {\n    actorId\n  });\n  return updateRootObject(doc, {}, state);\n}\n/**\n * Fetches the conflicts on the property `key` of `object`, which may be any\n * object in a document. If `object` is a list, then `key` must be a list\n * index; if `object` is a map, then `key` must be a property name.\n */\n\n\nfunction getConflicts(object, key) {\n  if (object[CONFLICTS] && object[CONFLICTS][key] && Object.keys(object[CONFLICTS][key]).length > 1) {\n    return object[CONFLICTS][key];\n  }\n}\n/**\n * Returns the backend state associated with the document `doc` (only used if\n * a backend implementation is passed to `init()`).\n */\n\n\nfunction getBackendState(doc) {\n  let callerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let argPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'first';\n\n  if (doc[OBJECT_ID] !== '_root') {\n    // Most likely cause of passing an array here is forgetting to deconstruct the return value of\n    // Automerge.applyChanges().\n    const extraMsg = Array.isArray(doc) ? '. Note: Automerge.applyChanges now returns an array.' : '';\n\n    if (callerName) {\n      throw new TypeError(`The ${argPos} argument to Automerge.${callerName} must be the document root${extraMsg}`);\n    } else {\n      throw new TypeError(`Argument is not an Automerge document root${extraMsg}`);\n    }\n  }\n\n  return doc[STATE].backendState;\n}\n/**\n * Given an array or text object from an Automerge document, returns an array\n * containing the unique element ID of each list element/character.\n */\n\n\nfunction getElementIds(list) {\n  if (list instanceof Text) {\n    return list.elems.map(elem => elem.elemId);\n  } else {\n    return list[ELEM_IDS];\n  }\n}\n\nmodule.exports = {\n  init,\n  from,\n  change,\n  emptyChange,\n  applyPatch,\n  getObjectId,\n  getObjectById,\n  getActorId,\n  setActorId,\n  getConflicts,\n  getLastLocalChange,\n  getBackendState,\n  getElementIds,\n  Text,\n  Table,\n  Counter,\n  Observable,\n  Float64,\n  Int,\n  Uint\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/index.js"],"names":["OPTIONS","CACHE","STATE","OBJECT_ID","CONFLICTS","CHANGE","ELEM_IDS","require","isObject","copyObject","uuid","interpretPatch","cloneRootObject","rootObjectProxy","Context","Text","Table","Counter","Float64","Int","Uint","Observable","checkActorId","actorId","TypeError","test","RangeError","length","updateRootObject","doc","updated","state","newDoc","_root","Object","defineProperty","value","freeze","objectId","keys","_freeze","elems","makeChange","context","options","actor","getActorId","Error","seq","change","startOp","maxOp","deps","time","Math","round","Date","getTime","message","ops","backend","backendState","patch","binaryChange","applyLocalChange","lastLocalChange","applyPatchToDoc","patchCallback","queuedRequest","before","requests","concat","countOps","count","op","action","values","getLastLocalChange","fromBackend","diffs","clock","max","init","deferActorId","undefined","observable","after","local","changes","root","cache","from","initialState","assign","callback","emptyChange","applyPatch","baseDoc","slice","getObjectId","object","getObjectById","setActorId","getConflicts","key","getBackendState","callerName","argPos","extraMsg","Array","isArray","getElementIds","list","map","elem","elemId","module","exports"],"mappings":"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","sourcesContent":["const { OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE, ELEM_IDS } = require('./constants')\nconst { isObject, copyObject } = require('../src/common')\nconst uuid = require('../src/uuid')\nconst { interpretPatch, cloneRootObject } = require('./apply_patch')\nconst { rootObjectProxy } = require('./proxies')\nconst { Context } = require('./context')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter } = require('./counter')\nconst { Float64, Int, Uint } = require('./numbers')\nconst { Observable } = require('./observable')\n\n/**\n * Actor IDs must consist only of hexadecimal digits so that they can be encoded\n * compactly in binary form.\n */\nfunction checkActorId(actorId) {\n  if (typeof actorId !== 'string') {\n    throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`)\n  }\n  if (!/^[0-9a-f]+$/.test(actorId)) {\n    throw new RangeError('actorId must consist only of lowercase hex digits')\n  }\n  if (actorId.length % 2 !== 0) {\n    throw new RangeError('actorId must consist of an even number of digits')\n  }\n}\n\n/**\n * Takes a set of objects that have been updated (in `updated`) and an updated state object\n * `state`, and returns a new immutable document root object based on `doc` that reflects\n * those updates.\n */\nfunction updateRootObject(doc, updated, state) {\n  let newDoc = updated._root\n  if (!newDoc) {\n    newDoc = cloneRootObject(doc[CACHE]._root)\n    updated._root = newDoc\n  }\n  Object.defineProperty(newDoc, OPTIONS,  {value: doc[OPTIONS]})\n  Object.defineProperty(newDoc, CACHE,    {value: updated})\n  Object.defineProperty(newDoc, STATE,    {value: state})\n\n  if (doc[OPTIONS].freeze) {\n    for (let objectId of Object.keys(updated)) {\n      if (updated[objectId] instanceof Table) {\n        updated[objectId]._freeze()\n      } else if (updated[objectId] instanceof Text) {\n        Object.freeze(updated[objectId].elems)\n        Object.freeze(updated[objectId])\n      } else {\n        Object.freeze(updated[objectId])\n        Object.freeze(updated[objectId][CONFLICTS])\n      }\n    }\n  }\n\n  for (let objectId of Object.keys(doc[CACHE])) {\n    if (!updated[objectId]) {\n      updated[objectId] = doc[CACHE][objectId]\n    }\n  }\n\n  if (doc[OPTIONS].freeze) {\n    Object.freeze(updated)\n  }\n  return newDoc\n}\n\n/**\n * Adds a new change request to the list of pending requests, and returns an\n * updated document root object.\n * The details of the change are taken from the context object `context`.\n * `options` contains properties that may affect how the change is processed; in\n * particular, the `message` property of `options` is an optional human-readable\n * string describing the change.\n */\nfunction makeChange(doc, context, options) {\n  const actor = getActorId(doc)\n  if (!actor) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const state = copyObject(doc[STATE])\n  state.seq += 1\n\n  const change = {\n    actor,\n    seq: state.seq,\n    startOp: state.maxOp + 1,\n    deps: state.deps,\n    time: (options && typeof options.time === 'number') ? options.time\n                                                        : Math.round(new Date().getTime() / 1000),\n    message: (options && typeof options.message === 'string') ? options.message : '',\n    ops: context.ops\n  }\n\n  if (doc[OPTIONS].backend) {\n    const [backendState, patch, binaryChange] = doc[OPTIONS].backend.applyLocalChange(state.backendState, change)\n    state.backendState = backendState\n    state.lastLocalChange = binaryChange\n    // NOTE: When performing a local change, the patch is effectively applied twice -- once by the\n    // context invoking interpretPatch as soon as any change is made, and the second time here\n    // (after a round-trip through the backend). This is perhaps more robust, as changes only take\n    // effect in the form processed by the backend, but the downside is a performance cost.\n    // Should we change this?\n    const newDoc = applyPatchToDoc(doc, patch, state, true)\n    const patchCallback = options && options.patchCallback || doc[OPTIONS].patchCallback\n    if (patchCallback) patchCallback(patch, doc, newDoc, true, [binaryChange])\n    return [newDoc, change]\n\n  } else {\n    const queuedRequest = {actor, seq: change.seq, before: doc}\n    state.requests = state.requests.concat([queuedRequest])\n    state.maxOp = state.maxOp + countOps(change.ops)\n    state.deps = []\n    return [updateRootObject(doc, context ? context.updated : {}, state), change]\n  }\n}\n\nfunction countOps(ops) {\n  let count = 0\n  for (const op of ops) {\n    if (op.action === 'set' && op.values) {\n      count += op.values.length\n    } else {\n      count += 1\n    }\n  }\n  return count\n}\n\n/**\n * Returns the binary encoding of the last change made by the local actor.\n */\nfunction getLastLocalChange(doc) {\n  return doc[STATE] && doc[STATE].lastLocalChange ? doc[STATE].lastLocalChange : null\n}\n\n/**\n * Applies the changes described in `patch` to the document with root object\n * `doc`. The state object `state` is attached to the new root object.\n * `fromBackend` should be set to `true` if the patch came from the backend,\n * and to `false` if the patch is a transient local (optimistically applied)\n * change from the frontend.\n */\nfunction applyPatchToDoc(doc, patch, state, fromBackend) {\n  const actor = getActorId(doc)\n  const updated = {}\n  interpretPatch(patch.diffs, doc, updated)\n\n  if (fromBackend) {\n    if (!patch.clock) throw new RangeError('patch is missing clock field')\n    if (patch.clock[actor] && patch.clock[actor] > state.seq) {\n      state.seq = patch.clock[actor]\n    }\n    state.clock = patch.clock\n    state.deps  = patch.deps\n    state.maxOp = Math.max(state.maxOp, patch.maxOp)\n  }\n  return updateRootObject(doc, updated, state)\n}\n\n/**\n * Creates an empty document object with no changes.\n */\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported value for init() options: ${options}`)\n  }\n\n  if (!options.deferActorId) {\n    if (options.actorId === undefined) {\n      options.actorId = uuid()\n    }\n    checkActorId(options.actorId)\n  }\n\n  if (options.observable) {\n    const patchCallback = options.patchCallback, observable = options.observable\n    options.patchCallback = (patch, before, after, local, changes) => {\n      if (patchCallback) patchCallback(patch, before, after, local, changes)\n      observable.patchCallback(patch, before, after, local, changes)\n    }\n  }\n\n  const root = {}, cache = {_root: root}\n  const state = {seq: 0, maxOp: 0, requests: [], clock: {}, deps: []}\n  if (options.backend) {\n    state.backendState = options.backend.init()\n    state.lastLocalChange = null\n  }\n  Object.defineProperty(root, OBJECT_ID, {value: '_root'})\n  Object.defineProperty(root, OPTIONS,   {value: Object.freeze(options)})\n  Object.defineProperty(root, CONFLICTS, {value: Object.freeze({})})\n  Object.defineProperty(root, CACHE,     {value: Object.freeze(cache)})\n  Object.defineProperty(root, STATE,     {value: Object.freeze(state)})\n  return Object.freeze(root)\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  return change(init(options), 'Initialization', doc => Object.assign(doc, initialState))\n}\n\n\n/**\n * Changes a document `doc` according to actions taken by the local user.\n * `options` is an object that can contain the following properties:\n *  - `message`: an optional descriptive string that is attached to the change.\n * If `options` is a string, it is treated as `message`.\n *\n * The actual change is made within the callback function `callback`, which is\n * given a mutable version of the document as argument. Returns a two-element\n * array `[doc, request]` where `doc` is the updated document, and `request`\n * is the change request to send to the backend. If nothing was actually\n * changed, returns the original `doc` and a `null` change request.\n */\nfunction change(doc, options, callback) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.change must be the document root')\n  }\n  if (doc[CHANGE]) {\n    throw new TypeError('Calls to Automerge.change cannot be nested')\n  }\n  if (typeof options === 'function' && callback === undefined) {\n    [options, callback] = [callback, options]\n  }\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const context = new Context(doc, actorId)\n  callback(rootObjectProxy(context))\n\n  if (Object.keys(context.updated).length === 0) {\n    // If the callback didn't change anything, return the original document object unchanged\n    return [doc, null]\n  } else {\n    return makeChange(doc, context, options)\n  }\n}\n\n/**\n * Triggers a new change request on the document `doc` without actually\n * modifying its data. `options` is an object as described in the documentation\n * for the `change` function. This function can be useful for acknowledging the\n * receipt of some message (as it's incorported into the `deps` field of the\n * change). Returns a two-element array `[doc, request]` where `doc` is the\n * updated document, and `request` is the change request to send to the backend.\n */\nfunction emptyChange(doc, options) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.emptyChange must be the document root')\n  }\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  return makeChange(doc, new Context(doc, actorId), options)\n}\n\n/**\n * Applies `patch` to the document root object `doc`. This patch must come\n * from the backend; it may be the result of a local change or a remote change.\n * If it is the result of a local change, the `seq` field from the change\n * request should be included in the patch, so that we can match them up here.\n */\nfunction applyPatch(doc, patch, backendState = undefined) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Frontend.applyPatch must be the document root')\n  }\n  const state = copyObject(doc[STATE])\n\n  if (doc[OPTIONS].backend) {\n    if (!backendState) {\n      throw new RangeError('applyPatch must be called with the updated backend state')\n    }\n    state.backendState = backendState\n    return applyPatchToDoc(doc, patch, state, true)\n  }\n\n  let baseDoc\n\n  if (state.requests.length > 0) {\n    baseDoc = state.requests[0].before\n    if (patch.actor === getActorId(doc)) {\n      if (state.requests[0].seq !== patch.seq) {\n        throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`)\n      }\n      state.requests = state.requests.slice(1)\n    } else {\n      state.requests = state.requests.slice()\n    }\n  } else {\n    baseDoc = doc\n    state.requests = []\n  }\n\n  let newDoc = applyPatchToDoc(baseDoc, patch, state, true)\n  if (state.requests.length === 0) {\n    return newDoc\n  } else {\n    state.requests[0] = copyObject(state.requests[0])\n    state.requests[0].before = newDoc\n    return updateRootObject(doc, {}, state)\n  }\n}\n\n/**\n * Returns the Automerge object ID of the given object.\n */\nfunction getObjectId(object) {\n  return object[OBJECT_ID]\n}\n\n/**\n * Returns the object with the given Automerge object ID. Note: when called\n * within a change callback, the returned object is read-only (not a mutable\n * proxy object).\n */\nfunction getObjectById(doc, objectId) {\n  // It would be nice to return a proxied object in a change callback.\n  // However, that requires knowing the path from the root to the current\n  // object, which we don't have if we jumped straight to the object by its ID.\n  // If we maintained an index from object ID to parent ID we could work out the path.\n  if (doc[CHANGE]) {\n    throw new TypeError('Cannot use getObjectById in a change callback')\n  }\n  return doc[CACHE][objectId]\n}\n\n/**\n * Returns the Automerge actor ID of the given document.\n */\nfunction getActorId(doc) {\n  return doc[STATE].actorId || doc[OPTIONS].actorId\n}\n\n/**\n * Sets the Automerge actor ID on the document object `doc`, returning a\n * document object with updated metadata.\n */\nfunction setActorId(doc, actorId) {\n  checkActorId(actorId)\n  const state = Object.assign({}, doc[STATE], {actorId})\n  return updateRootObject(doc, {}, state)\n}\n\n/**\n * Fetches the conflicts on the property `key` of `object`, which may be any\n * object in a document. If `object` is a list, then `key` must be a list\n * index; if `object` is a map, then `key` must be a property name.\n */\nfunction getConflicts(object, key) {\n  if (object[CONFLICTS] && object[CONFLICTS][key] &&\n      Object.keys(object[CONFLICTS][key]).length > 1) {\n    return object[CONFLICTS][key]\n  }\n}\n\n/**\n * Returns the backend state associated with the document `doc` (only used if\n * a backend implementation is passed to `init()`).\n */\nfunction getBackendState(doc, callerName = null, argPos = 'first') {\n  if (doc[OBJECT_ID] !== '_root') {\n    // Most likely cause of passing an array here is forgetting to deconstruct the return value of\n    // Automerge.applyChanges().\n    const extraMsg = Array.isArray(doc) ? '. Note: Automerge.applyChanges now returns an array.' : ''\n    if (callerName) {\n      throw new TypeError(`The ${argPos} argument to Automerge.${callerName} must be the document root${extraMsg}`)\n    } else {\n      throw new TypeError(`Argument is not an Automerge document root${extraMsg}`)\n    }\n  }\n  return doc[STATE].backendState\n}\n\n/**\n * Given an array or text object from an Automerge document, returns an array\n * containing the unique element ID of each list element/character.\n */\nfunction getElementIds(list) {\n  if (list instanceof Text) {\n    return list.elems.map(elem => elem.elemId)\n  } else {\n    return list[ELEM_IDS]\n  }\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, applyPatch,\n  getObjectId, getObjectById, getActorId, setActorId, getConflicts, getLastLocalChange,\n  getBackendState, getElementIds,\n  Text, Table, Counter, Observable, Float64, Int, Uint\n}\n"]},"metadata":{},"sourceType":"script"}