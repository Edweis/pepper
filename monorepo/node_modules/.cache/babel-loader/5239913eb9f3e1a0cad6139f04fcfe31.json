{"ast":null,"code":"const {\n  OBJECT_ID,\n  CONFLICTS\n} = require('./constants');\n/**\n * Allows an application to register a callback when a particular object in\n * a document changes.\n *\n * NOTE: This API is experimental and may change without warning in minor releases.\n */\n\n\nclass Observable {\n  constructor() {\n    this.observers = {}; // map from objectId to array of observers for that object\n  }\n  /**\n   * Called by an Automerge document when `patch` is applied. `before` is the\n   * state of the document before the patch, and `after` is the state after\n   * applying it. `local` is true if the update is a result of locally calling\n   * `Automerge.change()`, and false otherwise. `changes` is an array of\n   * changes that were applied to the document (as Uint8Arrays).\n   */\n\n\n  patchCallback(patch, before, after, local, changes) {\n    this._objectUpdate(patch.diffs, before, after, local, changes);\n  }\n  /**\n   * Recursively walks a patch and calls the callbacks for all objects that\n   * appear in the patch.\n   */\n\n\n  _objectUpdate(diff, before, after, local, changes) {\n    if (!diff.objectId) return;\n\n    if (this.observers[diff.objectId]) {\n      for (let callback of this.observers[diff.objectId]) {\n        callback(diff, before, after, local, changes);\n      }\n    }\n\n    if (diff.type === 'map' && diff.props) {\n      for (const propName of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[propName])) {\n          this._objectUpdate(diff.props[propName][opId], before && before[CONFLICTS] && before[CONFLICTS][propName] && before[CONFLICTS][propName][opId], after && after[CONFLICTS] && after[CONFLICTS][propName] && after[CONFLICTS][propName][opId], local, changes);\n        }\n      }\n    } else if (diff.type === 'table' && diff.props) {\n      for (const rowId of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[rowId])) {\n          this._objectUpdate(diff.props[rowId][opId], before && before.byId(rowId), after && after.byId(rowId), local, changes);\n        }\n      }\n    } else if (diff.type === 'list' && diff.edits) {\n      let offset = 0;\n\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1;\n\n          this._objectUpdate(edit.value, undefined, after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.elemId], local, changes);\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length;\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value, before && before[CONFLICTS] && before[CONFLICTS][edit.index + offset] && before[CONFLICTS][edit.index + offset][edit.opId], after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.opId], local, changes);\n        } else if (edit.action === 'remove') {\n          offset += edit.count;\n        }\n      }\n    } else if (diff.type === 'text' && diff.edits) {\n      let offset = 0;\n\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1;\n\n          this._objectUpdate(edit.value, undefined, after && after.get(edit.index), local, changes);\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length;\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value, before && before.get(edit.index + offset), after && after.get(edit.index), local, changes);\n        } else if (edit.action === 'remove') {\n          offset += edit.count;\n        }\n      }\n    }\n  }\n  /**\n   * Call this to register a callback that will get called whenever a particular\n   * object in a document changes. The callback is passed five arguments: the\n   * part of the patch describing the update to that object, the old state of\n   * the object, the new state of the object, a boolean that is true if the\n   * change is the result of calling `Automerge.change()` locally, and the array\n   * of binary changes applied to the document.\n   */\n\n\n  observe(object, callback) {\n    const objectId = object[OBJECT_ID];\n    if (!objectId) throw new TypeError('The observed object must be part of an Automerge document');\n    if (!this.observers[objectId]) this.observers[objectId] = [];\n    this.observers[objectId].push(callback);\n  }\n\n}\n\nmodule.exports = {\n  Observable\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/observable.js"],"names":["OBJECT_ID","CONFLICTS","require","Observable","constructor","observers","patchCallback","patch","before","after","local","changes","_objectUpdate","diffs","diff","objectId","callback","type","props","propName","Object","keys","opId","rowId","byId","edits","offset","edit","action","value","undefined","index","elemId","values","length","count","get","observe","object","TypeError","push","module","exports"],"mappings":"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","sourcesContent":["const { OBJECT_ID, CONFLICTS } = require('./constants')\n\n/**\n * Allows an application to register a callback when a particular object in\n * a document changes.\n *\n * NOTE: This API is experimental and may change without warning in minor releases.\n */\nclass Observable {\n  constructor() {\n    this.observers = {} // map from objectId to array of observers for that object\n  }\n\n  /**\n   * Called by an Automerge document when `patch` is applied. `before` is the\n   * state of the document before the patch, and `after` is the state after\n   * applying it. `local` is true if the update is a result of locally calling\n   * `Automerge.change()`, and false otherwise. `changes` is an array of\n   * changes that were applied to the document (as Uint8Arrays).\n   */\n  patchCallback(patch, before, after, local, changes) {\n    this._objectUpdate(patch.diffs, before, after, local, changes)\n  }\n\n  /**\n   * Recursively walks a patch and calls the callbacks for all objects that\n   * appear in the patch.\n   */\n  _objectUpdate(diff, before, after, local, changes) {\n    if (!diff.objectId) return\n    if (this.observers[diff.objectId]) {\n      for (let callback of this.observers[diff.objectId]) {\n        callback(diff, before, after, local, changes)\n      }\n    }\n\n    if (diff.type === 'map' && diff.props) {\n      for (const propName of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[propName])) {\n          this._objectUpdate(diff.props[propName][opId],\n                             before && before[CONFLICTS] && before[CONFLICTS][propName] && before[CONFLICTS][propName][opId],\n                             after && after[CONFLICTS] && after[CONFLICTS][propName] && after[CONFLICTS][propName][opId],\n                             local, changes)\n        }\n      }\n\n    } else if (diff.type === 'table' && diff.props) {\n      for (const rowId of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[rowId])) {\n          this._objectUpdate(diff.props[rowId][opId],\n                             before && before.byId(rowId),\n                             after && after.byId(rowId),\n                             local, changes)\n        }\n      }\n\n    } else if (diff.type === 'list' && diff.edits) {\n      let offset = 0\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1\n          this._objectUpdate(edit.value, undefined,\n                             after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.elemId],\n                             local, changes)\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value,\n                             before && before[CONFLICTS] && before[CONFLICTS][edit.index + offset] &&\n                               before[CONFLICTS][edit.index + offset][edit.opId],\n                             after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.opId],\n                             local, changes)\n        } else if (edit.action === 'remove') {\n          offset += edit.count\n        }\n      }\n\n    } else if (diff.type === 'text' && diff.edits) {\n      let offset = 0\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1\n          this._objectUpdate(edit.value, undefined, after && after.get(edit.index), local, changes)\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value,\n                             before && before.get(edit.index + offset),\n                             after && after.get(edit.index),\n                             local, changes)\n        } else if (edit.action === 'remove') {\n          offset += edit.count\n        }\n      }\n    }\n  }\n\n  /**\n   * Call this to register a callback that will get called whenever a particular\n   * object in a document changes. The callback is passed five arguments: the\n   * part of the patch describing the update to that object, the old state of\n   * the object, the new state of the object, a boolean that is true if the\n   * change is the result of calling `Automerge.change()` locally, and the array\n   * of binary changes applied to the document.\n   */\n  observe(object, callback) {\n    const objectId = object[OBJECT_ID]\n    if (!objectId) throw new TypeError('The observed object must be part of an Automerge document')\n    if (!this.observers[objectId]) this.observers[objectId] = []\n    this.observers[objectId].push(callback)\n  }\n}\n\nmodule.exports = { Observable }\n"]},"metadata":{},"sourceType":"script"}