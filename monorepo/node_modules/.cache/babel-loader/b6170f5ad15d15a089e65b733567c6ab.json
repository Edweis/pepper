{"ast":null,"code":"'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst {\n  _tr_init,\n  _tr_stored_block,\n  _tr_flush_block,\n  _tr_tally,\n  _tr_align\n} = require('./trees');\n\nconst adler32 = require('./adler32');\n\nconst crc32 = require('./crc32');\n\nconst msg = require('./messages');\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n\n\nconst {\n  Z_NO_FLUSH,\n  Z_PARTIAL_FLUSH,\n  Z_FULL_FLUSH,\n  Z_FINISH,\n  Z_BLOCK,\n  Z_OK,\n  Z_STREAM_END,\n  Z_STREAM_ERROR,\n  Z_DATA_ERROR,\n  Z_BUF_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_FILTERED,\n  Z_HUFFMAN_ONLY,\n  Z_RLE,\n  Z_FIXED,\n  Z_DEFAULT_STRATEGY,\n  Z_UNKNOWN,\n  Z_DEFLATED\n} = require('./constants');\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\n\nconst DEF_MEM_LEVEL = 8;\nconst LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES = 30;\n/* number of distance codes */\n\nconst BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */\n\nconst MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nconst PRESET_DICT = 0x20;\nconst INIT_STATE = 42;\nconst EXTRA_STATE = 69;\nconst NAME_STATE = 73;\nconst COMMENT_STATE = 91;\nconst HCRC_STATE = 103;\nconst BUSY_STATE = 113;\nconst FINISH_STATE = 666;\nconst BS_NEED_MORE = 1;\n/* block not completed, need more input or more output */\n\nconst BS_BLOCK_DONE = 2;\n/* block flush performed */\n\nconst BS_FINISH_STARTED = 3;\n/* finish started, need only more output at next deflate */\n\nconst BS_FINISH_DONE = 4;\n/* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = msg[errorCode];\n  return errorCode;\n};\n\nconst rank = f => {\n  return (f << 1) - (f > 4 ? 9 : 0);\n};\n\nconst zero = buf => {\n  let len = buf.length;\n\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n};\n/* eslint-disable new-cap */\n\n\nlet HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\n\nlet HASH = HASH_ZLIB;\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\n\nconst flush_pending = strm => {\n  const s = strm.state; //_tr_flush_bits(s);\n\n  let len = s.pending;\n\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n\n  if (len === 0) {\n    return;\n  }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\n\n\nconst putShortMSB = (s, b) => {\n  //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\n\n\nconst read_buf = (strm, buf, start, size) => {\n  let len = strm.avail_in;\n\n  if (len > size) {\n    len = size;\n  }\n\n  if (len === 0) {\n    return 0;\n  }\n\n  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n  return len;\n};\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\n\n\nconst longest_match = (s, cur_match) => {\n  let chain_length = s.max_chain_length;\n  /* max hash chain length */\n\n  let scan = s.strstart;\n  /* current string */\n\n  let match;\n  /* matched string */\n\n  let len;\n  /* length of current match */\n\n  let best_len = s.prev_length;\n  /* best match length so far */\n\n  let nice_match = s.nice_match;\n  /* stop if match long enough */\n\n  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n  /*NIL*/\n  ;\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev = s.prev;\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1 = _win[scan + best_len - 1];\n  let scan_end = _win[scan + best_len];\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n\n\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead;\n  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n      continue;\n    }\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n\n\n    scan += 2;\n    match++; // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n\n      if (len >= nice_match) {\n        break;\n      }\n\n      scan_end1 = _win[scan + best_len - 1];\n      scan_end = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n\n  return s.lookahead;\n};\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\n\n\nconst fill_window = s => {\n  const _w_size = s.w_size;\n  let p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n\n      s.block_start -= _w_size;\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n\n      do {\n        m = s.head[--p];\n        s.head[p] = m >= _w_size ? m - _w_size : 0;\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n\n      do {\n        m = s.prev[--p];\n        s.prev[p] = m >= _w_size ? m - _w_size : 0;\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n\n\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n    /* Initialize the hash value now that we have some input: */\n\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); //#if MIN_MATCH != 3\n      //        Call update_hash() MIN_MATCH-3 more times\n      //#endif\n\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n  //  if (s.high_water < s.window_size) {\n  //    const curr = s.strstart + s.lookahead;\n  //    let init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n\n};\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\n\n\nconst deflate_stored = (s, flush) => {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  let max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n  /* Copy as much as possible from input to output: */\n\n\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n      //        s.block_start >= s.w_size)) {\n      //        throw  new Error(\"slide too late\");\n      //      }\n      fill_window(s);\n\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    } //Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n    /* Emit a stored block if pending_buf will be full: */\n\n    const max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n\n\n    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_NEED_MORE;\n};\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\n\n\nconst deflate_fast = (s, flush) => {\n  let hash_head;\n  /* head of the hash chain */\n\n  let bflush;\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n        /* flush the current block */\n      }\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n\n    hash_head = 0\n    /*NIL*/\n    ;\n\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n\n\n    if (hash_head !== 0\n    /*NIL*/\n    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n\n      if (s.match_length <= s.max_lazy_match\n      /*max_insert_length*/\n      && s.lookahead >= MIN_MATCH) {\n        s.match_length--;\n        /* string at strstart already in table */\n\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n\n        s.strstart++;\n      } else {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); //#if MIN_MATCH != 3\n        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n};\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\n\n\nconst deflate_slow = (s, flush) => {\n  let hash_head;\n  /* head of hash chain */\n\n  let bflush;\n  /* set if current block must be flushed */\n\n  let max_insert;\n  /* Process the input block. */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n\n    hash_head = 0\n    /*NIL*/\n    ;\n\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     */\n\n\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0\n    /*NIL*/\n    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n    /*MAX_DIST(s)*/\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096\n      /*TOO_FAR*/\n      )) {\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n\n\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n\n      }\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n\n      s.strstart++;\n      s.lookahead--;\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  } //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n    s.match_available = 0;\n  }\n\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n};\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\n\n\nconst deflate_rle = (s, flush) => {\n  let bflush;\n  /* set if current block must be flushed */\n\n  let prev;\n  /* byte at distance one to match */\n\n  let scan, strend;\n  /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n\n    }\n    /* See how many times the previous byte repeats */\n\n\n    s.match_length = 0;\n\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\n        s.match_length = MAX_MATCH - (strend - scan);\n\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      } //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\n    }\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n};\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\n\n\nconst deflate_huff = (s, flush) => {\n  let bflush;\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n\n        break;\n        /* flush the current block */\n      }\n    }\n    /* Output a literal byte */\n\n\n    s.match_length = 0; //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n\n\n    return BS_FINISH_DONE;\n  }\n\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n\n  }\n\n  return BS_BLOCK_DONE;\n};\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\n\n\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n/*      good lazy nice chain */\nnew Config(0, 0, 0, 0, deflate_stored),\n/* 0 store only */\nnew Config(4, 4, 8, 4, deflate_fast),\n/* 1 max speed, no lazy matches */\nnew Config(4, 5, 16, 8, deflate_fast),\n/* 2 */\nnew Config(4, 6, 32, 32, deflate_fast),\n/* 3 */\nnew Config(4, 4, 16, 16, deflate_slow),\n/* 4 lazy matches */\nnew Config(8, 16, 32, 32, deflate_slow),\n/* 5 */\nnew Config(8, 16, 128, 128, deflate_slow),\n/* 6 */\nnew Config(8, 32, 128, 256, deflate_slow),\n/* 7 */\nnew Config(32, 128, 258, 1024, deflate_slow),\n/* 8 */\nnew Config(32, 258, 258, 4096, deflate_slow)\n/* 9 max compression */\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\n\nconst lm_init = s => {\n  s.window_size = 2 * s.w_size;\n  /*** CLEAR_HASH(s); ***/\n\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\nfunction DeflateState() {\n  this.strm = null;\n  /* pointer back to this zlib stream */\n\n  this.status = 0;\n  /* as the name implies */\n\n  this.pending_buf = null;\n  /* output still pending */\n\n  this.pending_buf_size = 0;\n  /* size of pending_buf */\n\n  this.pending_out = 0;\n  /* next pending byte to output to the stream */\n\n  this.pending = 0;\n  /* nb of bytes in the pending buffer */\n\n  this.wrap = 0;\n  /* bit 0 true for zlib, bit 1 true for gzip */\n\n  this.gzhead = null;\n  /* gzip header information to write */\n\n  this.gzindex = 0;\n  /* where in extra, name, or comment */\n\n  this.method = Z_DEFLATED;\n  /* can only be DEFLATED */\n\n  this.last_flush = -1;\n  /* value of flush param for previous deflate call */\n\n  this.w_size = 0;\n  /* LZ77 window size (32K by default) */\n\n  this.w_bits = 0;\n  /* log2(w_size)  (8..16) */\n\n  this.w_mask = 0;\n  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;\n  /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;\n  /* hash index of string to be inserted */\n\n  this.hash_size = 0;\n  /* number of elements in hash table */\n\n  this.hash_bits = 0;\n  /* log2(hash_size) */\n\n  this.hash_mask = 0;\n  /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;\n  /* length of best match */\n\n  this.prev_match = 0;\n  /* previous match */\n\n  this.match_available = 0;\n  /* set if previous match exists */\n\n  this.strstart = 0;\n  /* start of string to insert */\n\n  this.match_start = 0;\n  /* start of matching string */\n\n  this.lookahead = 0;\n  /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;\n  /* compression level (1..9) */\n\n  this.strategy = 0;\n  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0;\n  /* Stop searching when current match exceeds this */\n\n  /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n\n  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n  this.l_desc = null;\n  /* desc. for literal tree */\n\n  this.d_desc = null;\n  /* desc. for distance tree */\n\n  this.bl_desc = null;\n  /* desc. for bit length tree */\n  //ush bl_count[MAX_BITS+1];\n\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n  this.heap = new Uint16Array(2 * L_CODES + 1);\n  /* heap used to build the Huffman trees */\n\n  zero(this.heap);\n  this.heap_len = 0;\n  /* number of elements in the heap */\n\n  this.heap_max = 0;\n  /* element of largest frequency */\n\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;\n  /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;\n  /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;\n  /* bit length of current block with optimal trees */\n\n  this.static_len = 0;\n  /* bit length of current block with static trees */\n\n  this.matches = 0;\n  /* number of string matches in current block */\n\n  this.insert = 0;\n  /* bytes at end of window left to insert */\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\nconst deflateResetKeep = strm => {\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n\n  s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n  : 1; // adler32(0, Z_NULL, 0)\n\n  s.last_flush = Z_NO_FLUSH;\n\n  _tr_init(s);\n\n  return Z_OK;\n};\n\nconst deflateReset = strm => {\n  const ret = deflateResetKeep(strm);\n\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n\n  return ret;\n};\n\nconst deflateSetHeader = (strm, head) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR;\n  }\n\n  if (strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR;\n  }\n\n  strm.state.gzhead = head;\n  return Z_OK;\n};\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n  if (!strm) {\n    // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) {\n    /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  } else if (windowBits > 15) {\n    wrap = 2;\n    /* write gzip wrapper instead */\n\n    windowBits -= 16;\n  }\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n\n  const s = new DeflateState();\n  strm.state = s;\n  s.strm = strm;\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << memLevel + 6;\n  /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n\n  s.pending_buf = new Uint8Array(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n};\n\nconst deflate = (strm, flush) => {\n  let beg, val; // for gzip header write only\n\n  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm;\n  /* just in case */\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n  /* Write the header */\n\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      // GZIP header\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n\n      if (!s.gzhead) {\n        // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      } else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, s.gzhead.time >> 8 & 0xff);\n        put_byte(s, s.gzhead.time >> 16 & 0xff);\n        put_byte(s, s.gzhead.time >> 24 & 0xff);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, s.gzhead.os & 0xff);\n\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n        }\n\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    } else // DEFLATE header\n      {\n        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n        let level_flags = -1;\n\n        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n          level_flags = 0;\n        } else if (s.level < 6) {\n          level_flags = 1;\n        } else if (s.level === 6) {\n          level_flags = 2;\n        } else {\n          level_flags = 3;\n        }\n\n        header |= level_flags << 6;\n\n        if (s.strstart !== 0) {\n          header |= PRESET_DICT;\n        }\n\n        header += 31 - header % 31;\n        s.status = BUSY_STATE;\n        putShortMSB(s, header);\n        /* Save the adler32 of the preset dictionary: */\n\n        if (s.strstart !== 0) {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n\n        strm.adler = 1; // adler32(0L, Z_NULL, 0);\n      }\n  } //#ifdef GZIP\n\n\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra\n    /* != Z_NULL*/\n    ) {\n      beg = s.pending;\n      /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          flush_pending(strm);\n          beg = s.pending;\n\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    } else {\n      s.status = NAME_STATE;\n    }\n  }\n\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name\n    /* != Z_NULL*/\n    ) {\n      beg = s.pending;\n      /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          flush_pending(strm);\n          beg = s.pending;\n\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        } // JS specific: little magic to add zero terminator to end of string\n\n\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    } else {\n      s.status = COMMENT_STATE;\n    }\n  }\n\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment\n    /* != Z_NULL*/\n    ) {\n      beg = s.pending;\n      /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n\n          flush_pending(strm);\n          beg = s.pending;\n\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        } // JS specific: little magic to add zero terminator to end of string\n\n\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    } else {\n      s.status = HCRC_STATE;\n    }\n  }\n\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n        s.status = BUSY_STATE;\n      }\n    } else {\n      s.status = BUSY_STATE;\n    }\n  } //#endif\n\n  /* Flush as much pending output as possible */\n\n\n  if (s.pending !== 0) {\n    flush_pending(strm);\n\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n  /* User must not provide more input after the first FINISH: */\n\n\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n  /* Start a new block or continue the current one.\n   */\n\n\n  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      } else if (flush !== Z_BLOCK) {\n        /* FULL_FLUSH or SYNC_FLUSH */\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n\n\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/\n\n          /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n\n      flush_pending(strm);\n\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR at next call, see above */\n\n        return Z_OK;\n      }\n    }\n  } //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n\n  if (flush !== Z_FINISH) {\n    return Z_OK;\n  }\n\n  if (s.wrap <= 0) {\n    return Z_STREAM_END;\n  }\n  /* Write the trailer */\n\n\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, strm.adler >> 8 & 0xff);\n    put_byte(s, strm.adler >> 16 & 0xff);\n    put_byte(s, strm.adler >> 24 & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, strm.total_in >> 8 & 0xff);\n    put_byte(s, strm.total_in >> 16 & 0xff);\n    put_byte(s, strm.total_in >> 24 & 0xff);\n  } else {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap;\n  }\n  /* write the trailer only once! */\n\n\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n};\n\nconst deflateEnd = strm => {\n  if (!strm\n  /*== Z_NULL*/\n  || !strm.state\n  /*== Z_NULL*/\n  ) {\n    return Z_STREAM_ERROR;\n  }\n\n  const status = strm.state.status;\n\n  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n};\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\n\n\nconst deflateSetDictionary = (strm, dictionary) => {\n  let dictLength = dictionary.length;\n\n  if (!strm\n  /*== Z_NULL*/\n  || !strm.state\n  /*== Z_NULL*/\n  ) {\n    return Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;\n  /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {\n      /* already empty otherwise */\n\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n\n\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n\n\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n};\n\nmodule.exports.deflateInit = deflateInit;\nmodule.exports.deflateInit2 = deflateInit2;\nmodule.exports.deflateReset = deflateReset;\nmodule.exports.deflateResetKeep = deflateResetKeep;\nmodule.exports.deflateSetHeader = deflateSetHeader;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateEnd = deflateEnd;\nmodule.exports.deflateSetDictionary = deflateSetDictionary;\nmodule.exports.deflateInfo = 'pako deflate (from Nodeca project)';\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/pako/lib/zlib/deflate.js"],"names":["_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","_tr_align","require","adler32","crc32","msg","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","rank","f","zero","buf","len","length","HASH_ZLIB","s","prev","data","hash_shift","hash_mask","HASH","flush_pending","state","pending","avail_out","output","set","pending_buf","subarray","pending_out","next_out","total_out","flush_block_only","last","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","window","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","Uint16Array","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","Uint8Array","deflateInit","deflate","beg","val","old_flush","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","module","exports","deflateInfo"],"mappings":"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","sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require('./trees');\nconst adler32 = require('./adler32');\nconst crc32   = require('./crc32');\nconst msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,\n  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,\n  Z_UNKNOWN,\n  Z_DEFLATED\n} = require('./constants');\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE = 42;\nconst EXTRA_STATE = 69;\nconst NAME_STATE = 73;\nconst COMMENT_STATE = 91;\nconst HCRC_STATE = 103;\nconst BUSY_STATE = 113;\nconst FINISH_STATE = 666;\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = msg[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  let max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    const max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n};\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  _tr_init(s);\n  return Z_OK;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n};\n\n\nconst deflate = (strm, flush) => {\n\n  let beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      let level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n};\n\n\nmodule.exports.deflateInit = deflateInit;\nmodule.exports.deflateInit2 = deflateInit2;\nmodule.exports.deflateReset = deflateReset;\nmodule.exports.deflateResetKeep = deflateResetKeep;\nmodule.exports.deflateSetHeader = deflateSetHeader;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateEnd = deflateEnd;\nmodule.exports.deflateSetDictionary = deflateSetDictionary;\nmodule.exports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n"]},"metadata":{},"sourceType":"script"}