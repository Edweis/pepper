{"ast":null,"code":"const pako = require('pako');\n\nconst {\n  copyObject,\n  parseOpId,\n  equalBytes\n} = require('../src/common');\n\nconst {\n  utf8ToString,\n  hexStringToBytes,\n  bytesToHexString,\n  Encoder,\n  Decoder,\n  RLEEncoder,\n  RLEDecoder,\n  DeltaEncoder,\n  DeltaDecoder,\n  BooleanEncoder,\n  BooleanDecoder\n} = require('./encoding'); // Maybe we should be using the platform's built-in hash implementation?\n// Node has the crypto module: https://nodejs.org/api/crypto.html and browsers have\n// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n// However, the WebCrypto API is asynchronous (returns promises), which would\n// force all our APIs to become asynchronous as well, which would be annoying.\n//\n// I think on balance, it's safe enough to use a random library off npm:\n// - We only need one hash function (not a full suite of crypto algorithms);\n// - SHA256 is quite simple and has fairly few opportunities for subtle bugs\n//   (compared to asymmetric cryptography anyway);\n// - It does not need a secure source of random bits and does not need to be\n//   constant-time;\n// - I have reviewed the source code and it seems pretty reasonable.\n\n\nconst {\n  Hash\n} = require('fast-sha256'); // These bytes don't mean anything, they were generated randomly\n\n\nconst MAGIC_BYTES = new Uint8Array([0x85, 0x6f, 0x4a, 0x83]);\nconst CHUNK_TYPE_DOCUMENT = 0;\nconst CHUNK_TYPE_CHANGE = 1;\nconst CHUNK_TYPE_DEFLATE = 2; // like CHUNK_TYPE_CHANGE but with DEFLATE compression\n// Minimum number of bytes in a value before we enable DEFLATE compression (there is no point\n// compressing very short values since compression may actually make them bigger)\n\nconst DEFLATE_MIN_SIZE = 256; // The least-significant 3 bits of a columnId indicate its datatype\n\nconst COLUMN_TYPE = {\n  GROUP_CARD: 0,\n  ACTOR_ID: 1,\n  INT_RLE: 2,\n  INT_DELTA: 3,\n  BOOLEAN: 4,\n  STRING_RLE: 5,\n  VALUE_LEN: 6,\n  VALUE_RAW: 7\n}; // The 4th-least-significant bit of a columnId is set if the column is DEFLATE-compressed\n\nconst COLUMN_TYPE_DEFLATE = 8; // In the values in a column of type VALUE_LEN, the bottom four bits indicate the type of the value,\n// one of the following types in VALUE_TYPE. The higher bits indicate the length of the value in the\n// associated VALUE_RAW column (in bytes).\n\nconst VALUE_TYPE = {\n  NULL: 0,\n  FALSE: 1,\n  TRUE: 2,\n  LEB128_UINT: 3,\n  LEB128_INT: 4,\n  IEEE754: 5,\n  UTF8: 6,\n  BYTES: 7,\n  COUNTER: 8,\n  TIMESTAMP: 9,\n  MIN_UNKNOWN: 10,\n  MAX_UNKNOWN: 15\n}; // make* actions must be at even-numbered indexes in this list\n\nconst ACTIONS = ['makeMap', 'set', 'makeList', 'del', 'makeText', 'inc', 'makeTable', 'link'];\nconst OBJECT_TYPE = {\n  makeMap: 'map',\n  makeList: 'list',\n  makeText: 'text',\n  makeTable: 'table'\n};\nconst COMMON_COLUMNS = [{\n  columnName: 'objActor',\n  columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'objCtr',\n  columnId: 0 << 4 | COLUMN_TYPE.INT_RLE\n}, {\n  columnName: 'keyActor',\n  columnId: 1 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'keyCtr',\n  columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'keyStr',\n  columnId: 1 << 4 | COLUMN_TYPE.STRING_RLE\n}, {\n  columnName: 'idActor',\n  columnId: 2 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'idCtr',\n  columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'insert',\n  columnId: 3 << 4 | COLUMN_TYPE.BOOLEAN\n}, {\n  columnName: 'action',\n  columnId: 4 << 4 | COLUMN_TYPE.INT_RLE\n}, {\n  columnName: 'valLen',\n  columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN\n}, {\n  columnName: 'valRaw',\n  columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW\n}, {\n  columnName: 'chldActor',\n  columnId: 6 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'chldCtr',\n  columnId: 6 << 4 | COLUMN_TYPE.INT_DELTA\n}];\nconst CHANGE_COLUMNS = COMMON_COLUMNS.concat([{\n  columnName: 'predNum',\n  columnId: 7 << 4 | COLUMN_TYPE.GROUP_CARD\n}, {\n  columnName: 'predActor',\n  columnId: 7 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'predCtr',\n  columnId: 7 << 4 | COLUMN_TYPE.INT_DELTA\n}]);\nconst DOC_OPS_COLUMNS = COMMON_COLUMNS.concat([{\n  columnName: 'succNum',\n  columnId: 8 << 4 | COLUMN_TYPE.GROUP_CARD\n}, {\n  columnName: 'succActor',\n  columnId: 8 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'succCtr',\n  columnId: 8 << 4 | COLUMN_TYPE.INT_DELTA\n}]);\nconst DOCUMENT_COLUMNS = [{\n  columnName: 'actor',\n  columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID\n}, {\n  columnName: 'seq',\n  columnId: 0 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'maxOp',\n  columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'time',\n  columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'message',\n  columnId: 3 << 4 | COLUMN_TYPE.STRING_RLE\n}, {\n  columnName: 'depsNum',\n  columnId: 4 << 4 | COLUMN_TYPE.GROUP_CARD\n}, {\n  columnName: 'depsIndex',\n  columnId: 4 << 4 | COLUMN_TYPE.INT_DELTA\n}, {\n  columnName: 'extraLen',\n  columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN\n}, {\n  columnName: 'extraRaw',\n  columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW\n}];\n/**\n * Maps an opId of the form {counter: 12345, actorId: 'someActorId'} to the form\n * {counter: 12345, actorNum: 123, actorId: 'someActorId'}, where the actorNum\n * is the index into the `actorIds` array.\n */\n\nfunction actorIdToActorNum(opId, actorIds) {\n  if (!opId || !opId.actorId) return opId;\n  const counter = opId.counter;\n  const actorNum = actorIds.indexOf(opId.actorId);\n  if (actorNum < 0) throw new RangeError('missing actorId'); // should not happen\n\n  return {\n    counter,\n    actorNum,\n    actorId: opId.actorId\n  };\n}\n/**\n * Comparison function to pass to Array.sort(), which compares two opIds in the\n * form produced by `actorIdToActorNum` so that they are sorted in increasing\n * Lamport timestamp order (sorted first by counter, then by actorId).\n */\n\n\nfunction compareParsedOpIds(id1, id2) {\n  if (id1.counter < id2.counter) return -1;\n  if (id1.counter > id2.counter) return +1;\n  if (id1.actorId < id2.actorId) return -1;\n  if (id1.actorId > id2.actorId) return +1;\n  return 0;\n}\n/**\n * Takes `changes`, an array of changes (represented as JS objects). Returns an\n * object `{changes, actorIds}`, where `changes` is a copy of the argument in\n * which all string opIds have been replaced with `{counter, actorNum}` objects,\n * and where `actorIds` is a lexicographically sorted array of actor IDs occurring\n * in any of the operations. `actorNum` is an index into that array of actorIds.\n * If `single` is true, the actorId of the author of the change is moved to the\n * beginning of the array of actorIds, so that `actorNum` is zero when referencing\n * the author of the change itself. This special-casing is omitted if `single` is\n * false.\n */\n\n\nfunction parseAllOpIds(changes, single) {\n  const actors = {},\n        newChanges = [];\n\n  for (let change of changes) {\n    change = copyObject(change);\n    actors[change.actor] = true;\n    change.ops = expandMultiOps(change.ops, change.startOp, change.actor);\n    change.ops = change.ops.map(op => {\n      op = copyObject(op);\n      if (op.obj !== '_root') op.obj = parseOpId(op.obj);\n      if (op.elemId && op.elemId !== '_head') op.elemId = parseOpId(op.elemId);\n      if (op.child) op.child = parseOpId(op.child);\n      if (op.pred) op.pred = op.pred.map(parseOpId);\n      if (op.obj.actorId) actors[op.obj.actorId] = true;\n      if (op.elemId && op.elemId.actorId) actors[op.elemId.actorId] = true;\n      if (op.child && op.child.actorId) actors[op.child.actorId] = true;\n\n      for (let pred of op.pred) actors[pred.actorId] = true;\n\n      return op;\n    });\n    newChanges.push(change);\n  }\n\n  let actorIds = Object.keys(actors).sort();\n\n  if (single) {\n    actorIds = [changes[0].actor].concat(actorIds.filter(actor => actor !== changes[0].actor));\n  }\n\n  for (let change of newChanges) {\n    change.actorNum = actorIds.indexOf(change.actor);\n\n    for (let i = 0; i < change.ops.length; i++) {\n      let op = change.ops[i];\n      op.id = {\n        counter: change.startOp + i,\n        actorNum: change.actorNum,\n        actorId: change.actor\n      };\n      op.obj = actorIdToActorNum(op.obj, actorIds);\n      op.elemId = actorIdToActorNum(op.elemId, actorIds);\n      op.child = actorIdToActorNum(op.child, actorIds);\n      op.pred = op.pred.map(pred => actorIdToActorNum(pred, actorIds));\n    }\n  }\n\n  return {\n    changes: newChanges,\n    actorIds\n  };\n}\n/**\n * Encodes the `obj` property of operation `op` into the two columns\n * `objActor` and `objCtr`.\n */\n\n\nfunction encodeObjectId(op, columns) {\n  if (op.obj === '_root') {\n    columns.objActor.appendValue(null);\n    columns.objCtr.appendValue(null);\n  } else if (op.obj.actorNum >= 0 && op.obj.counter > 0) {\n    columns.objActor.appendValue(op.obj.actorNum);\n    columns.objCtr.appendValue(op.obj.counter);\n  } else {\n    throw new RangeError(`Unexpected objectId reference: ${JSON.stringify(op.obj)}`);\n  }\n}\n/**\n * Encodes the `key` and `elemId` properties of operation `op` into the three\n * columns `keyActor`, `keyCtr`, and `keyStr`.\n */\n\n\nfunction encodeOperationKey(op, columns) {\n  if (op.key) {\n    columns.keyActor.appendValue(null);\n    columns.keyCtr.appendValue(null);\n    columns.keyStr.appendValue(op.key);\n  } else if (op.elemId === '_head' && op.insert) {\n    columns.keyActor.appendValue(null);\n    columns.keyCtr.appendValue(0);\n    columns.keyStr.appendValue(null);\n  } else if (op.elemId && op.elemId.actorNum >= 0 && op.elemId.counter > 0) {\n    columns.keyActor.appendValue(op.elemId.actorNum);\n    columns.keyCtr.appendValue(op.elemId.counter);\n    columns.keyStr.appendValue(null);\n  } else {\n    throw new RangeError(`Unexpected operation key: ${JSON.stringify(op)}`);\n  }\n}\n/**\n * Encodes the `action` property of operation `op` into the `action` column.\n */\n\n\nfunction encodeOperationAction(op, columns) {\n  const actionCode = ACTIONS.indexOf(op.action);\n\n  if (actionCode >= 0) {\n    columns.action.appendValue(actionCode);\n  } else if (typeof op.action === 'number') {\n    columns.action.appendValue(op.action);\n  } else {\n    throw new RangeError(`Unexpected operation action: ${op.action}`);\n  }\n}\n/**\n * Given the datatype for a number, determine the typeTag and the value to encode\n * otherwise guess\n */\n\n\nfunction getNumberTypeAndValue(op) {\n  switch (op.datatype) {\n    case \"counter\":\n      return [VALUE_TYPE.COUNTER, op.value];\n\n    case \"timestamp\":\n      return [VALUE_TYPE.TIMESTAMP, op.value];\n\n    case \"uint\":\n      return [VALUE_TYPE.LEB128_UINT, op.value];\n\n    case \"int\":\n      return [VALUE_TYPE.LEB128_INT, op.value];\n\n    case \"float64\":\n      {\n        const buf64 = new ArrayBuffer(8),\n              view64 = new DataView(buf64);\n        view64.setFloat64(0, op.value, true);\n        return [VALUE_TYPE.IEEE754, new Uint8Array(buf64)];\n      }\n\n    default:\n      // increment operators get resolved here ...\n      if (Number.isInteger(op.value) && op.value <= Number.MAX_SAFE_INTEGER && op.value >= Number.MIN_SAFE_INTEGER) {\n        return [VALUE_TYPE.LEB128_INT, op.value];\n      } else {\n        const buf64 = new ArrayBuffer(8),\n              view64 = new DataView(buf64);\n        view64.setFloat64(0, op.value, true);\n        return [VALUE_TYPE.IEEE754, new Uint8Array(buf64)];\n      }\n\n  }\n}\n/**\n * Encodes the `value` property of operation `op` into the two columns\n * `valLen` and `valRaw`.\n */\n\n\nfunction encodeValue(op, columns) {\n  if (op.action !== 'set' && op.action !== 'inc' || op.value === null) {\n    columns.valLen.appendValue(VALUE_TYPE.NULL);\n  } else if (op.value === false) {\n    columns.valLen.appendValue(VALUE_TYPE.FALSE);\n  } else if (op.value === true) {\n    columns.valLen.appendValue(VALUE_TYPE.TRUE);\n  } else if (typeof op.value === 'string') {\n    const numBytes = columns.valRaw.appendRawString(op.value);\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.UTF8);\n  } else if (ArrayBuffer.isView(op.value)) {\n    const numBytes = columns.valRaw.appendRawBytes(new Uint8Array(op.value.buffer));\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.BYTES);\n  } else if (typeof op.value === 'number') {\n    let [typeTag, value] = getNumberTypeAndValue(op);\n    let numBytes;\n\n    if (typeTag === VALUE_TYPE.LEB128_UINT) {\n      numBytes = columns.valRaw.appendUint53(value);\n    } else if (typeTag === VALUE_TYPE.IEEE754) {\n      numBytes = columns.valRaw.appendRawBytes(value);\n    } else {\n      numBytes = columns.valRaw.appendInt53(value);\n    }\n\n    columns.valLen.appendValue(numBytes << 4 | typeTag);\n  } else if (typeof op.datatype === 'number' && op.datatype >= VALUE_TYPE.MIN_UNKNOWN && op.datatype <= VALUE_TYPE.MAX_UNKNOWN && op.value instanceof Uint8Array) {\n    const numBytes = columns.valRaw.appendRawBytes(op.value);\n    columns.valLen.appendValue(numBytes << 4 | op.datatype);\n  } else if (op.datatype) {\n    throw new RangeError(`Unknown datatype ${op.datatype} for value ${op.value}`);\n  } else {\n    throw new RangeError(`Unsupported value in operation: ${op.value}`);\n  }\n}\n/**\n * Given `sizeTag` (an unsigned integer read from a VALUE_LEN column) and `bytes` (a Uint8Array\n * read from a VALUE_RAW column, with length `sizeTag >> 4`), this function returns an object of the\n * form `{value: value, datatype: datatypeTag}` where `value` is a JavaScript primitive datatype\n * corresponding to the value, and `datatypeTag` is a datatype annotation such as 'counter'.\n */\n\n\nfunction decodeValue(sizeTag, bytes) {\n  if (sizeTag === VALUE_TYPE.NULL) {\n    return {\n      value: null\n    };\n  } else if (sizeTag === VALUE_TYPE.FALSE) {\n    return {\n      value: false\n    };\n  } else if (sizeTag === VALUE_TYPE.TRUE) {\n    return {\n      value: true\n    };\n  } else if (sizeTag % 16 === VALUE_TYPE.UTF8) {\n    return {\n      value: utf8ToString(bytes)\n    };\n  } else {\n    if (sizeTag % 16 === VALUE_TYPE.LEB128_UINT) {\n      return {\n        value: new Decoder(bytes).readUint53(),\n        datatype: \"uint\"\n      };\n    } else if (sizeTag % 16 === VALUE_TYPE.LEB128_INT) {\n      return {\n        value: new Decoder(bytes).readInt53(),\n        datatype: \"int\"\n      };\n    } else if (sizeTag % 16 === VALUE_TYPE.IEEE754) {\n      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n      if (bytes.byteLength === 8) {\n        return {\n          value: view.getFloat64(0, true),\n          datatype: \"float64\"\n        };\n      } else {\n        throw new RangeError(`Invalid length for floating point number: ${bytes.byteLength}`);\n      }\n    } else if (sizeTag % 16 === VALUE_TYPE.COUNTER) {\n      return {\n        value: new Decoder(bytes).readInt53(),\n        datatype: 'counter'\n      };\n    } else if (sizeTag % 16 === VALUE_TYPE.TIMESTAMP) {\n      return {\n        value: new Decoder(bytes).readInt53(),\n        datatype: 'timestamp'\n      };\n    } else {\n      return {\n        value: bytes,\n        datatype: sizeTag % 16\n      };\n    }\n  }\n}\n/**\n * Reads one value from the column `columns[colIndex]` and interprets it based\n * on the column type. `actorIds` is a list of actors that appear in the change;\n * `actorIds[0]` is the actorId of the change's author. Mutates the `result`\n * object with the value, and returns the number of columns processed (this is 2\n * in the case of a pair of VALUE_LEN and VALUE_RAW columns, which are processed\n * in one go).\n */\n\n\nfunction decodeValueColumns(columns, colIndex, actorIds, result) {\n  const {\n    columnId,\n    columnName,\n    decoder\n  } = columns[colIndex];\n\n  if (columnId % 8 === COLUMN_TYPE.VALUE_LEN && colIndex + 1 < columns.length && columns[colIndex + 1].columnId === columnId + 1) {\n    const sizeTag = decoder.readValue();\n    const rawValue = columns[colIndex + 1].decoder.readRawBytes(sizeTag >> 4);\n    const {\n      value,\n      datatype\n    } = decodeValue(sizeTag, rawValue);\n    result[columnName] = value;\n    if (datatype) result[columnName + '_datatype'] = datatype;\n    return 2;\n  } else if (columnId % 8 === COLUMN_TYPE.ACTOR_ID) {\n    const actorNum = decoder.readValue();\n\n    if (actorNum === null) {\n      result[columnName] = null;\n    } else {\n      if (!actorIds[actorNum]) throw new RangeError(`No actor index ${actorNum}`);\n      result[columnName] = actorIds[actorNum];\n    }\n  } else {\n    result[columnName] = decoder.readValue();\n  }\n\n  return 1;\n}\n/**\n * Encodes an array of operations in a set of columns. The operations need to\n * be parsed with `parseAllOpIds()` beforehand. If `forDocument` is true, we use\n * the column structure of a whole document, otherwise we use the column\n * structure for an individual change. Returns an array of\n * `{columnId, columnName, encoder}` objects.\n */\n\n\nfunction encodeOps(ops, forDocument) {\n  const columns = {\n    objActor: new RLEEncoder('uint'),\n    objCtr: new RLEEncoder('uint'),\n    keyActor: new RLEEncoder('uint'),\n    keyCtr: new DeltaEncoder(),\n    keyStr: new RLEEncoder('utf8'),\n    insert: new BooleanEncoder(),\n    action: new RLEEncoder('uint'),\n    valLen: new RLEEncoder('uint'),\n    valRaw: new Encoder(),\n    chldActor: new RLEEncoder('uint'),\n    chldCtr: new DeltaEncoder()\n  };\n\n  if (forDocument) {\n    columns.idActor = new RLEEncoder('uint');\n    columns.idCtr = new DeltaEncoder();\n    columns.succNum = new RLEEncoder('uint');\n    columns.succActor = new RLEEncoder('uint');\n    columns.succCtr = new DeltaEncoder();\n  } else {\n    columns.predNum = new RLEEncoder('uint');\n    columns.predCtr = new DeltaEncoder();\n    columns.predActor = new RLEEncoder('uint');\n  }\n\n  for (let op of ops) {\n    encodeObjectId(op, columns);\n    encodeOperationKey(op, columns);\n    columns.insert.appendValue(!!op.insert);\n    encodeOperationAction(op, columns);\n    encodeValue(op, columns);\n\n    if (op.child && op.child.counter) {\n      columns.chldActor.appendValue(op.child.actorNum);\n      columns.chldCtr.appendValue(op.child.counter);\n    } else {\n      columns.chldActor.appendValue(null);\n      columns.chldCtr.appendValue(null);\n    }\n\n    if (forDocument) {\n      columns.idActor.appendValue(op.id.actorNum);\n      columns.idCtr.appendValue(op.id.counter);\n      columns.succNum.appendValue(op.succ.length);\n      op.succ.sort(compareParsedOpIds);\n\n      for (let i = 0; i < op.succ.length; i++) {\n        columns.succActor.appendValue(op.succ[i].actorNum);\n        columns.succCtr.appendValue(op.succ[i].counter);\n      }\n    } else {\n      columns.predNum.appendValue(op.pred.length);\n      op.pred.sort(compareParsedOpIds);\n\n      for (let i = 0; i < op.pred.length; i++) {\n        columns.predActor.appendValue(op.pred[i].actorNum);\n        columns.predCtr.appendValue(op.pred[i].counter);\n      }\n    }\n  }\n\n  let columnList = [];\n\n  for (let {\n    columnName,\n    columnId\n  } of forDocument ? DOC_OPS_COLUMNS : CHANGE_COLUMNS) {\n    if (columns[columnName]) columnList.push({\n      columnId,\n      columnName,\n      encoder: columns[columnName]\n    });\n  }\n\n  return columnList.sort((a, b) => a.columnId - b.columnId);\n}\n\nfunction validDatatype(value, datatype) {\n  if (datatype === undefined) {\n    return typeof value === 'string' || typeof value === 'boolean' || value === null;\n  } else {\n    return typeof value === 'number';\n  }\n}\n\nfunction expandMultiOps(ops, startOp, actor) {\n  let opNum = startOp;\n  let expandedOps = [];\n\n  for (const op of ops) {\n    if (op.action === 'set' && op.values && op.insert) {\n      if (op.pred.length !== 0) throw new RangeError('multi-insert pred must be empty');\n      let lastElemId = op.elemId;\n      const datatype = op.datatype;\n\n      for (const value of op.values) {\n        if (!validDatatype(value, datatype)) throw new RangeError(`Decode failed: bad value/datatype association (${value},${datatype})`);\n        expandedOps.push({\n          action: 'set',\n          obj: op.obj,\n          elemId: lastElemId,\n          datatype,\n          value,\n          pred: [],\n          insert: true\n        });\n        lastElemId = `${opNum}@${actor}`;\n        opNum += 1;\n      }\n    } else if (op.action === 'del' && op.multiOp > 1) {\n      if (op.pred.length !== 1) throw new RangeError('multiOp deletion must have exactly one pred');\n      const startElemId = parseOpId(op.elemId),\n            startPred = parseOpId(op.pred[0]);\n\n      for (let i = 0; i < op.multiOp; i++) {\n        const elemId = `${startElemId.counter + i}@${startElemId.actorId}`;\n        const pred = [`${startPred.counter + i}@${startPred.actorId}`];\n        expandedOps.push({\n          action: 'del',\n          obj: op.obj,\n          elemId,\n          pred\n        });\n        opNum += 1;\n      }\n    } else {\n      expandedOps.push(op);\n      opNum += 1;\n    }\n  }\n\n  return expandedOps;\n}\n/**\n * Takes a change as decoded by `decodeColumns`, and changes it into the form\n * expected by the rest of the backend. If `forDocument` is true, we use the op\n * structure of a whole document, otherwise we use the op structure for an\n * individual change.\n */\n\n\nfunction decodeOps(ops, forDocument) {\n  const newOps = [];\n\n  for (let op of ops) {\n    const obj = op.objCtr === null ? '_root' : `${op.objCtr}@${op.objActor}`;\n    const elemId = op.keyStr ? undefined : op.keyCtr === 0 ? '_head' : `${op.keyCtr}@${op.keyActor}`;\n    const action = ACTIONS[op.action] || op.action;\n    const newOp = elemId ? {\n      obj,\n      elemId,\n      action\n    } : {\n      obj,\n      key: op.keyStr,\n      action\n    };\n    newOp.insert = !!op.insert;\n\n    if (ACTIONS[op.action] === 'set' || ACTIONS[op.action] === 'inc') {\n      newOp.value = op.valLen;\n      if (op.valLen_datatype) newOp.datatype = op.valLen_datatype;\n    }\n\n    if (!!op.chldCtr !== !!op.chldActor) {\n      throw new RangeError(`Mismatched child columns: ${op.chldCtr} and ${op.chldActor}`);\n    }\n\n    if (op.chldCtr !== null) newOp.child = `${op.chldCtr}@${op.chldActor}`;\n\n    if (forDocument) {\n      newOp.id = `${op.idCtr}@${op.idActor}`;\n      newOp.succ = op.succNum.map(succ => `${succ.succCtr}@${succ.succActor}`);\n      checkSortedOpIds(op.succNum.map(succ => ({\n        counter: succ.succCtr,\n        actorId: succ.succActor\n      })));\n    } else {\n      newOp.pred = op.predNum.map(pred => `${pred.predCtr}@${pred.predActor}`);\n      checkSortedOpIds(op.predNum.map(pred => ({\n        counter: pred.predCtr,\n        actorId: pred.predActor\n      })));\n    }\n\n    newOps.push(newOp);\n  }\n\n  return newOps;\n}\n/**\n * Throws an exception if the opIds in the given array are not in sorted order.\n */\n\n\nfunction checkSortedOpIds(opIds) {\n  let last = null;\n\n  for (let opId of opIds) {\n    if (last && compareParsedOpIds(last, opId) !== -1) {\n      throw new RangeError('operation IDs are not in ascending order');\n    }\n\n    last = opId;\n  }\n}\n\nfunction encoderByColumnId(columnId) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaEncoder();\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanEncoder();\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEEncoder('utf8');\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Encoder();\n  } else {\n    return new RLEEncoder('uint');\n  }\n}\n\nfunction decoderByColumnId(columnId, buffer) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaDecoder(buffer);\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanDecoder(buffer);\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEDecoder('utf8', buffer);\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Decoder(buffer);\n  } else {\n    return new RLEDecoder('uint', buffer);\n  }\n}\n\nfunction makeDecoders(columns, columnSpec) {\n  const emptyBuf = new Uint8Array(0);\n  let decoders = [],\n      columnIndex = 0,\n      specIndex = 0;\n\n  while (columnIndex < columns.length || specIndex < columnSpec.length) {\n    if (columnIndex === columns.length || specIndex < columnSpec.length && columnSpec[specIndex].columnId < columns[columnIndex].columnId) {\n      const {\n        columnId,\n        columnName\n      } = columnSpec[specIndex];\n      decoders.push({\n        columnId,\n        columnName,\n        decoder: decoderByColumnId(columnId, emptyBuf)\n      });\n      specIndex++;\n    } else if (specIndex === columnSpec.length || columns[columnIndex].columnId < columnSpec[specIndex].columnId) {\n      const {\n        columnId,\n        buffer\n      } = columns[columnIndex];\n      decoders.push({\n        columnId,\n        decoder: decoderByColumnId(columnId, buffer)\n      });\n      columnIndex++;\n    } else {\n      // columns[columnIndex].columnId === columnSpec[specIndex].columnId\n      const {\n        columnId,\n        buffer\n      } = columns[columnIndex],\n            {\n        columnName\n      } = columnSpec[specIndex];\n      decoders.push({\n        columnId,\n        columnName,\n        decoder: decoderByColumnId(columnId, buffer)\n      });\n      columnIndex++;\n      specIndex++;\n    }\n  }\n\n  return decoders;\n}\n\nfunction decodeColumns(columns, actorIds, columnSpec) {\n  columns = makeDecoders(columns, columnSpec);\n  let parsedRows = [];\n\n  while (columns.some(col => !col.decoder.done)) {\n    let row = {},\n        col = 0;\n\n    while (col < columns.length) {\n      const columnId = columns[col].columnId;\n      let groupId = columnId >> 4,\n          groupCols = 1;\n\n      while (col + groupCols < columns.length && columns[col + groupCols].columnId >> 4 === groupId) {\n        groupCols++;\n      }\n\n      if (columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        const values = [],\n              count = columns[col].decoder.readValue();\n\n        for (let i = 0; i < count; i++) {\n          let value = {};\n\n          for (let colOffset = 1; colOffset < groupCols; colOffset++) {\n            decodeValueColumns(columns, col + colOffset, actorIds, value);\n          }\n\n          values.push(value);\n        }\n\n        row[columns[col].columnName] = values;\n        col += groupCols;\n      } else {\n        col += decodeValueColumns(columns, col, actorIds, row);\n      }\n    }\n\n    parsedRows.push(row);\n  }\n\n  return parsedRows;\n}\n\nfunction decodeColumnInfo(decoder) {\n  // A number that is all 1 bits except for the bit that indicates whether a column is\n  // deflate-compressed. We ignore this bit when checking whether columns are sorted by ID.\n  const COLUMN_ID_MASK = (-1 ^ COLUMN_TYPE_DEFLATE) >>> 0;\n  let lastColumnId = -1,\n      columns = [],\n      numColumns = decoder.readUint53();\n\n  for (let i = 0; i < numColumns; i++) {\n    const columnId = decoder.readUint53(),\n          bufferLen = decoder.readUint53();\n\n    if ((columnId & COLUMN_ID_MASK) <= (lastColumnId & COLUMN_ID_MASK)) {\n      throw new RangeError('Columns must be in ascending order');\n    }\n\n    lastColumnId = columnId;\n    columns.push({\n      columnId,\n      bufferLen\n    });\n  }\n\n  return columns;\n}\n\nfunction encodeColumnInfo(encoder, columns) {\n  const nonEmptyColumns = columns.filter(column => column.encoder.buffer.byteLength > 0);\n  encoder.appendUint53(nonEmptyColumns.length);\n\n  for (let column of nonEmptyColumns) {\n    encoder.appendUint53(column.columnId);\n    encoder.appendUint53(column.encoder.buffer.byteLength);\n  }\n}\n\nfunction decodeChangeHeader(decoder) {\n  const numDeps = decoder.readUint53(),\n        deps = [];\n\n  for (let i = 0; i < numDeps; i++) {\n    deps.push(bytesToHexString(decoder.readRawBytes(32)));\n  }\n\n  let change = {\n    actor: decoder.readHexString(),\n    seq: decoder.readUint53(),\n    startOp: decoder.readUint53(),\n    time: decoder.readInt53(),\n    message: decoder.readPrefixedString(),\n    deps\n  };\n  const actorIds = [change.actor],\n        numActorIds = decoder.readUint53();\n\n  for (let i = 0; i < numActorIds; i++) actorIds.push(decoder.readHexString());\n\n  change.actorIds = actorIds;\n  return change;\n}\n/**\n * Assembles a chunk of encoded data containing a checksum, headers, and a\n * series of encoded columns. Calls `encodeHeaderCallback` with an encoder that\n * should be used to add the headers. The columns should be given as `columns`.\n */\n\n\nfunction encodeContainer(chunkType, encodeContentsCallback) {\n  const CHECKSUM_SIZE = 4; // checksum is first 4 bytes of SHA-256 hash of the rest of the data\n\n  const HEADER_SPACE = MAGIC_BYTES.byteLength + CHECKSUM_SIZE + 1 + 5; // 1 byte type + 5 bytes length\n\n  const body = new Encoder(); // Make space for the header at the beginning of the body buffer. We will\n  // copy the header in here later. This is cheaper than copying the body since\n  // the body is likely to be much larger than the header.\n\n  body.appendRawBytes(new Uint8Array(HEADER_SPACE));\n  encodeContentsCallback(body);\n  const bodyBuf = body.buffer;\n  const header = new Encoder();\n  header.appendByte(chunkType);\n  header.appendUint53(bodyBuf.byteLength - HEADER_SPACE); // Compute the hash over chunkType, length, and body\n\n  const headerBuf = header.buffer;\n  const sha256 = new Hash();\n  sha256.update(headerBuf);\n  sha256.update(bodyBuf.subarray(HEADER_SPACE));\n  const hash = sha256.digest(),\n        checksum = hash.subarray(0, CHECKSUM_SIZE); // Copy header into the body buffer so that they are contiguous\n\n  bodyBuf.set(MAGIC_BYTES, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength);\n  bodyBuf.set(checksum, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE);\n  bodyBuf.set(headerBuf, HEADER_SPACE - headerBuf.byteLength);\n  return {\n    hash,\n    bytes: bodyBuf.subarray(HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)\n  };\n}\n\nfunction decodeContainerHeader(decoder, computeHash) {\n  if (!equalBytes(decoder.readRawBytes(MAGIC_BYTES.byteLength), MAGIC_BYTES)) {\n    throw new RangeError('Data does not begin with magic bytes 85 6f 4a 83');\n  }\n\n  const expectedHash = decoder.readRawBytes(4);\n  const hashStartOffset = decoder.offset;\n  const chunkType = decoder.readByte();\n  const chunkLength = decoder.readUint53();\n  const header = {\n    chunkType,\n    chunkLength,\n    chunkData: decoder.readRawBytes(chunkLength)\n  };\n\n  if (computeHash) {\n    const sha256 = new Hash();\n    sha256.update(decoder.buf.subarray(hashStartOffset, decoder.offset));\n    const binaryHash = sha256.digest();\n\n    if (!equalBytes(binaryHash.subarray(0, 4), expectedHash)) {\n      throw new RangeError('checksum does not match data');\n    }\n\n    header.hash = bytesToHexString(binaryHash);\n  }\n\n  return header;\n}\n\nfunction encodeChange(changeObj) {\n  const {\n    changes,\n    actorIds\n  } = parseAllOpIds([changeObj], true);\n  const change = changes[0];\n  const {\n    hash,\n    bytes\n  } = encodeContainer(CHUNK_TYPE_CHANGE, encoder => {\n    if (!Array.isArray(change.deps)) throw new TypeError('deps is not an array');\n    encoder.appendUint53(change.deps.length);\n\n    for (let hash of change.deps.slice().sort()) {\n      encoder.appendRawBytes(hexStringToBytes(hash));\n    }\n\n    encoder.appendHexString(change.actor);\n    encoder.appendUint53(change.seq);\n    encoder.appendUint53(change.startOp);\n    encoder.appendInt53(change.time);\n    encoder.appendPrefixedString(change.message || '');\n    encoder.appendUint53(actorIds.length - 1);\n\n    for (let actor of actorIds.slice(1)) encoder.appendHexString(actor);\n\n    const columns = encodeOps(change.ops, false);\n    encodeColumnInfo(encoder, columns);\n\n    for (let column of columns) encoder.appendRawBytes(column.encoder.buffer);\n\n    if (change.extraBytes) encoder.appendRawBytes(change.extraBytes);\n  });\n  const hexHash = bytesToHexString(hash);\n\n  if (changeObj.hash && changeObj.hash !== hexHash) {\n    throw new RangeError(`Change hash does not match encoding: ${changeObj.hash} != ${hexHash}`);\n  }\n\n  return bytes.byteLength >= DEFLATE_MIN_SIZE ? deflateChange(bytes) : bytes;\n}\n\nfunction decodeChangeColumns(buffer) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer);\n  const decoder = new Decoder(buffer);\n  const header = decodeContainerHeader(decoder, true);\n  const chunkDecoder = new Decoder(header.chunkData);\n  if (!decoder.done) throw new RangeError('Encoded change has trailing data');\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);\n  const change = decodeChangeHeader(chunkDecoder);\n  const columns = decodeColumnInfo(chunkDecoder);\n\n  for (let i = 0; i < columns.length; i++) {\n    if ((columns[i].columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n      throw new RangeError('change must not contain deflated columns');\n    }\n\n    columns[i].buffer = chunkDecoder.readRawBytes(columns[i].bufferLen);\n  }\n\n  if (!chunkDecoder.done) {\n    const restLen = chunkDecoder.buf.byteLength - chunkDecoder.offset;\n    change.extraBytes = chunkDecoder.readRawBytes(restLen);\n  }\n\n  change.columns = columns;\n  change.hash = header.hash;\n  return change;\n}\n/**\n * Decodes one change in binary format into its JS object representation.\n */\n\n\nfunction decodeChange(buffer) {\n  const change = decodeChangeColumns(buffer);\n  change.ops = decodeOps(decodeColumns(change.columns, change.actorIds, CHANGE_COLUMNS), false);\n  delete change.actorIds;\n  delete change.columns;\n  return change;\n}\n/**\n * Decodes the header fields of a change in binary format, but does not decode\n * the operations. Saves work when we only need to inspect the headers. Only\n * computes the hash of the change if `computeHash` is true.\n */\n\n\nfunction decodeChangeMeta(buffer, computeHash) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer);\n  const header = decodeContainerHeader(new Decoder(buffer), computeHash);\n\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) {\n    throw new RangeError('Buffer chunk type is not a change');\n  }\n\n  const meta = decodeChangeHeader(new Decoder(header.chunkData));\n  meta.change = buffer;\n  if (computeHash) meta.hash = header.hash;\n  return meta;\n}\n/**\n * Compresses a binary change using DEFLATE.\n */\n\n\nfunction deflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false);\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);\n  const compressed = pako.deflateRaw(header.chunkData);\n  const encoder = new Encoder();\n  encoder.appendRawBytes(buffer.subarray(0, 8)); // copy MAGIC_BYTES and checksum\n\n  encoder.appendByte(CHUNK_TYPE_DEFLATE);\n  encoder.appendUint53(compressed.byteLength);\n  encoder.appendRawBytes(compressed);\n  return encoder.buffer;\n}\n/**\n * Decompresses a binary change that has been compressed with DEFLATE.\n */\n\n\nfunction inflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false);\n  if (header.chunkType !== CHUNK_TYPE_DEFLATE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);\n  const decompressed = pako.inflateRaw(header.chunkData);\n  const encoder = new Encoder();\n  encoder.appendRawBytes(buffer.subarray(0, 8)); // copy MAGIC_BYTES and checksum\n\n  encoder.appendByte(CHUNK_TYPE_CHANGE);\n  encoder.appendUint53(decompressed.byteLength);\n  encoder.appendRawBytes(decompressed);\n  return encoder.buffer;\n}\n/**\n * Takes an Uint8Array that may contain multiple concatenated changes, and\n * returns an array of subarrays, each subarray containing one change.\n */\n\n\nfunction splitContainers(buffer) {\n  let decoder = new Decoder(buffer),\n      chunks = [],\n      startOffset = 0;\n\n  while (!decoder.done) {\n    decodeContainerHeader(decoder, false);\n    chunks.push(buffer.subarray(startOffset, decoder.offset));\n    startOffset = decoder.offset;\n  }\n\n  return chunks;\n}\n/**\n * Decodes a list of changes from the binary format into JS objects.\n * `binaryChanges` is an array of `Uint8Array` objects.\n */\n\n\nfunction decodeChanges(binaryChanges) {\n  let decoded = [];\n\n  for (let binaryChange of binaryChanges) {\n    for (let chunk of splitContainers(binaryChange)) {\n      if (chunk[8] === CHUNK_TYPE_DOCUMENT) {\n        decoded = decoded.concat(decodeDocument(chunk));\n      } else if (chunk[8] === CHUNK_TYPE_CHANGE || chunk[8] === CHUNK_TYPE_DEFLATE) {\n        decoded.push(decodeChange(chunk));\n      } else {// ignoring chunk of unknown type\n      }\n    }\n  }\n\n  return decoded;\n}\n\nfunction sortOpIds(a, b) {\n  if (a === b) return 0;\n  if (a === '_root') return -1;\n  if (b === '_root') return +1;\n  const a_ = parseOpId(a),\n        b_ = parseOpId(b);\n  if (a_.counter < b_.counter) return -1;\n  if (a_.counter > b_.counter) return +1;\n  if (a_.actorId < b_.actorId) return -1;\n  if (a_.actorId > b_.actorId) return +1;\n  return 0;\n}\n/**\n * Takes a set of operations `ops` loaded from an encoded document, and\n * reconstructs the changes that they originally came from.\n * Does not return anything, only mutates `changes`.\n */\n\n\nfunction groupChangeOps(changes, ops) {\n  let changesByActor = {}; // map from actorId to array of changes by that actor\n\n  for (let change of changes) {\n    change.ops = [];\n    if (!changesByActor[change.actor]) changesByActor[change.actor] = [];\n\n    if (change.seq !== changesByActor[change.actor].length + 1) {\n      throw new RangeError(`Expected seq = ${changesByActor[change.actor].length + 1}, got ${change.seq}`);\n    }\n\n    if (change.seq > 1 && changesByActor[change.actor][change.seq - 2].maxOp > change.maxOp) {\n      throw new RangeError('maxOp must increase monotonically per actor');\n    }\n\n    changesByActor[change.actor].push(change);\n  }\n\n  let opsById = {};\n\n  for (let op of ops) {\n    if (op.action === 'del') throw new RangeError('document should not contain del operations');\n    op.pred = opsById[op.id] ? opsById[op.id].pred : [];\n    opsById[op.id] = op;\n\n    for (let succ of op.succ) {\n      if (!opsById[succ]) {\n        if (op.elemId) {\n          const elemId = op.insert ? op.id : op.elemId;\n          opsById[succ] = {\n            id: succ,\n            action: 'del',\n            obj: op.obj,\n            elemId,\n            pred: []\n          };\n        } else {\n          opsById[succ] = {\n            id: succ,\n            action: 'del',\n            obj: op.obj,\n            key: op.key,\n            pred: []\n          };\n        }\n      }\n\n      opsById[succ].pred.push(op.id);\n    }\n\n    delete op.succ;\n  }\n\n  for (let op of Object.values(opsById)) {\n    if (op.action === 'del') ops.push(op);\n  }\n\n  for (let op of ops) {\n    const {\n      counter,\n      actorId\n    } = parseOpId(op.id);\n    const actorChanges = changesByActor[actorId]; // Binary search to find the change that should contain this operation\n\n    let left = 0,\n        right = actorChanges.length;\n\n    while (left < right) {\n      const index = Math.floor((left + right) / 2);\n\n      if (actorChanges[index].maxOp < counter) {\n        left = index + 1;\n      } else {\n        right = index;\n      }\n    }\n\n    if (left >= actorChanges.length) {\n      throw new RangeError(`Operation ID ${op.id} outside of allowed range`);\n    }\n\n    actorChanges[left].ops.push(op);\n  }\n\n  for (let change of changes) {\n    change.ops.sort((op1, op2) => sortOpIds(op1.id, op2.id));\n    change.startOp = change.maxOp - change.ops.length + 1;\n    delete change.maxOp;\n\n    for (let i = 0; i < change.ops.length; i++) {\n      const op = change.ops[i],\n            expectedId = `${change.startOp + i}@${change.actor}`;\n\n      if (op.id !== expectedId) {\n        throw new RangeError(`Expected opId ${expectedId}, got ${op.id}`);\n      }\n\n      delete op.id;\n    }\n  }\n}\n\nfunction decodeDocumentChanges(changes, expectedHeads) {\n  let heads = {}; // change hashes that are not a dependency of any other change\n\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i];\n    change.deps = [];\n\n    for (let index of change.depsNum.map(d => d.depsIndex)) {\n      if (!changes[index] || !changes[index].hash) {\n        throw new RangeError(`No hash for index ${index} while processing index ${i}`);\n      }\n\n      const hash = changes[index].hash;\n      change.deps.push(hash);\n      if (heads[hash]) delete heads[hash];\n    }\n\n    change.deps.sort();\n    delete change.depsNum;\n\n    if (change.extraLen_datatype !== VALUE_TYPE.BYTES) {\n      throw new RangeError(`Bad datatype for extra bytes: ${VALUE_TYPE.BYTES}`);\n    }\n\n    change.extraBytes = change.extraLen;\n    delete change.extraLen_datatype; // Encoding and decoding again to compute the hash of the change\n\n    changes[i] = decodeChange(encodeChange(change));\n    heads[changes[i].hash] = true;\n  }\n\n  const actualHeads = Object.keys(heads).sort();\n  let headsEqual = actualHeads.length === expectedHeads.length,\n      i = 0;\n\n  while (headsEqual && i < actualHeads.length) {\n    headsEqual = actualHeads[i] === expectedHeads[i];\n    i++;\n  }\n\n  if (!headsEqual) {\n    throw new RangeError(`Mismatched heads hashes: expected ${expectedHeads.join(', ')}, got ${actualHeads.join(', ')}`);\n  }\n}\n\nfunction encodeDocumentHeader(doc) {\n  const {\n    changesColumns,\n    opsColumns,\n    actorIds,\n    heads,\n    headsIndexes,\n    extraBytes\n  } = doc;\n\n  for (let column of changesColumns) deflateColumn(column);\n\n  for (let column of opsColumns) deflateColumn(column);\n\n  return encodeContainer(CHUNK_TYPE_DOCUMENT, encoder => {\n    encoder.appendUint53(actorIds.length);\n\n    for (let actor of actorIds) {\n      encoder.appendHexString(actor);\n    }\n\n    encoder.appendUint53(heads.length);\n\n    for (let head of heads.sort()) {\n      encoder.appendRawBytes(hexStringToBytes(head));\n    }\n\n    encodeColumnInfo(encoder, changesColumns);\n    encodeColumnInfo(encoder, opsColumns);\n\n    for (let column of changesColumns) encoder.appendRawBytes(column.encoder.buffer);\n\n    for (let column of opsColumns) encoder.appendRawBytes(column.encoder.buffer);\n\n    for (let index of headsIndexes) encoder.appendUint53(index);\n\n    if (extraBytes) encoder.appendRawBytes(extraBytes);\n  }).bytes;\n}\n\nfunction decodeDocumentHeader(buffer) {\n  const documentDecoder = new Decoder(buffer);\n  const header = decodeContainerHeader(documentDecoder, true);\n  const decoder = new Decoder(header.chunkData);\n  if (!documentDecoder.done) throw new RangeError('Encoded document has trailing data');\n  if (header.chunkType !== CHUNK_TYPE_DOCUMENT) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);\n  const actorIds = [],\n        numActors = decoder.readUint53();\n\n  for (let i = 0; i < numActors; i++) {\n    actorIds.push(decoder.readHexString());\n  }\n\n  const heads = [],\n        headsIndexes = [],\n        numHeads = decoder.readUint53();\n\n  for (let i = 0; i < numHeads; i++) {\n    heads.push(bytesToHexString(decoder.readRawBytes(32)));\n  }\n\n  const changesColumns = decodeColumnInfo(decoder);\n  const opsColumns = decodeColumnInfo(decoder);\n\n  for (let i = 0; i < changesColumns.length; i++) {\n    changesColumns[i].buffer = decoder.readRawBytes(changesColumns[i].bufferLen);\n    inflateColumn(changesColumns[i]);\n  }\n\n  for (let i = 0; i < opsColumns.length; i++) {\n    opsColumns[i].buffer = decoder.readRawBytes(opsColumns[i].bufferLen);\n    inflateColumn(opsColumns[i]);\n  }\n\n  if (!decoder.done) {\n    for (let i = 0; i < numHeads; i++) headsIndexes.push(decoder.readUint53());\n  }\n\n  const extraBytes = decoder.readRawBytes(decoder.buf.byteLength - decoder.offset);\n  return {\n    changesColumns,\n    opsColumns,\n    actorIds,\n    heads,\n    headsIndexes,\n    extraBytes\n  };\n}\n\nfunction decodeDocument(buffer) {\n  const {\n    changesColumns,\n    opsColumns,\n    actorIds,\n    heads\n  } = decodeDocumentHeader(buffer);\n  const changes = decodeColumns(changesColumns, actorIds, DOCUMENT_COLUMNS);\n  const ops = decodeOps(decodeColumns(opsColumns, actorIds, DOC_OPS_COLUMNS), true);\n  groupChangeOps(changes, ops);\n  decodeDocumentChanges(changes, heads);\n  return changes;\n}\n/**\n * DEFLATE-compresses the given column if it is large enough to make the compression worthwhile.\n */\n\n\nfunction deflateColumn(column) {\n  if (column.encoder.buffer.byteLength >= DEFLATE_MIN_SIZE) {\n    column.encoder = {\n      buffer: pako.deflateRaw(column.encoder.buffer)\n    };\n    column.columnId |= COLUMN_TYPE_DEFLATE;\n  }\n}\n/**\n * Decompresses the given column if it is DEFLATE-compressed.\n */\n\n\nfunction inflateColumn(column) {\n  if ((column.columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n    column.buffer = pako.inflateRaw(column.buffer);\n    column.columnId ^= COLUMN_TYPE_DEFLATE;\n  }\n}\n\nmodule.exports = {\n  COLUMN_TYPE,\n  VALUE_TYPE,\n  ACTIONS,\n  OBJECT_TYPE,\n  DOC_OPS_COLUMNS,\n  CHANGE_COLUMNS,\n  DOCUMENT_COLUMNS,\n  encoderByColumnId,\n  decoderByColumnId,\n  makeDecoders,\n  decodeValue,\n  splitContainers,\n  encodeChange,\n  decodeChangeColumns,\n  decodeChange,\n  decodeChangeMeta,\n  decodeChanges,\n  encodeDocumentHeader,\n  decodeDocumentHeader,\n  decodeDocument\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/backend/columnar.js"],"names":["pako","require","copyObject","parseOpId","equalBytes","utf8ToString","hexStringToBytes","bytesToHexString","Encoder","Decoder","RLEEncoder","RLEDecoder","DeltaEncoder","DeltaDecoder","BooleanEncoder","BooleanDecoder","Hash","MAGIC_BYTES","Uint8Array","CHUNK_TYPE_DOCUMENT","CHUNK_TYPE_CHANGE","CHUNK_TYPE_DEFLATE","DEFLATE_MIN_SIZE","COLUMN_TYPE","GROUP_CARD","ACTOR_ID","INT_RLE","INT_DELTA","BOOLEAN","STRING_RLE","VALUE_LEN","VALUE_RAW","COLUMN_TYPE_DEFLATE","VALUE_TYPE","NULL","FALSE","TRUE","LEB128_UINT","LEB128_INT","IEEE754","UTF8","BYTES","COUNTER","TIMESTAMP","MIN_UNKNOWN","MAX_UNKNOWN","ACTIONS","OBJECT_TYPE","makeMap","makeList","makeText","makeTable","COMMON_COLUMNS","columnName","columnId","CHANGE_COLUMNS","concat","DOC_OPS_COLUMNS","DOCUMENT_COLUMNS","actorIdToActorNum","opId","actorIds","actorId","counter","actorNum","indexOf","RangeError","compareParsedOpIds","id1","id2","parseAllOpIds","changes","single","actors","newChanges","change","actor","ops","expandMultiOps","startOp","map","op","obj","elemId","child","pred","push","Object","keys","sort","filter","i","length","id","encodeObjectId","columns","objActor","appendValue","objCtr","JSON","stringify","encodeOperationKey","key","keyActor","keyCtr","keyStr","insert","encodeOperationAction","actionCode","action","getNumberTypeAndValue","datatype","value","buf64","ArrayBuffer","view64","DataView","setFloat64","Number","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","encodeValue","valLen","numBytes","valRaw","appendRawString","isView","appendRawBytes","buffer","typeTag","appendUint53","appendInt53","decodeValue","sizeTag","bytes","readUint53","readInt53","view","byteOffset","byteLength","getFloat64","decodeValueColumns","colIndex","result","decoder","readValue","rawValue","readRawBytes","encodeOps","forDocument","chldActor","chldCtr","idActor","idCtr","succNum","succActor","succCtr","predNum","predCtr","predActor","succ","columnList","encoder","a","b","validDatatype","undefined","opNum","expandedOps","values","lastElemId","multiOp","startElemId","startPred","decodeOps","newOps","newOp","valLen_datatype","checkSortedOpIds","opIds","last","encoderByColumnId","decoderByColumnId","makeDecoders","columnSpec","emptyBuf","decoders","columnIndex","specIndex","decodeColumns","parsedRows","some","col","done","row","groupId","groupCols","count","colOffset","decodeColumnInfo","COLUMN_ID_MASK","lastColumnId","numColumns","bufferLen","encodeColumnInfo","nonEmptyColumns","column","decodeChangeHeader","numDeps","deps","readHexString","seq","time","message","readPrefixedString","numActorIds","encodeContainer","chunkType","encodeContentsCallback","CHECKSUM_SIZE","HEADER_SPACE","body","bodyBuf","header","appendByte","headerBuf","sha256","update","subarray","hash","digest","checksum","set","decodeContainerHeader","computeHash","expectedHash","hashStartOffset","offset","readByte","chunkLength","chunkData","buf","binaryHash","encodeChange","changeObj","Array","isArray","TypeError","slice","appendHexString","appendPrefixedString","extraBytes","hexHash","deflateChange","decodeChangeColumns","inflateChange","chunkDecoder","restLen","decodeChange","decodeChangeMeta","meta","compressed","deflateRaw","decompressed","inflateRaw","splitContainers","chunks","startOffset","decodeChanges","binaryChanges","decoded","binaryChange","chunk","decodeDocument","sortOpIds","a_","b_","groupChangeOps","changesByActor","maxOp","opsById","actorChanges","left","right","index","Math","floor","op1","op2","expectedId","decodeDocumentChanges","expectedHeads","heads","depsNum","d","depsIndex","extraLen_datatype","extraLen","actualHeads","headsEqual","join","encodeDocumentHeader","doc","changesColumns","opsColumns","headsIndexes","deflateColumn","head","decodeDocumentHeader","documentDecoder","numActors","numHeads","inflateColumn","module","exports"],"mappings":"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","sourcesContent":["const pako = require('pako')\nconst { copyObject, parseOpId, equalBytes } = require('../src/common')\nconst {\n  utf8ToString, hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n} = require('./encoding')\n\n// Maybe we should be using the platform's built-in hash implementation?\n// Node has the crypto module: https://nodejs.org/api/crypto.html and browsers have\n// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n// However, the WebCrypto API is asynchronous (returns promises), which would\n// force all our APIs to become asynchronous as well, which would be annoying.\n//\n// I think on balance, it's safe enough to use a random library off npm:\n// - We only need one hash function (not a full suite of crypto algorithms);\n// - SHA256 is quite simple and has fairly few opportunities for subtle bugs\n//   (compared to asymmetric cryptography anyway);\n// - It does not need a secure source of random bits and does not need to be\n//   constant-time;\n// - I have reviewed the source code and it seems pretty reasonable.\nconst { Hash } = require('fast-sha256')\n\n// These bytes don't mean anything, they were generated randomly\nconst MAGIC_BYTES = new Uint8Array([0x85, 0x6f, 0x4a, 0x83])\n\nconst CHUNK_TYPE_DOCUMENT = 0\nconst CHUNK_TYPE_CHANGE = 1\nconst CHUNK_TYPE_DEFLATE = 2 // like CHUNK_TYPE_CHANGE but with DEFLATE compression\n\n// Minimum number of bytes in a value before we enable DEFLATE compression (there is no point\n// compressing very short values since compression may actually make them bigger)\nconst DEFLATE_MIN_SIZE = 256\n\n// The least-significant 3 bits of a columnId indicate its datatype\nconst COLUMN_TYPE = {\n  GROUP_CARD: 0, ACTOR_ID: 1, INT_RLE: 2, INT_DELTA: 3, BOOLEAN: 4,\n  STRING_RLE: 5, VALUE_LEN: 6, VALUE_RAW: 7\n}\n\n// The 4th-least-significant bit of a columnId is set if the column is DEFLATE-compressed\nconst COLUMN_TYPE_DEFLATE = 8\n\n// In the values in a column of type VALUE_LEN, the bottom four bits indicate the type of the value,\n// one of the following types in VALUE_TYPE. The higher bits indicate the length of the value in the\n// associated VALUE_RAW column (in bytes).\nconst VALUE_TYPE = {\n  NULL: 0, FALSE: 1, TRUE: 2, LEB128_UINT: 3, LEB128_INT: 4, IEEE754: 5,\n  UTF8: 6, BYTES: 7, COUNTER: 8, TIMESTAMP: 9, MIN_UNKNOWN: 10, MAX_UNKNOWN: 15\n}\n\n// make* actions must be at even-numbered indexes in this list\nconst ACTIONS = ['makeMap', 'set', 'makeList', 'del', 'makeText', 'inc', 'makeTable', 'link']\n\nconst OBJECT_TYPE = {makeMap: 'map', makeList: 'list', makeText: 'text', makeTable: 'table'}\n\nconst COMMON_COLUMNS = [\n  {columnName: 'objActor',  columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'objCtr',    columnId: 0 << 4 | COLUMN_TYPE.INT_RLE},\n  {columnName: 'keyActor',  columnId: 1 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'keyCtr',    columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'keyStr',    columnId: 1 << 4 | COLUMN_TYPE.STRING_RLE},\n  {columnName: 'idActor',   columnId: 2 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'idCtr',     columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'insert',    columnId: 3 << 4 | COLUMN_TYPE.BOOLEAN},\n  {columnName: 'action',    columnId: 4 << 4 | COLUMN_TYPE.INT_RLE},\n  {columnName: 'valLen',    columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN},\n  {columnName: 'valRaw',    columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW},\n  {columnName: 'chldActor', columnId: 6 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'chldCtr',   columnId: 6 << 4 | COLUMN_TYPE.INT_DELTA}\n]\n\nconst CHANGE_COLUMNS = COMMON_COLUMNS.concat([\n  {columnName: 'predNum',   columnId: 7 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'predActor', columnId: 7 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'predCtr',   columnId: 7 << 4 | COLUMN_TYPE.INT_DELTA}\n])\n\nconst DOC_OPS_COLUMNS = COMMON_COLUMNS.concat([\n  {columnName: 'succNum',   columnId: 8 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'succActor', columnId: 8 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'succCtr',   columnId: 8 << 4 | COLUMN_TYPE.INT_DELTA}\n])\n\nconst DOCUMENT_COLUMNS = [\n  {columnName: 'actor',     columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'seq',       columnId: 0 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'maxOp',     columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'time',      columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'message',   columnId: 3 << 4 | COLUMN_TYPE.STRING_RLE},\n  {columnName: 'depsNum',   columnId: 4 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'depsIndex', columnId: 4 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'extraLen',  columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN},\n  {columnName: 'extraRaw',  columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW}\n]\n\n/**\n * Maps an opId of the form {counter: 12345, actorId: 'someActorId'} to the form\n * {counter: 12345, actorNum: 123, actorId: 'someActorId'}, where the actorNum\n * is the index into the `actorIds` array.\n */\nfunction actorIdToActorNum(opId, actorIds) {\n  if (!opId || !opId.actorId) return opId\n  const counter = opId.counter\n  const actorNum = actorIds.indexOf(opId.actorId)\n  if (actorNum < 0) throw new RangeError('missing actorId') // should not happen\n  return {counter, actorNum, actorId: opId.actorId}\n}\n\n/**\n * Comparison function to pass to Array.sort(), which compares two opIds in the\n * form produced by `actorIdToActorNum` so that they are sorted in increasing\n * Lamport timestamp order (sorted first by counter, then by actorId).\n */\nfunction compareParsedOpIds(id1, id2) {\n  if (id1.counter < id2.counter) return -1\n  if (id1.counter > id2.counter) return +1\n  if (id1.actorId < id2.actorId) return -1\n  if (id1.actorId > id2.actorId) return +1\n  return 0\n}\n\n/**\n * Takes `changes`, an array of changes (represented as JS objects). Returns an\n * object `{changes, actorIds}`, where `changes` is a copy of the argument in\n * which all string opIds have been replaced with `{counter, actorNum}` objects,\n * and where `actorIds` is a lexicographically sorted array of actor IDs occurring\n * in any of the operations. `actorNum` is an index into that array of actorIds.\n * If `single` is true, the actorId of the author of the change is moved to the\n * beginning of the array of actorIds, so that `actorNum` is zero when referencing\n * the author of the change itself. This special-casing is omitted if `single` is\n * false.\n */\nfunction parseAllOpIds(changes, single) {\n  const actors = {}, newChanges = []\n  for (let change of changes) {\n    change = copyObject(change)\n    actors[change.actor] = true\n    change.ops = expandMultiOps(change.ops, change.startOp, change.actor)\n    change.ops = change.ops.map(op => {\n      op = copyObject(op)\n      if (op.obj !== '_root') op.obj = parseOpId(op.obj)\n      if (op.elemId && op.elemId !== '_head') op.elemId = parseOpId(op.elemId)\n      if (op.child) op.child = parseOpId(op.child)\n      if (op.pred) op.pred = op.pred.map(parseOpId)\n      if (op.obj.actorId) actors[op.obj.actorId] = true\n      if (op.elemId && op.elemId.actorId) actors[op.elemId.actorId] = true\n      if (op.child && op.child.actorId) actors[op.child.actorId] = true\n      for (let pred of op.pred) actors[pred.actorId] = true\n      return op\n    })\n    newChanges.push(change)\n  }\n\n  let actorIds = Object.keys(actors).sort()\n  if (single) {\n    actorIds = [changes[0].actor].concat(actorIds.filter(actor => actor !== changes[0].actor))\n  }\n  for (let change of newChanges) {\n    change.actorNum = actorIds.indexOf(change.actor)\n    for (let i = 0; i < change.ops.length; i++) {\n      let op = change.ops[i]\n      op.id = {counter: change.startOp + i, actorNum: change.actorNum, actorId: change.actor}\n      op.obj = actorIdToActorNum(op.obj, actorIds)\n      op.elemId = actorIdToActorNum(op.elemId, actorIds)\n      op.child = actorIdToActorNum(op.child, actorIds)\n      op.pred = op.pred.map(pred => actorIdToActorNum(pred, actorIds))\n    }\n  }\n  return {changes: newChanges, actorIds}\n}\n\n/**\n * Encodes the `obj` property of operation `op` into the two columns\n * `objActor` and `objCtr`.\n */\nfunction encodeObjectId(op, columns) {\n  if (op.obj === '_root') {\n    columns.objActor.appendValue(null)\n    columns.objCtr.appendValue(null)\n  } else if (op.obj.actorNum >= 0 && op.obj.counter > 0) {\n    columns.objActor.appendValue(op.obj.actorNum)\n    columns.objCtr.appendValue(op.obj.counter)\n  } else {\n    throw new RangeError(`Unexpected objectId reference: ${JSON.stringify(op.obj)}`)\n  }\n}\n\n/**\n * Encodes the `key` and `elemId` properties of operation `op` into the three\n * columns `keyActor`, `keyCtr`, and `keyStr`.\n */\nfunction encodeOperationKey(op, columns) {\n  if (op.key) {\n    columns.keyActor.appendValue(null)\n    columns.keyCtr.appendValue(null)\n    columns.keyStr.appendValue(op.key)\n  } else if (op.elemId === '_head' && op.insert) {\n    columns.keyActor.appendValue(null)\n    columns.keyCtr.appendValue(0)\n    columns.keyStr.appendValue(null)\n  } else if (op.elemId && op.elemId.actorNum >= 0 && op.elemId.counter > 0) {\n    columns.keyActor.appendValue(op.elemId.actorNum)\n    columns.keyCtr.appendValue(op.elemId.counter)\n    columns.keyStr.appendValue(null)\n  } else {\n    throw new RangeError(`Unexpected operation key: ${JSON.stringify(op)}`)\n  }\n}\n\n/**\n * Encodes the `action` property of operation `op` into the `action` column.\n */\nfunction encodeOperationAction(op, columns) {\n  const actionCode = ACTIONS.indexOf(op.action)\n  if (actionCode >= 0) {\n    columns.action.appendValue(actionCode)\n  } else if (typeof op.action === 'number') {\n    columns.action.appendValue(op.action)\n  } else {\n    throw new RangeError(`Unexpected operation action: ${op.action}`)\n  }\n}\n\n/**\n * Given the datatype for a number, determine the typeTag and the value to encode\n * otherwise guess\n */\nfunction getNumberTypeAndValue(op) {\n  switch (op.datatype) {\n    case \"counter\":\n      return [ VALUE_TYPE.COUNTER, op.value ]\n    case \"timestamp\":\n      return [ VALUE_TYPE.TIMESTAMP, op.value ]\n    case \"uint\":\n      return [ VALUE_TYPE.LEB128_UINT, op.value ]\n    case \"int\":\n      return [ VALUE_TYPE.LEB128_INT, op.value ]\n    case \"float64\": {\n      const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64)\n      view64.setFloat64(0, op.value, true)\n      return [ VALUE_TYPE.IEEE754,  new Uint8Array(buf64) ]\n    }\n    default:\n      // increment operators get resolved here ...\n      if (Number.isInteger(op.value) && op.value <= Number.MAX_SAFE_INTEGER && op.value >= Number.MIN_SAFE_INTEGER) {\n        return [ VALUE_TYPE.LEB128_INT, op.value ]\n      } else {\n        const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64)\n        view64.setFloat64(0, op.value, true)\n        return [ VALUE_TYPE.IEEE754,  new Uint8Array(buf64) ]\n      }\n  }\n}\n\n/**\n * Encodes the `value` property of operation `op` into the two columns\n * `valLen` and `valRaw`.\n */\nfunction encodeValue(op, columns) {\n  if ((op.action !== 'set' && op.action !== 'inc') || op.value === null) {\n    columns.valLen.appendValue(VALUE_TYPE.NULL)\n  } else if (op.value === false) {\n    columns.valLen.appendValue(VALUE_TYPE.FALSE)\n  } else if (op.value === true) {\n    columns.valLen.appendValue(VALUE_TYPE.TRUE)\n  } else if (typeof op.value === 'string') {\n    const numBytes = columns.valRaw.appendRawString(op.value)\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.UTF8)\n  } else if (ArrayBuffer.isView(op.value)) {\n    const numBytes = columns.valRaw.appendRawBytes(new Uint8Array(op.value.buffer))\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.BYTES)\n  } else if (typeof op.value === 'number') {\n    let [typeTag, value] = getNumberTypeAndValue(op)\n    let numBytes\n    if (typeTag === VALUE_TYPE.LEB128_UINT) {\n      numBytes = columns.valRaw.appendUint53(value)\n    } else if (typeTag === VALUE_TYPE.IEEE754) {\n      numBytes = columns.valRaw.appendRawBytes(value)\n    } else {\n      numBytes = columns.valRaw.appendInt53(value)\n    }\n    columns.valLen.appendValue(numBytes << 4 | typeTag)\n  } else if (typeof op.datatype === 'number' && op.datatype >= VALUE_TYPE.MIN_UNKNOWN &&\n             op.datatype <= VALUE_TYPE.MAX_UNKNOWN && op.value instanceof Uint8Array) {\n    const numBytes = columns.valRaw.appendRawBytes(op.value)\n    columns.valLen.appendValue(numBytes << 4 | op.datatype)\n  } else if (op.datatype) {\n      throw new RangeError(`Unknown datatype ${op.datatype} for value ${op.value}`)\n  } else {\n    throw new RangeError(`Unsupported value in operation: ${op.value}`)\n  }\n}\n\n/**\n * Given `sizeTag` (an unsigned integer read from a VALUE_LEN column) and `bytes` (a Uint8Array\n * read from a VALUE_RAW column, with length `sizeTag >> 4`), this function returns an object of the\n * form `{value: value, datatype: datatypeTag}` where `value` is a JavaScript primitive datatype\n * corresponding to the value, and `datatypeTag` is a datatype annotation such as 'counter'.\n */\nfunction decodeValue(sizeTag, bytes) {\n  if (sizeTag === VALUE_TYPE.NULL) {\n    return {value: null}\n  } else if (sizeTag === VALUE_TYPE.FALSE) {\n    return {value: false}\n  } else if (sizeTag === VALUE_TYPE.TRUE) {\n    return {value: true}\n  } else if (sizeTag % 16 === VALUE_TYPE.UTF8) {\n    return {value: utf8ToString(bytes)}\n  } else {\n    if (sizeTag % 16 === VALUE_TYPE.LEB128_UINT) {\n      return {value: new Decoder(bytes).readUint53(), datatype: \"uint\"}\n    } else if (sizeTag % 16 === VALUE_TYPE.LEB128_INT) {\n      return {value: new Decoder(bytes).readInt53(), datatype: \"int\"}\n    } else if (sizeTag % 16 === VALUE_TYPE.IEEE754) {\n      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n      if (bytes.byteLength === 8) {\n        return {value: view.getFloat64(0, true), datatype: \"float64\"}\n      } else {\n        throw new RangeError(`Invalid length for floating point number: ${bytes.byteLength}`)\n      }\n    } else if (sizeTag % 16 === VALUE_TYPE.COUNTER) {\n      return {value: new Decoder(bytes).readInt53(), datatype: 'counter'}\n    } else if (sizeTag % 16 === VALUE_TYPE.TIMESTAMP) {\n      return {value: new Decoder(bytes).readInt53(), datatype: 'timestamp'}\n    } else {\n      return {value: bytes, datatype: sizeTag % 16}\n    }\n  }\n}\n\n/**\n * Reads one value from the column `columns[colIndex]` and interprets it based\n * on the column type. `actorIds` is a list of actors that appear in the change;\n * `actorIds[0]` is the actorId of the change's author. Mutates the `result`\n * object with the value, and returns the number of columns processed (this is 2\n * in the case of a pair of VALUE_LEN and VALUE_RAW columns, which are processed\n * in one go).\n */\nfunction decodeValueColumns(columns, colIndex, actorIds, result) {\n  const { columnId, columnName, decoder } = columns[colIndex]\n  if (columnId % 8 === COLUMN_TYPE.VALUE_LEN && colIndex + 1 < columns.length &&\n      columns[colIndex + 1].columnId === columnId + 1) {\n    const sizeTag = decoder.readValue()\n    const rawValue = columns[colIndex + 1].decoder.readRawBytes(sizeTag >> 4)\n    const { value, datatype } = decodeValue(sizeTag, rawValue)\n    result[columnName] = value\n    if (datatype) result[columnName + '_datatype'] = datatype\n    return 2\n  } else if (columnId % 8 === COLUMN_TYPE.ACTOR_ID) {\n    const actorNum = decoder.readValue()\n    if (actorNum === null) {\n      result[columnName] = null\n    } else {\n      if (!actorIds[actorNum]) throw new RangeError(`No actor index ${actorNum}`)\n      result[columnName] = actorIds[actorNum]\n    }\n  } else {\n    result[columnName] = decoder.readValue()\n  }\n  return 1\n}\n\n/**\n * Encodes an array of operations in a set of columns. The operations need to\n * be parsed with `parseAllOpIds()` beforehand. If `forDocument` is true, we use\n * the column structure of a whole document, otherwise we use the column\n * structure for an individual change. Returns an array of\n * `{columnId, columnName, encoder}` objects.\n */\nfunction encodeOps(ops, forDocument) {\n  const columns = {\n    objActor  : new RLEEncoder('uint'),\n    objCtr    : new RLEEncoder('uint'),\n    keyActor  : new RLEEncoder('uint'),\n    keyCtr    : new DeltaEncoder(),\n    keyStr    : new RLEEncoder('utf8'),\n    insert    : new BooleanEncoder(),\n    action    : new RLEEncoder('uint'),\n    valLen    : new RLEEncoder('uint'),\n    valRaw    : new Encoder(),\n    chldActor : new RLEEncoder('uint'),\n    chldCtr   : new DeltaEncoder()\n  }\n\n  if (forDocument) {\n    columns.idActor   = new RLEEncoder('uint')\n    columns.idCtr     = new DeltaEncoder()\n    columns.succNum   = new RLEEncoder('uint')\n    columns.succActor = new RLEEncoder('uint')\n    columns.succCtr   = new DeltaEncoder()\n  } else {\n    columns.predNum   = new RLEEncoder('uint')\n    columns.predCtr   = new DeltaEncoder()\n    columns.predActor = new RLEEncoder('uint')\n  }\n\n  for (let op of ops) {\n    encodeObjectId(op, columns)\n    encodeOperationKey(op, columns)\n    columns.insert.appendValue(!!op.insert)\n    encodeOperationAction(op, columns)\n    encodeValue(op, columns)\n\n    if (op.child && op.child.counter) {\n      columns.chldActor.appendValue(op.child.actorNum)\n      columns.chldCtr.appendValue(op.child.counter)\n    } else {\n      columns.chldActor.appendValue(null)\n      columns.chldCtr.appendValue(null)\n    }\n\n    if (forDocument) {\n      columns.idActor.appendValue(op.id.actorNum)\n      columns.idCtr.appendValue(op.id.counter)\n      columns.succNum.appendValue(op.succ.length)\n      op.succ.sort(compareParsedOpIds)\n      for (let i = 0; i < op.succ.length; i++) {\n        columns.succActor.appendValue(op.succ[i].actorNum)\n        columns.succCtr.appendValue(op.succ[i].counter)\n      }\n    } else {\n      columns.predNum.appendValue(op.pred.length)\n      op.pred.sort(compareParsedOpIds)\n      for (let i = 0; i < op.pred.length; i++) {\n        columns.predActor.appendValue(op.pred[i].actorNum)\n        columns.predCtr.appendValue(op.pred[i].counter)\n      }\n    }\n  }\n\n  let columnList = []\n  for (let {columnName, columnId} of forDocument ? DOC_OPS_COLUMNS : CHANGE_COLUMNS) {\n    if (columns[columnName]) columnList.push({columnId, columnName, encoder: columns[columnName]})\n  }\n  return columnList.sort((a, b) => a.columnId - b.columnId)\n}\n\nfunction validDatatype(value, datatype) {\n  if (datatype === undefined) {\n    return (typeof value === 'string' || typeof value === 'boolean' || value === null)\n  } else {\n    return typeof value === 'number'\n  }\n}\n\nfunction expandMultiOps(ops, startOp, actor) {\n  let opNum = startOp\n  let expandedOps = []\n  for (const op of ops) {\n    if (op.action === 'set' && op.values && op.insert) {\n      if (op.pred.length !== 0) throw new RangeError('multi-insert pred must be empty')\n      let lastElemId = op.elemId\n      const datatype = op.datatype\n      for (const value of op.values) {\n        if (!validDatatype(value, datatype)) throw new RangeError(`Decode failed: bad value/datatype association (${value},${datatype})`)\n        expandedOps.push({action: 'set', obj: op.obj, elemId: lastElemId, datatype, value, pred: [], insert: true})\n        lastElemId = `${opNum}@${actor}`\n        opNum += 1\n      }\n    } else if (op.action === 'del' && op.multiOp > 1) {\n      if (op.pred.length !== 1) throw new RangeError('multiOp deletion must have exactly one pred')\n      const startElemId = parseOpId(op.elemId), startPred = parseOpId(op.pred[0])\n      for (let i = 0; i < op.multiOp; i++) {\n        const elemId = `${startElemId.counter + i}@${startElemId.actorId}`\n        const pred = [`${startPred.counter + i}@${startPred.actorId}`]\n        expandedOps.push({action: 'del', obj: op.obj, elemId, pred})\n        opNum += 1\n      }\n    } else {\n      expandedOps.push(op)\n      opNum += 1\n    }\n  }\n  return expandedOps\n}\n\n/**\n * Takes a change as decoded by `decodeColumns`, and changes it into the form\n * expected by the rest of the backend. If `forDocument` is true, we use the op\n * structure of a whole document, otherwise we use the op structure for an\n * individual change.\n */\nfunction decodeOps(ops, forDocument) {\n  const newOps = []\n  for (let op of ops) {\n    const obj = (op.objCtr === null) ? '_root' : `${op.objCtr}@${op.objActor}`\n    const elemId = op.keyStr ? undefined : (op.keyCtr === 0 ? '_head' : `${op.keyCtr}@${op.keyActor}`)\n    const action = ACTIONS[op.action] || op.action\n    const newOp = elemId ? {obj, elemId, action} : {obj, key: op.keyStr, action}\n    newOp.insert = !!op.insert\n    if (ACTIONS[op.action] === 'set' || ACTIONS[op.action] === 'inc') {\n      newOp.value = op.valLen\n      if (op.valLen_datatype) newOp.datatype = op.valLen_datatype\n    }\n    if (!!op.chldCtr !== !!op.chldActor) {\n      throw new RangeError(`Mismatched child columns: ${op.chldCtr} and ${op.chldActor}`)\n    }\n    if (op.chldCtr !== null) newOp.child = `${op.chldCtr}@${op.chldActor}`\n    if (forDocument) {\n      newOp.id = `${op.idCtr}@${op.idActor}`\n      newOp.succ = op.succNum.map(succ => `${succ.succCtr}@${succ.succActor}`)\n      checkSortedOpIds(op.succNum.map(succ => ({counter: succ.succCtr, actorId: succ.succActor})))\n    } else {\n      newOp.pred = op.predNum.map(pred => `${pred.predCtr}@${pred.predActor}`)\n      checkSortedOpIds(op.predNum.map(pred => ({counter: pred.predCtr, actorId: pred.predActor})))\n    }\n    newOps.push(newOp)\n  }\n  return newOps\n}\n\n/**\n * Throws an exception if the opIds in the given array are not in sorted order.\n */\nfunction checkSortedOpIds(opIds) {\n  let last = null\n  for (let opId of opIds) {\n    if (last && compareParsedOpIds(last, opId) !== -1) {\n      throw new RangeError('operation IDs are not in ascending order')\n    }\n    last = opId\n  }\n}\n\nfunction encoderByColumnId(columnId) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEEncoder('utf8')\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Encoder()\n  } else {\n    return new RLEEncoder('uint')\n  }\n}\n\nfunction decoderByColumnId(columnId, buffer) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEDecoder('utf8', buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Decoder(buffer)\n  } else {\n    return new RLEDecoder('uint', buffer)\n  }\n}\n\nfunction makeDecoders(columns, columnSpec) {\n  const emptyBuf = new Uint8Array(0)\n  let decoders = [], columnIndex = 0, specIndex = 0\n\n  while (columnIndex < columns.length || specIndex < columnSpec.length) {\n    if (columnIndex === columns.length ||\n        (specIndex < columnSpec.length && columnSpec[specIndex].columnId < columns[columnIndex].columnId)) {\n      const {columnId, columnName} = columnSpec[specIndex]\n      decoders.push({columnId, columnName, decoder: decoderByColumnId(columnId, emptyBuf)})\n      specIndex++\n    } else if (specIndex === columnSpec.length || columns[columnIndex].columnId < columnSpec[specIndex].columnId) {\n      const {columnId, buffer} = columns[columnIndex]\n      decoders.push({columnId, decoder: decoderByColumnId(columnId, buffer)})\n      columnIndex++\n    } else { // columns[columnIndex].columnId === columnSpec[specIndex].columnId\n      const {columnId, buffer} = columns[columnIndex], {columnName} = columnSpec[specIndex]\n      decoders.push({columnId, columnName, decoder: decoderByColumnId(columnId, buffer)})\n      columnIndex++\n      specIndex++\n    }\n  }\n  return decoders\n}\n\nfunction decodeColumns(columns, actorIds, columnSpec) {\n  columns = makeDecoders(columns, columnSpec)\n  let parsedRows = []\n  while (columns.some(col => !col.decoder.done)) {\n    let row = {}, col = 0\n    while (col < columns.length) {\n      const columnId = columns[col].columnId\n      let groupId = columnId >> 4, groupCols = 1\n      while (col + groupCols < columns.length && columns[col + groupCols].columnId >> 4 === groupId) {\n        groupCols++\n      }\n\n      if (columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        const values = [], count = columns[col].decoder.readValue()\n        for (let i = 0; i < count; i++) {\n          let value = {}\n          for (let colOffset = 1; colOffset < groupCols; colOffset++) {\n            decodeValueColumns(columns, col + colOffset, actorIds, value)\n          }\n          values.push(value)\n        }\n        row[columns[col].columnName] = values\n        col += groupCols\n      } else {\n        col += decodeValueColumns(columns, col, actorIds, row)\n      }\n    }\n    parsedRows.push(row)\n  }\n  return parsedRows\n}\n\nfunction decodeColumnInfo(decoder) {\n  // A number that is all 1 bits except for the bit that indicates whether a column is\n  // deflate-compressed. We ignore this bit when checking whether columns are sorted by ID.\n  const COLUMN_ID_MASK = (-1 ^ COLUMN_TYPE_DEFLATE) >>> 0\n\n  let lastColumnId = -1, columns = [], numColumns = decoder.readUint53()\n  for (let i = 0; i < numColumns; i++) {\n    const columnId = decoder.readUint53(), bufferLen = decoder.readUint53()\n    if ((columnId & COLUMN_ID_MASK) <= (lastColumnId & COLUMN_ID_MASK)) {\n      throw new RangeError('Columns must be in ascending order')\n    }\n    lastColumnId = columnId\n    columns.push({columnId, bufferLen})\n  }\n  return columns\n}\n\nfunction encodeColumnInfo(encoder, columns) {\n  const nonEmptyColumns = columns.filter(column => column.encoder.buffer.byteLength > 0)\n  encoder.appendUint53(nonEmptyColumns.length)\n  for (let column of nonEmptyColumns) {\n    encoder.appendUint53(column.columnId)\n    encoder.appendUint53(column.encoder.buffer.byteLength)\n  }\n}\n\nfunction decodeChangeHeader(decoder) {\n  const numDeps = decoder.readUint53(), deps = []\n  for (let i = 0; i < numDeps; i++) {\n    deps.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n  let change = {\n    actor:   decoder.readHexString(),\n    seq:     decoder.readUint53(),\n    startOp: decoder.readUint53(),\n    time:    decoder.readInt53(),\n    message: decoder.readPrefixedString(),\n    deps\n  }\n  const actorIds = [change.actor], numActorIds = decoder.readUint53()\n  for (let i = 0; i < numActorIds; i++) actorIds.push(decoder.readHexString())\n  change.actorIds = actorIds\n  return change\n}\n\n/**\n * Assembles a chunk of encoded data containing a checksum, headers, and a\n * series of encoded columns. Calls `encodeHeaderCallback` with an encoder that\n * should be used to add the headers. The columns should be given as `columns`.\n */\nfunction encodeContainer(chunkType, encodeContentsCallback) {\n  const CHECKSUM_SIZE = 4 // checksum is first 4 bytes of SHA-256 hash of the rest of the data\n  const HEADER_SPACE = MAGIC_BYTES.byteLength + CHECKSUM_SIZE + 1 + 5 // 1 byte type + 5 bytes length\n  const body = new Encoder()\n  // Make space for the header at the beginning of the body buffer. We will\n  // copy the header in here later. This is cheaper than copying the body since\n  // the body is likely to be much larger than the header.\n  body.appendRawBytes(new Uint8Array(HEADER_SPACE))\n  encodeContentsCallback(body)\n\n  const bodyBuf = body.buffer\n  const header = new Encoder()\n  header.appendByte(chunkType)\n  header.appendUint53(bodyBuf.byteLength - HEADER_SPACE)\n\n  // Compute the hash over chunkType, length, and body\n  const headerBuf = header.buffer\n  const sha256 = new Hash()\n  sha256.update(headerBuf)\n  sha256.update(bodyBuf.subarray(HEADER_SPACE))\n  const hash = sha256.digest(), checksum = hash.subarray(0, CHECKSUM_SIZE)\n\n  // Copy header into the body buffer so that they are contiguous\n  bodyBuf.set(MAGIC_BYTES, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)\n  bodyBuf.set(checksum,    HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE)\n  bodyBuf.set(headerBuf,   HEADER_SPACE - headerBuf.byteLength)\n  return {hash, bytes: bodyBuf.subarray(HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)}\n}\n\nfunction decodeContainerHeader(decoder, computeHash) {\n  if (!equalBytes(decoder.readRawBytes(MAGIC_BYTES.byteLength), MAGIC_BYTES)) {\n    throw new RangeError('Data does not begin with magic bytes 85 6f 4a 83')\n  }\n  const expectedHash = decoder.readRawBytes(4)\n  const hashStartOffset = decoder.offset\n  const chunkType = decoder.readByte()\n  const chunkLength = decoder.readUint53()\n  const header = {chunkType, chunkLength, chunkData: decoder.readRawBytes(chunkLength)}\n\n  if (computeHash) {\n    const sha256 = new Hash()\n    sha256.update(decoder.buf.subarray(hashStartOffset, decoder.offset))\n    const binaryHash = sha256.digest()\n    if (!equalBytes(binaryHash.subarray(0, 4), expectedHash)) {\n      throw new RangeError('checksum does not match data')\n    }\n    header.hash = bytesToHexString(binaryHash)\n  }\n  return header\n}\n\nfunction encodeChange(changeObj) {\n  const { changes, actorIds } = parseAllOpIds([changeObj], true)\n  const change = changes[0]\n\n  const { hash, bytes } = encodeContainer(CHUNK_TYPE_CHANGE, encoder => {\n    if (!Array.isArray(change.deps)) throw new TypeError('deps is not an array')\n    encoder.appendUint53(change.deps.length)\n    for (let hash of change.deps.slice().sort()) {\n      encoder.appendRawBytes(hexStringToBytes(hash))\n    }\n    encoder.appendHexString(change.actor)\n    encoder.appendUint53(change.seq)\n    encoder.appendUint53(change.startOp)\n    encoder.appendInt53(change.time)\n    encoder.appendPrefixedString(change.message || '')\n    encoder.appendUint53(actorIds.length - 1)\n    for (let actor of actorIds.slice(1)) encoder.appendHexString(actor)\n\n    const columns = encodeOps(change.ops, false)\n    encodeColumnInfo(encoder, columns)\n    for (let column of columns) encoder.appendRawBytes(column.encoder.buffer)\n    if (change.extraBytes) encoder.appendRawBytes(change.extraBytes)\n  })\n\n  const hexHash = bytesToHexString(hash)\n  if (changeObj.hash && changeObj.hash !== hexHash) {\n    throw new RangeError(`Change hash does not match encoding: ${changeObj.hash} != ${hexHash}`)\n  }\n  return (bytes.byteLength >= DEFLATE_MIN_SIZE) ? deflateChange(bytes) : bytes\n}\n\nfunction decodeChangeColumns(buffer) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer)\n  const decoder = new Decoder(buffer)\n  const header = decodeContainerHeader(decoder, true)\n  const chunkDecoder = new Decoder(header.chunkData)\n  if (!decoder.done) throw new RangeError('Encoded change has trailing data')\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const change = decodeChangeHeader(chunkDecoder)\n  const columns = decodeColumnInfo(chunkDecoder)\n  for (let i = 0; i < columns.length; i++) {\n    if ((columns[i].columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n      throw new RangeError('change must not contain deflated columns')\n    }\n    columns[i].buffer = chunkDecoder.readRawBytes(columns[i].bufferLen)\n  }\n  if (!chunkDecoder.done) {\n    const restLen = chunkDecoder.buf.byteLength - chunkDecoder.offset\n    change.extraBytes = chunkDecoder.readRawBytes(restLen)\n  }\n\n  change.columns = columns\n  change.hash = header.hash\n  return change\n}\n\n/**\n * Decodes one change in binary format into its JS object representation.\n */\nfunction decodeChange(buffer) {\n  const change = decodeChangeColumns(buffer)\n  change.ops = decodeOps(decodeColumns(change.columns, change.actorIds, CHANGE_COLUMNS), false)\n  delete change.actorIds\n  delete change.columns\n  return change\n}\n\n/**\n * Decodes the header fields of a change in binary format, but does not decode\n * the operations. Saves work when we only need to inspect the headers. Only\n * computes the hash of the change if `computeHash` is true.\n */\nfunction decodeChangeMeta(buffer, computeHash) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer)\n  const header = decodeContainerHeader(new Decoder(buffer), computeHash)\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) {\n    throw new RangeError('Buffer chunk type is not a change')\n  }\n  const meta = decodeChangeHeader(new Decoder(header.chunkData))\n  meta.change = buffer\n  if (computeHash) meta.hash = header.hash\n  return meta\n}\n\n/**\n * Compresses a binary change using DEFLATE.\n */\nfunction deflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false)\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n  const compressed = pako.deflateRaw(header.chunkData)\n  const encoder = new Encoder()\n  encoder.appendRawBytes(buffer.subarray(0, 8)) // copy MAGIC_BYTES and checksum\n  encoder.appendByte(CHUNK_TYPE_DEFLATE)\n  encoder.appendUint53(compressed.byteLength)\n  encoder.appendRawBytes(compressed)\n  return encoder.buffer\n}\n\n/**\n * Decompresses a binary change that has been compressed with DEFLATE.\n */\nfunction inflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false)\n  if (header.chunkType !== CHUNK_TYPE_DEFLATE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n  const decompressed = pako.inflateRaw(header.chunkData)\n  const encoder = new Encoder()\n  encoder.appendRawBytes(buffer.subarray(0, 8)) // copy MAGIC_BYTES and checksum\n  encoder.appendByte(CHUNK_TYPE_CHANGE)\n  encoder.appendUint53(decompressed.byteLength)\n  encoder.appendRawBytes(decompressed)\n  return encoder.buffer\n}\n\n/**\n * Takes an Uint8Array that may contain multiple concatenated changes, and\n * returns an array of subarrays, each subarray containing one change.\n */\nfunction splitContainers(buffer) {\n  let decoder = new Decoder(buffer), chunks = [], startOffset = 0\n  while (!decoder.done) {\n    decodeContainerHeader(decoder, false)\n    chunks.push(buffer.subarray(startOffset, decoder.offset))\n    startOffset = decoder.offset\n  }\n  return chunks\n}\n\n/**\n * Decodes a list of changes from the binary format into JS objects.\n * `binaryChanges` is an array of `Uint8Array` objects.\n */\nfunction decodeChanges(binaryChanges) {\n  let decoded = []\n  for (let binaryChange of binaryChanges) {\n    for (let chunk of splitContainers(binaryChange)) {\n      if (chunk[8] === CHUNK_TYPE_DOCUMENT) {\n        decoded = decoded.concat(decodeDocument(chunk))\n      } else if (chunk[8] === CHUNK_TYPE_CHANGE || chunk[8] === CHUNK_TYPE_DEFLATE) {\n        decoded.push(decodeChange(chunk))\n      } else {\n        // ignoring chunk of unknown type\n      }\n    }\n  }\n  return decoded\n}\n\nfunction sortOpIds(a, b) {\n  if (a === b) return 0\n  if (a === '_root') return -1\n  if (b === '_root') return +1\n  const a_ = parseOpId(a), b_ = parseOpId(b)\n  if (a_.counter < b_.counter) return -1\n  if (a_.counter > b_.counter) return +1\n  if (a_.actorId < b_.actorId) return -1\n  if (a_.actorId > b_.actorId) return +1\n  return 0\n}\n\n/**\n * Takes a set of operations `ops` loaded from an encoded document, and\n * reconstructs the changes that they originally came from.\n * Does not return anything, only mutates `changes`.\n */\nfunction groupChangeOps(changes, ops) {\n  let changesByActor = {} // map from actorId to array of changes by that actor\n  for (let change of changes) {\n    change.ops = []\n    if (!changesByActor[change.actor]) changesByActor[change.actor] = []\n    if (change.seq !== changesByActor[change.actor].length + 1) {\n      throw new RangeError(`Expected seq = ${changesByActor[change.actor].length + 1}, got ${change.seq}`)\n    }\n    if (change.seq > 1 && changesByActor[change.actor][change.seq - 2].maxOp > change.maxOp) {\n      throw new RangeError('maxOp must increase monotonically per actor')\n    }\n    changesByActor[change.actor].push(change)\n  }\n\n  let opsById = {}\n  for (let op of ops) {\n    if (op.action === 'del') throw new RangeError('document should not contain del operations')\n    op.pred = opsById[op.id] ? opsById[op.id].pred : []\n    opsById[op.id] = op\n    for (let succ of op.succ) {\n      if (!opsById[succ]) {\n        if (op.elemId) {\n          const elemId = op.insert ? op.id : op.elemId\n          opsById[succ] = {id: succ, action: 'del', obj: op.obj, elemId, pred: []}\n        } else {\n          opsById[succ] = {id: succ, action: 'del', obj: op.obj, key: op.key, pred: []}\n        }\n      }\n      opsById[succ].pred.push(op.id)\n    }\n    delete op.succ\n  }\n  for (let op of Object.values(opsById)) {\n    if (op.action === 'del') ops.push(op)\n  }\n\n  for (let op of ops) {\n    const { counter, actorId } = parseOpId(op.id)\n    const actorChanges = changesByActor[actorId]\n    // Binary search to find the change that should contain this operation\n    let left = 0, right = actorChanges.length\n    while (left < right) {\n      const index = Math.floor((left + right) / 2)\n      if (actorChanges[index].maxOp < counter) {\n        left = index + 1\n      } else {\n        right = index\n      }\n    }\n    if (left >= actorChanges.length) {\n      throw new RangeError(`Operation ID ${op.id} outside of allowed range`)\n    }\n    actorChanges[left].ops.push(op)\n  }\n\n  for (let change of changes) {\n    change.ops.sort((op1, op2) => sortOpIds(op1.id, op2.id))\n    change.startOp = change.maxOp - change.ops.length + 1\n    delete change.maxOp\n    for (let i = 0; i < change.ops.length; i++) {\n      const op = change.ops[i], expectedId = `${change.startOp + i}@${change.actor}`\n      if (op.id !== expectedId) {\n        throw new RangeError(`Expected opId ${expectedId}, got ${op.id}`)\n      }\n      delete op.id\n    }\n  }\n}\n\nfunction decodeDocumentChanges(changes, expectedHeads) {\n  let heads = {} // change hashes that are not a dependency of any other change\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i]\n    change.deps = []\n    for (let index of change.depsNum.map(d => d.depsIndex)) {\n      if (!changes[index] || !changes[index].hash) {\n        throw new RangeError(`No hash for index ${index} while processing index ${i}`)\n      }\n      const hash = changes[index].hash\n      change.deps.push(hash)\n      if (heads[hash]) delete heads[hash]\n    }\n    change.deps.sort()\n    delete change.depsNum\n\n    if (change.extraLen_datatype !== VALUE_TYPE.BYTES) {\n      throw new RangeError(`Bad datatype for extra bytes: ${VALUE_TYPE.BYTES}`)\n    }\n    change.extraBytes = change.extraLen\n    delete change.extraLen_datatype\n\n    // Encoding and decoding again to compute the hash of the change\n    changes[i] = decodeChange(encodeChange(change))\n    heads[changes[i].hash] = true\n  }\n\n  const actualHeads = Object.keys(heads).sort()\n  let headsEqual = (actualHeads.length === expectedHeads.length), i = 0\n  while (headsEqual && i < actualHeads.length) {\n    headsEqual = (actualHeads[i] === expectedHeads[i])\n    i++\n  }\n  if (!headsEqual) {\n    throw new RangeError(`Mismatched heads hashes: expected ${expectedHeads.join(', ')}, got ${actualHeads.join(', ')}`)\n  }\n}\n\nfunction encodeDocumentHeader(doc) {\n  const { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes } = doc\n  for (let column of changesColumns) deflateColumn(column)\n  for (let column of opsColumns) deflateColumn(column)\n\n  return encodeContainer(CHUNK_TYPE_DOCUMENT, encoder => {\n    encoder.appendUint53(actorIds.length)\n    for (let actor of actorIds) {\n      encoder.appendHexString(actor)\n    }\n    encoder.appendUint53(heads.length)\n    for (let head of heads.sort()) {\n      encoder.appendRawBytes(hexStringToBytes(head))\n    }\n    encodeColumnInfo(encoder, changesColumns)\n    encodeColumnInfo(encoder, opsColumns)\n    for (let column of changesColumns) encoder.appendRawBytes(column.encoder.buffer)\n    for (let column of opsColumns) encoder.appendRawBytes(column.encoder.buffer)\n    for (let index of headsIndexes) encoder.appendUint53(index)\n    if (extraBytes) encoder.appendRawBytes(extraBytes)\n  }).bytes\n}\n\nfunction decodeDocumentHeader(buffer) {\n  const documentDecoder = new Decoder(buffer)\n  const header = decodeContainerHeader(documentDecoder, true)\n  const decoder = new Decoder(header.chunkData)\n  if (!documentDecoder.done) throw new RangeError('Encoded document has trailing data')\n  if (header.chunkType !== CHUNK_TYPE_DOCUMENT) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const actorIds = [], numActors = decoder.readUint53()\n  for (let i = 0; i < numActors; i++) {\n    actorIds.push(decoder.readHexString())\n  }\n  const heads = [], headsIndexes = [], numHeads = decoder.readUint53()\n  for (let i = 0; i < numHeads; i++) {\n    heads.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n\n  const changesColumns = decodeColumnInfo(decoder)\n  const opsColumns = decodeColumnInfo(decoder)\n  for (let i = 0; i < changesColumns.length; i++) {\n    changesColumns[i].buffer = decoder.readRawBytes(changesColumns[i].bufferLen)\n    inflateColumn(changesColumns[i])\n  }\n  for (let i = 0; i < opsColumns.length; i++) {\n    opsColumns[i].buffer = decoder.readRawBytes(opsColumns[i].bufferLen)\n    inflateColumn(opsColumns[i])\n  }\n  if (!decoder.done) {\n    for (let i = 0; i < numHeads; i++) headsIndexes.push(decoder.readUint53())\n  }\n\n  const extraBytes = decoder.readRawBytes(decoder.buf.byteLength - decoder.offset)\n  return { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes }\n}\n\nfunction decodeDocument(buffer) {\n  const { changesColumns, opsColumns, actorIds, heads } = decodeDocumentHeader(buffer)\n  const changes = decodeColumns(changesColumns, actorIds, DOCUMENT_COLUMNS)\n  const ops = decodeOps(decodeColumns(opsColumns, actorIds, DOC_OPS_COLUMNS), true)\n  groupChangeOps(changes, ops)\n  decodeDocumentChanges(changes, heads)\n  return changes\n}\n\n/**\n * DEFLATE-compresses the given column if it is large enough to make the compression worthwhile.\n */\nfunction deflateColumn(column) {\n  if (column.encoder.buffer.byteLength >= DEFLATE_MIN_SIZE) {\n    column.encoder = {buffer: pako.deflateRaw(column.encoder.buffer)}\n    column.columnId |= COLUMN_TYPE_DEFLATE\n  }\n}\n\n/**\n * Decompresses the given column if it is DEFLATE-compressed.\n */\nfunction inflateColumn(column) {\n  if ((column.columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n    column.buffer = pako.inflateRaw(column.buffer)\n    column.columnId ^= COLUMN_TYPE_DEFLATE\n  }\n}\n\nmodule.exports = {\n  COLUMN_TYPE, VALUE_TYPE, ACTIONS, OBJECT_TYPE, DOC_OPS_COLUMNS, CHANGE_COLUMNS, DOCUMENT_COLUMNS,\n  encoderByColumnId, decoderByColumnId, makeDecoders, decodeValue,\n  splitContainers, encodeChange, decodeChangeColumns, decodeChange, decodeChangeMeta, decodeChanges,\n  encodeDocumentHeader, decodeDocumentHeader, decodeDocument\n}\n"]},"metadata":{},"sourceType":"script"}