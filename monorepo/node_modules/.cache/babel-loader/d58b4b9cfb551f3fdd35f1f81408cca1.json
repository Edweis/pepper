{"ast":null,"code":"const {\n  CACHE,\n  OBJECT_ID,\n  CONFLICTS,\n  ELEM_IDS,\n  STATE\n} = require('./constants');\n\nconst {\n  interpretPatch\n} = require('./apply_patch');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nconst {\n  Counter,\n  getWriteableCounter\n} = require('./counter');\n\nconst {\n  Int,\n  Uint,\n  Float64\n} = require('./numbers');\n\nconst {\n  isObject,\n  parseOpId,\n  createArrayOfNulls\n} = require('../src/common');\n\nconst uuid = require('../src/uuid');\n/**\n * An instance of this class is passed to `rootObjectProxy()`. The methods are\n * called by proxy object mutation functions to query the current object state\n * and to apply the requested changes.\n */\n\n\nclass Context {\n  constructor(doc, actorId, applyPatch) {\n    this.actorId = actorId;\n    this.nextOpNum = doc[STATE].maxOp + 1;\n    this.cache = doc[CACHE];\n    this.updated = {};\n    this.ops = [];\n    this.applyPatch = applyPatch ? applyPatch : interpretPatch;\n  }\n  /**\n   * Adds an operation object to the list of changes made in the current context.\n   */\n\n\n  addOp(operation) {\n    this.ops.push(operation);\n\n    if (operation.action === 'set' && operation.values) {\n      this.nextOpNum += operation.values.length;\n    } else if (operation.action === 'del' && operation.multiOp) {\n      this.nextOpNum += operation.multiOp;\n    } else {\n      this.nextOpNum += 1;\n    }\n  }\n  /**\n   * Returns the operation ID of the next operation to be added to the context.\n   */\n\n\n  nextOpId() {\n    return `${this.nextOpNum}@${this.actorId}`;\n  }\n  /**\n   * Takes a value and returns an object describing the value (in the format used by patches).\n   */\n\n\n  getValueDescription(value) {\n    if (!['object', 'boolean', 'number', 'string'].includes(typeof value)) {\n      throw new TypeError(`Unsupported type of value: ${typeof value}`);\n    }\n\n    if (isObject(value)) {\n      if (value instanceof Date) {\n        // Date object, represented as milliseconds since epoch\n        return {\n          type: 'value',\n          value: value.getTime(),\n          datatype: 'timestamp'\n        };\n      } else if (value instanceof Int) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'int'\n        };\n      } else if (value instanceof Uint) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'uint'\n        };\n      } else if (value instanceof Float64) {\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'float64'\n        };\n      } else if (value instanceof Counter) {\n        // Counter object\n        return {\n          type: 'value',\n          value: value.value,\n          datatype: 'counter'\n        };\n      } else {\n        // Nested object (map, list, text, or table)\n        const objectId = value[OBJECT_ID],\n              type = this.getObjectType(objectId);\n\n        if (!objectId) {\n          throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`);\n        }\n\n        if (type === 'list' || type === 'text') {\n          return {\n            objectId,\n            type,\n            edits: []\n          };\n        } else {\n          return {\n            objectId,\n            type,\n            props: {}\n          };\n        }\n      }\n    } else if (typeof value === 'number') {\n      if (Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {\n        return {\n          type: 'value',\n          value,\n          datatype: 'int'\n        };\n      } else {\n        return {\n          type: 'value',\n          value,\n          datatype: 'float64'\n        };\n      }\n    } else {\n      // Primitive value (string, boolean, or null)\n      return {\n        type: 'value',\n        value\n      };\n    }\n  }\n  /**\n   * Builds the values structure describing a single property in a patch. Finds all the values of\n   * property `key` of `object` (there might be multiple values in the case of a conflict), and\n   * returns an object that maps operation IDs to descriptions of values.\n   */\n\n\n  getValuesDescriptions(path, object, key) {\n    if (object instanceof Table) {\n      // Table objects don't have conflicts, since rows are identified by their unique objectId\n      const value = object.byId(key);\n      return value ? {\n        [key]: this.getValueDescription(value)\n      } : {};\n    } else if (object instanceof Text) {\n      // Text objects don't support conflicts\n      const value = object.get(key);\n      const elemId = object.getElemId(key);\n      return value ? {\n        [elemId]: this.getValueDescription(value)\n      } : {};\n    } else {\n      // Map or list objects\n      const conflicts = object[CONFLICTS][key],\n            values = {};\n\n      if (!conflicts) {\n        throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`);\n      }\n\n      for (let opId of Object.keys(conflicts)) {\n        values[opId] = this.getValueDescription(conflicts[opId]);\n      }\n\n      return values;\n    }\n  }\n  /**\n   * Returns the value at property `key` of object `object`. In the case of a conflict, returns\n   * the value whose assignment operation has the ID `opId`.\n   */\n\n\n  getPropertyValue(object, key, opId) {\n    if (object instanceof Table) {\n      return object.byId(key);\n    } else if (object instanceof Text) {\n      return object.get(key);\n    } else {\n      return object[CONFLICTS][key][opId];\n    }\n  }\n  /**\n   * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed\n   * by mutating the patch object. Returns the subpatch at the given path.\n   */\n\n\n  getSubpatch(patch, path) {\n    if (path.length == 0) return patch;\n    let subpatch = patch,\n        object = this.getObject('_root');\n\n    for (let pathElem of path) {\n      let values = this.getValuesDescriptions(path, object, pathElem.key);\n\n      if (subpatch.props) {\n        if (!subpatch.props[pathElem.key]) {\n          subpatch.props[pathElem.key] = values;\n        }\n      } else if (subpatch.edits) {\n        for (const opId of Object.keys(values)) {\n          subpatch.edits.push({\n            action: 'update',\n            index: pathElem.key,\n            opId,\n            value: values[opId]\n          });\n        }\n      }\n\n      let nextOpId = null;\n\n      for (let opId of Object.keys(values)) {\n        if (values[opId].objectId === pathElem.objectId) {\n          nextOpId = opId;\n        }\n      }\n\n      if (!nextOpId) {\n        throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`);\n      }\n\n      subpatch = values[nextOpId];\n      object = this.getPropertyValue(object, pathElem.key, nextOpId);\n    }\n\n    return subpatch;\n  }\n  /**\n   * Returns an object (not proxied) from the cache or updated set, as appropriate.\n   */\n\n\n  getObject(objectId) {\n    const object = this.updated[objectId] || this.cache[objectId];\n    if (!object) throw new RangeError(`Target object does not exist: ${objectId}`);\n    return object;\n  }\n  /**\n   * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n   * the type of the object with ID `objectId`.\n   */\n\n\n  getObjectType(objectId) {\n    if (objectId === '_root') return 'map';\n    const object = this.getObject(objectId);\n    if (object instanceof Text) return 'text';\n    if (object instanceof Table) return 'table';\n    if (Array.isArray(object)) return 'list';\n    return 'map';\n  }\n  /**\n   * Returns the value associated with the property named `key` on the object\n   * at path `path`. If the value is an object, returns a proxy for it.\n   */\n\n\n  getObjectField(path, objectId, key) {\n    if (!['string', 'number'].includes(typeof key)) return;\n    const object = this.getObject(objectId);\n\n    if (object[key] instanceof Counter) {\n      return getWriteableCounter(object[key].value, this, path, objectId, key);\n    } else if (isObject(object[key])) {\n      const childId = object[key][OBJECT_ID];\n      const subpath = path.concat([{\n        key,\n        objectId: childId\n      }]); // The instantiateObject function is added to the context object by rootObjectProxy()\n\n      return this.instantiateObject(subpath, childId);\n    } else {\n      return object[key];\n    }\n  }\n  /**\n   * Recursively creates Automerge versions of all the objects and nested objects in `value`,\n   * constructing a patch and operations that describe the object tree. The new object is\n   * assigned to the property `key` in the object with ID `obj`. If the object is a list or\n   * text, `key` must be set to the list index being updated, and `elemId` must be set to the\n   * elemId of the element being updated. If `insert` is true, we insert a new list element\n   * (or text character) at index `key`, and `elemId` must be the elemId of the immediate\n   * predecessor element (or the string '_head' if inserting at index 0). If the assignment\n   * overwrites a previous value at this key/element, `pred` must be set to the array of the\n   * prior operations we are overwriting (empty array if there is no existing value).\n   */\n\n\n  createNestedObjects(obj, key, value, insert, pred, elemId) {\n    if (value[OBJECT_ID]) {\n      throw new RangeError('Cannot create a reference to an existing document object');\n    }\n\n    const objectId = this.nextOpId();\n\n    if (value instanceof Text) {\n      // Create a new Text object\n      this.addOp(elemId ? {\n        action: 'makeText',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeText',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      const subpatch = {\n        objectId,\n        type: 'text',\n        edits: []\n      };\n      this.insertListItems(subpatch, 0, [...value], true);\n      return subpatch;\n    } else if (value instanceof Table) {\n      // Create a new Table object\n      if (value.count > 0) {\n        throw new RangeError('Assigning a non-empty Table object is not supported');\n      }\n\n      this.addOp(elemId ? {\n        action: 'makeTable',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeTable',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      return {\n        objectId,\n        type: 'table',\n        props: {}\n      };\n    } else if (Array.isArray(value)) {\n      // Create a new list object\n      this.addOp(elemId ? {\n        action: 'makeList',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeList',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      const subpatch = {\n        objectId,\n        type: 'list',\n        edits: []\n      };\n      this.insertListItems(subpatch, 0, value, true);\n      return subpatch;\n    } else {\n      // Create a new map object\n      this.addOp(elemId ? {\n        action: 'makeMap',\n        obj,\n        elemId,\n        insert,\n        pred\n      } : {\n        action: 'makeMap',\n        obj,\n        key,\n        insert,\n        pred\n      });\n      let props = {};\n\n      for (let nested of Object.keys(value).sort()) {\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, nested, value[nested], false, []);\n        props[nested] = {\n          [opId]: valuePatch\n        };\n      }\n\n      return {\n        objectId,\n        type: 'map',\n        props\n      };\n    }\n  }\n  /**\n   * Records an assignment to a particular key in a map, or a particular index in a list.\n   * `objectId` is the ID of the object being modified, `key` is the property name or list\n   * index being updated, and `value` is the new value being assigned. If `insert` is true,\n   * a new list element is inserted at index `key`, and `value` is assigned to that new list\n   * element. `pred` is an array of opIds for previous values of the property being assigned,\n   * which are overwritten by this operation. If the object being modified is a list or text,\n   * `elemId` is the element ID of the list element being updated (if insert=false), or the\n   * element ID of the list element immediately preceding the insertion (if insert=true).\n   *\n   * Returns a patch describing the new value. The return value is of the form\n   * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a\n   * primitive value. For string, number, boolean, or null the datatype is omitted.\n   */\n\n\n  setValue(objectId, key, value, insert, pred, elemId) {\n    if (!objectId) {\n      throw new RangeError('setValue needs an objectId');\n    }\n\n    if (key === '') {\n      throw new RangeError('The key of a map entry must not be an empty string');\n    }\n\n    if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter) && !(value instanceof Int) && !(value instanceof Uint) && !(value instanceof Float64)) {\n      // Nested object (map, list, text, or table)\n      return this.createNestedObjects(objectId, key, value, insert, pred, elemId);\n    } else {\n      // Date or counter object, or primitive value (number, string, boolean, or null)\n      const description = this.getValueDescription(value);\n      const op = {\n        action: 'set',\n        obj: objectId,\n        insert,\n        value: description.value,\n        pred\n      };\n      if (elemId) op.elemId = elemId;else op.key = key;\n      if (description.datatype) op.datatype = description.datatype;\n      this.addOp(op);\n      return description;\n    }\n  }\n  /**\n   * Constructs a new patch, calls `callback` with the subpatch at the location `path`,\n   * and then immediately applies the patch to the document.\n   */\n\n\n  applyAtPath(path, callback) {\n    let diff = {\n      objectId: '_root',\n      type: 'map',\n      props: {}\n    };\n    callback(this.getSubpatch(diff, path));\n    this.applyPatch(diff, this.cache._root, this.updated);\n  }\n  /**\n   * Updates the map object at path `path`, setting the property with name\n   * `key` to `value`.\n   */\n\n\n  setMapKey(path, key, value) {\n    if (typeof key !== 'string') {\n      throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`);\n    }\n\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (object[key] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.');\n    } // If the assigned field value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n\n\n    if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(object, key);\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, key, value, false, pred);\n        subpatch.props[key] = {\n          [opId]: valuePatch\n        };\n      });\n    }\n  }\n  /**\n   * Updates the map object at path `path`, deleting the property `key`.\n   */\n\n\n  deleteMapKey(path, key) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (object[key] !== undefined) {\n      const pred = getPred(object, key);\n      this.addOp({\n        action: 'del',\n        obj: objectId,\n        key,\n        insert: false,\n        pred\n      });\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[key] = {};\n      });\n    }\n  }\n  /**\n   * Inserts a sequence of new list elements `values` into a list, starting at position `index`.\n   * `newObject` is true if we are creating a new list object, and false if we are updating an\n   * existing one. `subpatch` is the patch for the list object being modified. Mutates\n   * `subpatch` to reflect the sequence of values.\n   */\n\n\n  insertListItems(subpatch, index, values, newObject) {\n    const list = newObject ? [] : this.getObject(subpatch.objectId);\n\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`);\n    }\n\n    if (values.length === 0) return;\n    let elemId = getElemId(list, index, true);\n    const allPrimitive = values.every(v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null || isObject(v) && (v instanceof Date || v instanceof Counter || v instanceof Int || v instanceof Uint || v instanceof Float64));\n    const allValueDescriptions = allPrimitive ? values.map(v => this.getValueDescription(v)) : [];\n    const allDatatypesSame = allValueDescriptions.every(t => t.datatype === allValueDescriptions[0].datatype);\n\n    if (allPrimitive && allDatatypesSame && values.length > 1) {\n      const nextElemId = this.nextOpId();\n      const datatype = allValueDescriptions[0].datatype;\n      const values = allValueDescriptions.map(v => v.value);\n      const op = {\n        action: 'set',\n        obj: subpatch.objectId,\n        elemId,\n        insert: true,\n        values,\n        pred: []\n      };\n      const edit = {\n        action: 'multi-insert',\n        elemId: nextElemId,\n        index,\n        values\n      };\n\n      if (datatype) {\n        op.datatype = datatype;\n        edit.datatype = datatype;\n      }\n\n      this.addOp(op);\n      subpatch.edits.push(edit);\n    } else {\n      for (let offset = 0; offset < values.length; offset++) {\n        let nextElemId = this.nextOpId();\n        const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true, [], elemId);\n        elemId = nextElemId;\n        subpatch.edits.push({\n          action: 'insert',\n          index: index + offset,\n          elemId,\n          opId: elemId,\n          value: valuePatch\n        });\n      }\n    }\n  }\n  /**\n   * Updates the list object at path `path`, replacing the current value at\n   * position `index` with the new value `value`.\n   */\n\n\n  setListIndex(path, index, value) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const list = this.getObject(objectId); // Assignment past the end of the list => insert nulls followed by new value\n\n    if (index >= list.length) {\n      const insertions = createArrayOfNulls(index - list.length);\n      insertions.push(value);\n      return this.splice(path, list.length, 0, insertions);\n    }\n\n    if (list[index] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.');\n    } // If the assigned list element value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n\n\n    if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(list, index);\n        const opId = this.nextOpId();\n        const valuePatch = this.setValue(objectId, index, value, false, pred, getElemId(list, index));\n        subpatch.edits.push({\n          action: 'update',\n          index,\n          opId,\n          value: valuePatch\n        });\n      });\n    }\n  }\n  /**\n   * Updates the list object at path `path`, deleting `deletions` list elements starting from\n   * list index `start`, and inserting the list of new elements `insertions` at that position.\n   */\n\n\n  splice(path, start, deletions, insertions) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    let list = this.getObject(objectId);\n\n    if (start < 0 || deletions < 0 || start > list.length - deletions) {\n      throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`);\n    }\n\n    if (deletions === 0 && insertions.length === 0) return;\n    let patch = {\n      diffs: {\n        objectId: '_root',\n        type: 'map',\n        props: {}\n      }\n    };\n    let subpatch = this.getSubpatch(patch.diffs, path);\n\n    if (deletions > 0) {\n      let op, lastElemParsed, lastPredParsed;\n\n      for (let i = 0; i < deletions; i++) {\n        if (this.getObjectField(path, objectId, start + i) instanceof Counter) {\n          // This may seem bizarre, but it's really fiddly to implement deletion of counters from\n          // lists, and I doubt anyone ever needs to do this, so I'm just going to throw an\n          // exception for now. The reason is: a counter is created by a set operation with counter\n          // datatype, and subsequent increment ops are successors to the set operation. Normally, a\n          // set operation with successor indicates a value that has been overwritten, so a set\n          // operation with successors is normally invisible. Counters are an exception, because the\n          // increment operations don't make the set operation invisible. When a counter appears in\n          // a map, this is not too bad: if all successors are increments, then the counter remains\n          // visible; if one or more successors are deletions, it goes away. However, when deleting\n          // a list element, we have the additional challenge that we need to distinguish between a\n          // list element that is being deleted by the current change (in which case we need to put\n          // a 'remove' action in the patch's edits for that list) and a list element that was\n          // already deleted previously (in which case the patch should not reflect the deletion).\n          // This can be done, but as I said, it's fiddly. If someone wants to pick this up in the\n          // future, hopefully the above description will be enough to get you started. Good luck!\n          throw new TypeError('Unsupported operation: deleting a counter from a list');\n        } // Any sequences of deletions with consecutive elemId and pred values get combined into a\n        // single multiOp; any others become individual deletion operations. This optimisation only\n        // kicks in if the user deletes a sequence of elements at once (in a single call to splice);\n        // it might be nice to also detect such runs of deletions in the case where the user deletes\n        // a sequence of list elements one by one.\n\n\n        const thisElem = getElemId(list, start + i),\n              thisElemParsed = parseOpId(thisElem);\n        const thisPred = getPred(list, start + i);\n        const thisPredParsed = thisPred.length === 1 ? parseOpId(thisPred[0]) : undefined;\n\n        if (op && lastElemParsed && lastPredParsed && thisPredParsed && lastElemParsed.actorId === thisElemParsed.actorId && lastElemParsed.counter + 1 === thisElemParsed.counter && lastPredParsed.actorId === thisPredParsed.actorId && lastPredParsed.counter + 1 === thisPredParsed.counter) {\n          op.multiOp = (op.multiOp || 1) + 1;\n        } else {\n          if (op) this.addOp(op);\n          op = {\n            action: 'del',\n            obj: objectId,\n            elemId: thisElem,\n            insert: false,\n            pred: thisPred\n          };\n        }\n\n        lastElemParsed = thisElemParsed;\n        lastPredParsed = thisPredParsed;\n      }\n\n      this.addOp(op);\n      subpatch.edits.push({\n        action: 'remove',\n        index: start,\n        count: deletions\n      });\n    }\n\n    if (insertions.length > 0) {\n      this.insertListItems(subpatch, start, insertions, false);\n    }\n\n    this.applyPatch(patch.diffs, this.cache._root, this.updated);\n  }\n  /**\n   * Updates the table object at path `path`, adding a new entry `row`.\n   * Returns the objectId of the new row.\n   */\n\n\n  addTableRow(path, row) {\n    if (!isObject(row) || Array.isArray(row)) {\n      throw new TypeError('A table row must be an object');\n    }\n\n    if (row[OBJECT_ID]) {\n      throw new TypeError('Cannot reuse an existing object as table row');\n    }\n\n    if (row.id) {\n      throw new TypeError('A table row must not have an \"id\" property; it is generated automatically');\n    }\n\n    const id = uuid();\n    const valuePatch = this.setValue(path[path.length - 1].objectId, id, row, false, []);\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[id] = {\n        [valuePatch.objectId]: valuePatch\n      };\n    });\n    return id;\n  }\n  /**\n   * Updates the table object at path `path`, deleting the row with ID `rowId`.\n   * `pred` is the opId of the operation that originally created the row.\n   */\n\n\n  deleteTableRow(path, rowId, pred) {\n    const objectId = path[path.length - 1].objectId,\n          table = this.getObject(objectId);\n\n    if (table.byId(rowId)) {\n      this.addOp({\n        action: 'del',\n        obj: objectId,\n        key: rowId,\n        insert: false,\n        pred: [pred]\n      });\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[rowId] = {};\n      });\n    }\n  }\n  /**\n   * Adds the integer `delta` to the value of the counter located at property\n   * `key` in the object at path `path`.\n   */\n\n\n  increment(path, key, delta) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId;\n    const object = this.getObject(objectId);\n\n    if (!(object[key] instanceof Counter)) {\n      throw new TypeError('Only counter values can be incremented');\n    } // TODO what if there is a conflicting value on the same key as the counter?\n\n\n    const type = this.getObjectType(objectId);\n    const value = object[key].value + delta;\n    const opId = this.nextOpId();\n    const pred = getPred(object, key);\n\n    if (type === 'list' || type === 'text') {\n      const elemId = getElemId(object, key, false);\n      this.addOp({\n        action: 'inc',\n        obj: objectId,\n        elemId,\n        value: delta,\n        insert: false,\n        pred\n      });\n    } else {\n      this.addOp({\n        action: 'inc',\n        obj: objectId,\n        key,\n        value: delta,\n        insert: false,\n        pred\n      });\n    }\n\n    this.applyAtPath(path, subpatch => {\n      if (type === 'list' || type === 'text') {\n        subpatch.edits.push({\n          action: 'update',\n          index: key,\n          opId,\n          value: {\n            value,\n            datatype: 'counter'\n          }\n        });\n      } else {\n        subpatch.props[key] = {\n          [opId]: {\n            value,\n            datatype: 'counter'\n          }\n        };\n      }\n    });\n  }\n\n}\n\nfunction getPred(object, key) {\n  if (object instanceof Table) {\n    return [object.opIds[key]];\n  } else if (object instanceof Text) {\n    return object.elems[key].pred;\n  } else if (object[CONFLICTS]) {\n    return object[CONFLICTS][key] ? Object.keys(object[CONFLICTS][key]) : [];\n  } else {\n    return [];\n  }\n}\n\nfunction getElemId(list, index) {\n  let insert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (insert) {\n    if (index === 0) return '_head';\n    index -= 1;\n  }\n\n  if (list[ELEM_IDS]) return list[ELEM_IDS][index];\n  if (list.getElemId) return list.getElemId(index);\n  throw new RangeError(`Cannot find elemId at list index ${index}`);\n}\n\nmodule.exports = {\n  Context\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/context.js"],"names":["CACHE","OBJECT_ID","CONFLICTS","ELEM_IDS","STATE","require","interpretPatch","Text","Table","Counter","getWriteableCounter","Int","Uint","Float64","isObject","parseOpId","createArrayOfNulls","uuid","Context","constructor","doc","actorId","applyPatch","nextOpNum","maxOp","cache","updated","ops","addOp","operation","push","action","values","length","multiOp","nextOpId","getValueDescription","value","includes","TypeError","Date","type","getTime","datatype","objectId","getObjectType","RangeError","JSON","stringify","edits","props","Number","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getValuesDescriptions","path","object","key","byId","get","elemId","getElemId","conflicts","opId","Object","keys","getPropertyValue","getSubpatch","patch","subpatch","getObject","pathElem","index","Array","isArray","getObjectField","childId","subpath","concat","instantiateObject","createNestedObjects","obj","insert","pred","insertListItems","count","nested","sort","valuePatch","setValue","description","op","applyAtPath","callback","diff","_root","setMapKey","undefined","getPred","deleteMapKey","newObject","list","allPrimitive","every","v","allValueDescriptions","map","allDatatypesSame","t","nextElemId","edit","offset","setListIndex","insertions","splice","start","deletions","diffs","lastElemParsed","lastPredParsed","i","thisElem","thisElemParsed","thisPred","thisPredParsed","counter","addTableRow","row","id","deleteTableRow","rowId","table","increment","delta","opIds","elems","module","exports"],"mappings":"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","sourcesContent":["const { CACHE, OBJECT_ID, CONFLICTS, ELEM_IDS, STATE } = require('./constants')\nconst { interpretPatch } = require('./apply_patch')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter, getWriteableCounter } = require('./counter')\nconst { Int, Uint, Float64 } = require('./numbers')\nconst { isObject, parseOpId, createArrayOfNulls } = require('../src/common')\nconst uuid = require('../src/uuid')\n\n\n/**\n * An instance of this class is passed to `rootObjectProxy()`. The methods are\n * called by proxy object mutation functions to query the current object state\n * and to apply the requested changes.\n */\nclass Context {\n  constructor (doc, actorId, applyPatch) {\n    this.actorId = actorId\n    this.nextOpNum = doc[STATE].maxOp + 1\n    this.cache = doc[CACHE]\n    this.updated = {}\n    this.ops = []\n    this.applyPatch = applyPatch ? applyPatch : interpretPatch\n  }\n\n  /**\n   * Adds an operation object to the list of changes made in the current context.\n   */\n  addOp(operation) {\n    this.ops.push(operation)\n\n    if (operation.action === 'set' && operation.values) {\n      this.nextOpNum += operation.values.length\n    } else if (operation.action === 'del' && operation.multiOp) {\n      this.nextOpNum += operation.multiOp\n    } else {\n      this.nextOpNum += 1\n    }\n  }\n\n  /**\n   * Returns the operation ID of the next operation to be added to the context.\n   */\n  nextOpId() {\n    return `${this.nextOpNum}@${this.actorId}`\n  }\n\n  /**\n   * Takes a value and returns an object describing the value (in the format used by patches).\n   */\n  getValueDescription(value) {\n    if (!['object', 'boolean', 'number', 'string'].includes(typeof value)) {\n      throw new TypeError(`Unsupported type of value: ${typeof value}`)\n    }\n\n    if (isObject(value)) {\n      if (value instanceof Date) {\n        // Date object, represented as milliseconds since epoch\n        return {type: 'value', value: value.getTime(), datatype: 'timestamp'}\n\n      } else if (value instanceof Int) {\n        return {type: 'value', value: value.value, datatype: 'int'}\n      } else if (value instanceof Uint) {\n        return {type: 'value', value: value.value, datatype: 'uint'}\n      } else if (value instanceof Float64) {\n        return {type: 'value', value: value.value, datatype: 'float64'}\n      } else if (value instanceof Counter) {\n        // Counter object\n        return {type: 'value', value: value.value, datatype: 'counter'}\n\n      } else {\n        // Nested object (map, list, text, or table)\n        const objectId = value[OBJECT_ID], type = this.getObjectType(objectId)\n        if (!objectId) {\n          throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`)\n        }\n        if (type === 'list' || type === 'text') {\n          return {objectId, type, edits: []}\n        } else {\n          return {objectId, type, props: {}}\n        }\n      }\n    } else if (typeof value === 'number') {\n      if (Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {\n        return {type: 'value', value, datatype: 'int'}\n      } else {\n        return {type: 'value', value, datatype: 'float64'}\n      }\n    } else {\n      // Primitive value (string, boolean, or null)\n      return {type: 'value', value}\n    }\n  }\n\n  /**\n   * Builds the values structure describing a single property in a patch. Finds all the values of\n   * property `key` of `object` (there might be multiple values in the case of a conflict), and\n   * returns an object that maps operation IDs to descriptions of values.\n   */\n  getValuesDescriptions(path, object, key) {\n    if (object instanceof Table) {\n      // Table objects don't have conflicts, since rows are identified by their unique objectId\n      const value = object.byId(key)\n      return value ? {[key]: this.getValueDescription(value)} : {}\n    } else if (object instanceof Text) {\n      // Text objects don't support conflicts\n      const value = object.get(key)\n      const elemId = object.getElemId(key)\n      return value ? {[elemId]: this.getValueDescription(value)} : {}\n    } else {\n      // Map or list objects\n      const conflicts = object[CONFLICTS][key], values = {}\n      if (!conflicts) {\n        throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`)\n      }\n      for (let opId of Object.keys(conflicts)) {\n        values[opId] = this.getValueDescription(conflicts[opId])\n      }\n      return values\n    }\n  }\n\n  /**\n   * Returns the value at property `key` of object `object`. In the case of a conflict, returns\n   * the value whose assignment operation has the ID `opId`.\n   */\n  getPropertyValue(object, key, opId) {\n    if (object instanceof Table) {\n      return object.byId(key)\n    } else if (object instanceof Text) {\n      return object.get(key)\n    } else {\n      return object[CONFLICTS][key][opId]\n    }\n  }\n\n  /**\n   * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed\n   * by mutating the patch object. Returns the subpatch at the given path.\n   */\n  getSubpatch(patch, path) {\n    if (path.length == 0) return patch\n    let subpatch = patch, object = this.getObject('_root')\n\n    for (let pathElem of path) {\n      let values = this.getValuesDescriptions(path, object, pathElem.key)\n      if (subpatch.props) {\n        if (!subpatch.props[pathElem.key]) {\n          subpatch.props[pathElem.key] = values\n        }\n      } else if (subpatch.edits) {\n        for (const opId of Object.keys(values)) {\n          subpatch.edits.push({action: 'update', index: pathElem.key, opId, value: values[opId]})\n        }\n      }\n\n      let nextOpId = null\n      for (let opId of Object.keys(values)) {\n        if (values[opId].objectId === pathElem.objectId) {\n          nextOpId = opId\n        }\n      }\n      if (!nextOpId) {\n        throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`)\n      }\n\n      subpatch = values[nextOpId]\n      object = this.getPropertyValue(object, pathElem.key, nextOpId)\n    }\n\n    return subpatch\n  }\n\n  /**\n   * Returns an object (not proxied) from the cache or updated set, as appropriate.\n   */\n  getObject(objectId) {\n    const object = this.updated[objectId] || this.cache[objectId]\n    if (!object) throw new RangeError(`Target object does not exist: ${objectId}`)\n    return object\n  }\n\n  /**\n   * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n   * the type of the object with ID `objectId`.\n   */\n  getObjectType(objectId) {\n    if (objectId === '_root') return 'map'\n    const object = this.getObject(objectId)\n    if (object instanceof Text) return 'text'\n    if (object instanceof Table) return 'table'\n    if (Array.isArray(object)) return 'list'\n    return 'map'\n  }\n\n  /**\n   * Returns the value associated with the property named `key` on the object\n   * at path `path`. If the value is an object, returns a proxy for it.\n   */\n  getObjectField(path, objectId, key) {\n    if (!['string', 'number'].includes(typeof key)) return\n    const object = this.getObject(objectId)\n\n    if (object[key] instanceof Counter) {\n      return getWriteableCounter(object[key].value, this, path, objectId, key)\n\n    } else if (isObject(object[key])) {\n      const childId = object[key][OBJECT_ID]\n      const subpath = path.concat([{key, objectId: childId}])\n      // The instantiateObject function is added to the context object by rootObjectProxy()\n      return this.instantiateObject(subpath, childId)\n\n    } else {\n      return object[key]\n    }\n  }\n\n  /**\n   * Recursively creates Automerge versions of all the objects and nested objects in `value`,\n   * constructing a patch and operations that describe the object tree. The new object is\n   * assigned to the property `key` in the object with ID `obj`. If the object is a list or\n   * text, `key` must be set to the list index being updated, and `elemId` must be set to the\n   * elemId of the element being updated. If `insert` is true, we insert a new list element\n   * (or text character) at index `key`, and `elemId` must be the elemId of the immediate\n   * predecessor element (or the string '_head' if inserting at index 0). If the assignment\n   * overwrites a previous value at this key/element, `pred` must be set to the array of the\n   * prior operations we are overwriting (empty array if there is no existing value).\n   */\n  createNestedObjects(obj, key, value, insert, pred, elemId) {\n    if (value[OBJECT_ID]) {\n      throw new RangeError('Cannot create a reference to an existing document object')\n    }\n    const objectId = this.nextOpId()\n\n    if (value instanceof Text) {\n      // Create a new Text object\n      this.addOp(elemId ? {action: 'makeText', obj, elemId, insert, pred}\n                        : {action: 'makeText', obj, key, insert, pred})\n      const subpatch = {objectId, type: 'text', edits: []}\n      this.insertListItems(subpatch, 0, [...value], true)\n      return subpatch\n\n    } else if (value instanceof Table) {\n      // Create a new Table object\n      if (value.count > 0) {\n        throw new RangeError('Assigning a non-empty Table object is not supported')\n      }\n      this.addOp(elemId ? {action: 'makeTable', obj, elemId, insert, pred}\n                        : {action: 'makeTable', obj, key, insert, pred})\n      return {objectId, type: 'table', props: {}}\n\n    } else if (Array.isArray(value)) {\n      // Create a new list object\n      this.addOp(elemId ? {action: 'makeList', obj, elemId, insert, pred}\n                        : {action: 'makeList', obj, key, insert, pred})\n      const subpatch = {objectId, type: 'list', edits: []}\n      this.insertListItems(subpatch, 0, value, true)\n      return subpatch\n\n    } else {\n      // Create a new map object\n      this.addOp(elemId ? {action: 'makeMap', obj, elemId, insert, pred}\n                        : {action: 'makeMap', obj, key, insert, pred})\n      let props = {}\n      for (let nested of Object.keys(value).sort()) {\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, nested, value[nested], false, [])\n        props[nested] = {[opId]: valuePatch}\n      }\n      return {objectId, type: 'map', props}\n    }\n  }\n\n  /**\n   * Records an assignment to a particular key in a map, or a particular index in a list.\n   * `objectId` is the ID of the object being modified, `key` is the property name or list\n   * index being updated, and `value` is the new value being assigned. If `insert` is true,\n   * a new list element is inserted at index `key`, and `value` is assigned to that new list\n   * element. `pred` is an array of opIds for previous values of the property being assigned,\n   * which are overwritten by this operation. If the object being modified is a list or text,\n   * `elemId` is the element ID of the list element being updated (if insert=false), or the\n   * element ID of the list element immediately preceding the insertion (if insert=true).\n   *\n   * Returns a patch describing the new value. The return value is of the form\n   * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a\n   * primitive value. For string, number, boolean, or null the datatype is omitted.\n   */\n  setValue(objectId, key, value, insert, pred, elemId) {\n    if (!objectId) {\n      throw new RangeError('setValue needs an objectId')\n    }\n    if (key === '') {\n      throw new RangeError('The key of a map entry must not be an empty string')\n    }\n\n    if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter) && !(value instanceof Int) && !(value instanceof Uint) && !(value instanceof Float64)) {\n      // Nested object (map, list, text, or table)\n      return this.createNestedObjects(objectId, key, value, insert, pred, elemId)\n    } else {\n      // Date or counter object, or primitive value (number, string, boolean, or null)\n      const description = this.getValueDescription(value)\n      const op = {action: 'set', obj: objectId, insert, value: description.value, pred}\n      if (elemId) op.elemId = elemId; else op.key = key\n      if (description.datatype) op.datatype = description.datatype\n      this.addOp(op)\n      return description\n    }\n  }\n\n  /**\n   * Constructs a new patch, calls `callback` with the subpatch at the location `path`,\n   * and then immediately applies the patch to the document.\n   */\n  applyAtPath(path, callback) {\n    let diff = {objectId: '_root', type: 'map', props: {}}\n    callback(this.getSubpatch(diff, path))\n    this.applyPatch(diff, this.cache._root, this.updated)\n  }\n\n  /**\n   * Updates the map object at path `path`, setting the property with name\n   * `key` to `value`.\n   */\n  setMapKey(path, key, value) {\n    if (typeof key !== 'string') {\n      throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`)\n    }\n\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (object[key] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned field value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(object, key)\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, key, value, false, pred)\n        subpatch.props[key] = {[opId]: valuePatch}\n      })\n    }\n  }\n\n  /**\n   * Updates the map object at path `path`, deleting the property `key`.\n   */\n  deleteMapKey(path, key) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n\n    if (object[key] !== undefined) {\n      const pred = getPred(object, key)\n      this.addOp({action: 'del', obj: objectId, key, insert: false, pred})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[key] = {}\n      })\n    }\n  }\n\n  /**\n   * Inserts a sequence of new list elements `values` into a list, starting at position `index`.\n   * `newObject` is true if we are creating a new list object, and false if we are updating an\n   * existing one. `subpatch` is the patch for the list object being modified. Mutates\n   * `subpatch` to reflect the sequence of values.\n   */\n  insertListItems(subpatch, index, values, newObject) {\n    const list = newObject ? [] : this.getObject(subpatch.objectId)\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`)\n    }\n    if (values.length === 0) return\n\n    let elemId = getElemId(list, index, true)\n    const allPrimitive = values.every(v => typeof v === 'string' || typeof v === 'number' ||\n                                           typeof v === 'boolean' || v === null ||\n                                           (isObject(v) && (v instanceof Date || v instanceof Counter || v instanceof Int ||\n                                                            v instanceof Uint || v instanceof Float64)))\n    const allValueDescriptions = allPrimitive ? values.map(v => this.getValueDescription(v)) : []\n    const allDatatypesSame = allValueDescriptions.every(t => t.datatype === allValueDescriptions[0].datatype)\n\n    if (allPrimitive && allDatatypesSame && values.length > 1) {\n      const nextElemId = this.nextOpId()\n      const datatype = allValueDescriptions[0].datatype\n      const values = allValueDescriptions.map(v => v.value)\n      const op = {action: 'set', obj: subpatch.objectId, elemId, insert: true, values, pred: []}\n      const edit = {action: 'multi-insert', elemId: nextElemId, index, values}\n      if (datatype) {\n        op.datatype = datatype\n        edit.datatype = datatype\n      }\n      this.addOp(op)\n      subpatch.edits.push(edit)\n    } else {\n      for (let offset = 0; offset < values.length; offset++) {\n        let nextElemId = this.nextOpId()\n        const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true, [], elemId)\n        elemId = nextElemId\n        subpatch.edits.push({action: 'insert', index: index + offset, elemId, opId: elemId, value: valuePatch})\n      }\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, replacing the current value at\n   * position `index` with the new value `value`.\n   */\n  setListIndex(path, index, value) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const list = this.getObject(objectId)\n\n    // Assignment past the end of the list => insert nulls followed by new value\n    if (index >= list.length) {\n      const insertions = createArrayOfNulls(index - list.length)\n      insertions.push(value)\n      return this.splice(path, list.length, 0, insertions)\n    }\n    if (list[index] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned list element value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(list, index)\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, index, value, false, pred, getElemId(list, index))\n        subpatch.edits.push({action: 'update', index, opId, value: valuePatch})\n      })\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, deleting `deletions` list elements starting from\n   * list index `start`, and inserting the list of new elements `insertions` at that position.\n   */\n  splice(path, start, deletions, insertions) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    let list = this.getObject(objectId)\n    if (start < 0 || deletions < 0 || start > list.length - deletions) {\n      throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`)\n    }\n    if (deletions === 0 && insertions.length === 0) return\n\n    let patch = {diffs: {objectId: '_root', type: 'map', props: {}}}\n    let subpatch = this.getSubpatch(patch.diffs, path)\n\n    if (deletions > 0) {\n      let op, lastElemParsed, lastPredParsed\n      for (let i = 0; i < deletions; i++) {\n        if (this.getObjectField(path, objectId, start + i) instanceof Counter) {\n          // This may seem bizarre, but it's really fiddly to implement deletion of counters from\n          // lists, and I doubt anyone ever needs to do this, so I'm just going to throw an\n          // exception for now. The reason is: a counter is created by a set operation with counter\n          // datatype, and subsequent increment ops are successors to the set operation. Normally, a\n          // set operation with successor indicates a value that has been overwritten, so a set\n          // operation with successors is normally invisible. Counters are an exception, because the\n          // increment operations don't make the set operation invisible. When a counter appears in\n          // a map, this is not too bad: if all successors are increments, then the counter remains\n          // visible; if one or more successors are deletions, it goes away. However, when deleting\n          // a list element, we have the additional challenge that we need to distinguish between a\n          // list element that is being deleted by the current change (in which case we need to put\n          // a 'remove' action in the patch's edits for that list) and a list element that was\n          // already deleted previously (in which case the patch should not reflect the deletion).\n          // This can be done, but as I said, it's fiddly. If someone wants to pick this up in the\n          // future, hopefully the above description will be enough to get you started. Good luck!\n          throw new TypeError('Unsupported operation: deleting a counter from a list')\n        }\n\n        // Any sequences of deletions with consecutive elemId and pred values get combined into a\n        // single multiOp; any others become individual deletion operations. This optimisation only\n        // kicks in if the user deletes a sequence of elements at once (in a single call to splice);\n        // it might be nice to also detect such runs of deletions in the case where the user deletes\n        // a sequence of list elements one by one.\n        const thisElem = getElemId(list, start + i), thisElemParsed = parseOpId(thisElem)\n        const thisPred = getPred(list, start + i)\n        const thisPredParsed = (thisPred.length === 1) ? parseOpId(thisPred[0]) : undefined\n\n        if (op && lastElemParsed && lastPredParsed && thisPredParsed &&\n            lastElemParsed.actorId === thisElemParsed.actorId && lastElemParsed.counter + 1 === thisElemParsed.counter &&\n            lastPredParsed.actorId === thisPredParsed.actorId && lastPredParsed.counter + 1 === thisPredParsed.counter) {\n          op.multiOp = (op.multiOp || 1) + 1\n        } else {\n          if (op) this.addOp(op)\n          op = {action: 'del', obj: objectId, elemId: thisElem, insert: false, pred: thisPred}\n        }\n        lastElemParsed = thisElemParsed\n        lastPredParsed = thisPredParsed\n      }\n      this.addOp(op)\n      subpatch.edits.push({action: 'remove', index: start, count: deletions})\n    }\n\n    if (insertions.length > 0) {\n      this.insertListItems(subpatch, start, insertions, false)\n    }\n    this.applyPatch(patch.diffs, this.cache._root, this.updated)\n  }\n\n  /**\n   * Updates the table object at path `path`, adding a new entry `row`.\n   * Returns the objectId of the new row.\n   */\n  addTableRow(path, row) {\n    if (!isObject(row) || Array.isArray(row)) {\n      throw new TypeError('A table row must be an object')\n    }\n    if (row[OBJECT_ID]) {\n      throw new TypeError('Cannot reuse an existing object as table row')\n    }\n    if (row.id) {\n      throw new TypeError('A table row must not have an \"id\" property; it is generated automatically')\n    }\n\n    const id = uuid()\n    const valuePatch = this.setValue(path[path.length - 1].objectId, id, row, false, [])\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[id] = {[valuePatch.objectId]: valuePatch}\n    })\n    return id\n  }\n\n  /**\n   * Updates the table object at path `path`, deleting the row with ID `rowId`.\n   * `pred` is the opId of the operation that originally created the row.\n   */\n  deleteTableRow(path, rowId, pred) {\n    const objectId = path[path.length - 1].objectId, table = this.getObject(objectId)\n\n    if (table.byId(rowId)) {\n      this.addOp({action: 'del', obj: objectId, key: rowId, insert: false, pred: [pred]})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[rowId] = {}\n      })\n    }\n  }\n\n  /**\n   * Adds the integer `delta` to the value of the counter located at property\n   * `key` in the object at path `path`.\n   */\n  increment(path, key, delta) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (!(object[key] instanceof Counter)) {\n      throw new TypeError('Only counter values can be incremented')\n    }\n\n    // TODO what if there is a conflicting value on the same key as the counter?\n    const type = this.getObjectType(objectId)\n    const value = object[key].value + delta\n    const opId = this.nextOpId()\n    const pred = getPred(object, key)\n\n    if (type === 'list' || type === 'text') {\n      const elemId = getElemId(object, key, false)\n      this.addOp({action: 'inc', obj: objectId, elemId, value: delta, insert: false, pred})\n    } else {\n      this.addOp({action: 'inc', obj: objectId, key, value: delta, insert: false, pred})\n    }\n\n    this.applyAtPath(path, subpatch => {\n      if (type === 'list' || type === 'text') {\n        subpatch.edits.push({action: 'update', index: key, opId, value: {value, datatype: 'counter'}})\n      } else {\n        subpatch.props[key] = {[opId]: {value, datatype: 'counter'}}\n      }\n    })\n  }\n}\n\nfunction getPred(object, key) {\n  if (object instanceof Table) {\n    return [object.opIds[key]]\n  } else if (object instanceof Text) {\n    return object.elems[key].pred\n  } else if (object[CONFLICTS]) {\n    return object[CONFLICTS][key] ? Object.keys(object[CONFLICTS][key]) : []\n  } else {\n    return []\n  }\n}\n\nfunction getElemId(list, index, insert = false) {\n  if (insert) {\n    if (index === 0) return '_head'\n    index -= 1\n  }\n  if (list[ELEM_IDS]) return list[ELEM_IDS][index]\n  if (list.getElemId) return list.getElemId(index)\n  throw new RangeError(`Cannot find elemId at list index ${index}`)\n}\n\nmodule.exports = {\n  Context\n}\n"]},"metadata":{},"sourceType":"script"}