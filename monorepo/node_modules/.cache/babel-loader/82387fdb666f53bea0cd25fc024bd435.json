{"ast":null,"code":"const uuid = require('./uuid');\n\nconst Frontend = require('../frontend');\n\nconst {\n  OPTIONS\n} = require('../frontend/constants');\n\nconst {\n  encodeChange,\n  decodeChange\n} = require('../backend/columnar');\n\nconst {\n  isObject\n} = require('./common');\n\nlet backend = require('../backend'); // mutable: can be overridden with setDefaultBackend()\n\n/**\n * Automerge.* API\n * The functions in this file constitute the publicly facing Automerge API which combines\n * the features of the Frontend (a document interface) and the backend (CRDT operations)\n */\n\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {\n      actorId: options\n    };\n  } else if (typeof options === 'undefined') {\n    options = {};\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported options for init(): ${options}`);\n  }\n\n  return Frontend.init(Object.assign({\n    backend\n  }, options));\n}\n/**\n * Returns a new document object initialized with the given state.\n */\n\n\nfunction from(initialState, options) {\n  const changeOpts = {\n    message: 'Initialization'\n  };\n  return change(init(options), changeOpts, doc => Object.assign(doc, initialState));\n}\n\nfunction change(doc, options, callback) {\n  const [newDoc] = Frontend.change(doc, options, callback);\n  return newDoc;\n}\n\nfunction emptyChange(doc, options) {\n  const [newDoc] = Frontend.emptyChange(doc, options);\n  return newDoc;\n}\n\nfunction clone(doc) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const state = backend.clone(Frontend.getBackendState(doc, 'clone'));\n  return applyPatch(init(options), backend.getPatch(state), state, [], options);\n}\n\nfunction free(doc) {\n  backend.free(Frontend.getBackendState(doc, 'free'));\n}\n\nfunction load(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const state = backend.load(data);\n  return applyPatch(init(options), backend.getPatch(state), state, [data], options);\n}\n\nfunction save(doc) {\n  return backend.save(Frontend.getBackendState(doc, 'save'));\n}\n\nfunction merge(localDoc, remoteDoc) {\n  const localState = Frontend.getBackendState(localDoc, 'merge');\n  const remoteState = Frontend.getBackendState(remoteDoc, 'merge', 'second');\n\n  if (Frontend.getActorId(localDoc) === Frontend.getActorId(remoteDoc)) {\n    throw new RangeError('Cannot merge an actor with itself');\n  }\n\n  const changes = backend.getChangesAdded(localState, remoteState);\n  const [updatedDoc] = applyChanges(localDoc, changes);\n  return updatedDoc;\n}\n\nfunction getChanges(oldDoc, newDoc) {\n  const oldState = Frontend.getBackendState(oldDoc, 'getChanges');\n  const newState = Frontend.getBackendState(newDoc, 'getChanges', 'second');\n  return backend.getChanges(newState, backend.getHeads(oldState));\n}\n\nfunction getAllChanges(doc) {\n  return backend.getAllChanges(Frontend.getBackendState(doc, 'getAllChanges'));\n}\n\nfunction applyPatch(doc, patch, backendState, changes, options) {\n  const newDoc = Frontend.applyPatch(doc, patch, backendState);\n  const patchCallback = options.patchCallback || doc[OPTIONS].patchCallback;\n\n  if (patchCallback) {\n    patchCallback(patch, doc, newDoc, false, changes);\n  }\n\n  return newDoc;\n}\n\nfunction applyChanges(doc, changes) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const oldState = Frontend.getBackendState(doc, 'applyChanges');\n  const [newState, patch] = backend.applyChanges(oldState, changes);\n  return [applyPatch(doc, patch, newState, changes, options), patch];\n}\n\nfunction equals(val1, val2) {\n  if (!isObject(val1) || !isObject(val2)) return val1 === val2;\n  const keys1 = Object.keys(val1).sort(),\n        keys2 = Object.keys(val2).sort();\n  if (keys1.length !== keys2.length) return false;\n\n  for (let i = 0; i < keys1.length; i++) {\n    if (keys1[i] !== keys2[i]) return false;\n    if (!equals(val1[keys1[i]], val2[keys2[i]])) return false;\n  }\n\n  return true;\n}\n\nfunction getHistory(doc) {\n  const actor = Frontend.getActorId(doc);\n  const history = getAllChanges(doc);\n  return history.map((change, index) => ({\n    get change() {\n      return decodeChange(change);\n    },\n\n    get snapshot() {\n      const state = backend.loadChanges(backend.init(), history.slice(0, index + 1));\n      return Frontend.applyPatch(init(actor), backend.getPatch(state), state);\n    }\n\n  }));\n}\n\nfunction generateSyncMessage(doc, syncState) {\n  const state = Frontend.getBackendState(doc, 'generateSyncMessage');\n  return backend.generateSyncMessage(state, syncState);\n}\n\nfunction receiveSyncMessage(doc, oldSyncState, message) {\n  const oldBackendState = Frontend.getBackendState(doc, 'receiveSyncMessage');\n  const [backendState, syncState, patch] = backend.receiveSyncMessage(oldBackendState, oldSyncState, message);\n  if (!patch) return [doc, syncState, patch]; // The patchCallback is passed as argument all changes that are applied.\n  // We get those from the sync message if a patchCallback is present.\n\n  let changes = null;\n\n  if (doc[OPTIONS].patchCallback) {\n    changes = backend.decodeSyncMessage(message).changes;\n  }\n\n  return [applyPatch(doc, patch, backendState, changes, {}), syncState, patch];\n}\n\nfunction initSyncState() {\n  return backend.initSyncState();\n}\n/**\n * Replaces the default backend implementation with a different one.\n * This allows you to switch to using the Rust/WebAssembly implementation.\n */\n\n\nfunction setDefaultBackend(newBackend) {\n  backend = newBackend;\n}\n\nmodule.exports = {\n  init,\n  from,\n  change,\n  emptyChange,\n  clone,\n  free,\n  load,\n  save,\n  merge,\n  getChanges,\n  getAllChanges,\n  applyChanges,\n  encodeChange,\n  decodeChange,\n  equals,\n  getHistory,\n  uuid,\n  Frontend,\n  setDefaultBackend,\n  generateSyncMessage,\n  receiveSyncMessage,\n  initSyncState,\n\n  get Backend() {\n    return backend;\n  }\n\n};\n\nfor (let name of ['getObjectId', 'getObjectById', 'getActorId', 'setActorId', 'getConflicts', 'getLastLocalChange', 'Text', 'Table', 'Counter', 'Observable', 'Int', 'Uint', 'Float64']) {\n  module.exports[name] = Frontend[name];\n}","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/src/automerge.js"],"names":["uuid","require","Frontend","OPTIONS","encodeChange","decodeChange","isObject","backend","init","options","actorId","TypeError","Object","assign","from","initialState","changeOpts","message","change","doc","callback","newDoc","emptyChange","clone","state","getBackendState","applyPatch","getPatch","free","load","data","save","merge","localDoc","remoteDoc","localState","remoteState","getActorId","RangeError","changes","getChangesAdded","updatedDoc","applyChanges","getChanges","oldDoc","oldState","newState","getHeads","getAllChanges","patch","backendState","patchCallback","equals","val1","val2","keys1","keys","sort","keys2","length","i","getHistory","actor","history","map","index","snapshot","loadChanges","slice","generateSyncMessage","syncState","receiveSyncMessage","oldSyncState","oldBackendState","decodeSyncMessage","initSyncState","setDefaultBackend","newBackend","module","exports","Backend","name"],"mappings":"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","sourcesContent":["const uuid = require('./uuid')\nconst Frontend = require('../frontend')\nconst { OPTIONS } = require('../frontend/constants')\nconst { encodeChange, decodeChange } = require('../backend/columnar')\nconst { isObject } = require('./common')\nlet backend = require('../backend') // mutable: can be overridden with setDefaultBackend()\n\n/**\n * Automerge.* API\n * The functions in this file constitute the publicly facing Automerge API which combines\n * the features of the Frontend (a document interface) and the backend (CRDT operations)\n */\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported options for init(): ${options}`)\n  }\n  return Frontend.init(Object.assign({backend}, options))\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  const changeOpts = {message: 'Initialization'}\n  return change(init(options), changeOpts, doc => Object.assign(doc, initialState))\n}\n\nfunction change(doc, options, callback) {\n  const [newDoc] = Frontend.change(doc, options, callback)\n  return newDoc\n}\n\nfunction emptyChange(doc, options) {\n  const [newDoc] = Frontend.emptyChange(doc, options)\n  return newDoc\n}\n\nfunction clone(doc, options = {}) {\n  const state = backend.clone(Frontend.getBackendState(doc, 'clone'))\n  return applyPatch(init(options), backend.getPatch(state), state, [], options)\n}\n\nfunction free(doc) {\n  backend.free(Frontend.getBackendState(doc, 'free'))\n}\n\nfunction load(data, options = {}) {\n  const state = backend.load(data)\n  return applyPatch(init(options), backend.getPatch(state), state, [data], options)\n}\n\nfunction save(doc) {\n  return backend.save(Frontend.getBackendState(doc, 'save'))\n}\n\nfunction merge(localDoc, remoteDoc) {\n  const localState = Frontend.getBackendState(localDoc, 'merge')\n  const remoteState = Frontend.getBackendState(remoteDoc, 'merge', 'second')\n  if (Frontend.getActorId(localDoc) === Frontend.getActorId(remoteDoc)) {\n    throw new RangeError('Cannot merge an actor with itself')\n  }\n  const changes = backend.getChangesAdded(localState, remoteState)\n  const [updatedDoc] = applyChanges(localDoc, changes)\n  return updatedDoc\n}\n\nfunction getChanges(oldDoc, newDoc) {\n  const oldState = Frontend.getBackendState(oldDoc, 'getChanges')\n  const newState = Frontend.getBackendState(newDoc, 'getChanges', 'second')\n  return backend.getChanges(newState, backend.getHeads(oldState))\n}\n\nfunction getAllChanges(doc) {\n  return backend.getAllChanges(Frontend.getBackendState(doc, 'getAllChanges'))\n}\n\nfunction applyPatch(doc, patch, backendState, changes, options) {\n  const newDoc = Frontend.applyPatch(doc, patch, backendState)\n  const patchCallback = options.patchCallback || doc[OPTIONS].patchCallback\n  if (patchCallback) {\n    patchCallback(patch, doc, newDoc, false, changes)\n  }\n  return newDoc\n}\n\nfunction applyChanges(doc, changes, options = {}) {\n  const oldState = Frontend.getBackendState(doc, 'applyChanges')\n  const [newState, patch] = backend.applyChanges(oldState, changes)\n  return [applyPatch(doc, patch, newState, changes, options), patch]\n}\n\nfunction equals(val1, val2) {\n  if (!isObject(val1) || !isObject(val2)) return val1 === val2\n  const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort()\n  if (keys1.length !== keys2.length) return false\n  for (let i = 0; i < keys1.length; i++) {\n    if (keys1[i] !== keys2[i]) return false\n    if (!equals(val1[keys1[i]], val2[keys2[i]])) return false\n  }\n  return true\n}\n\nfunction getHistory(doc) {\n  const actor = Frontend.getActorId(doc)\n  const history = getAllChanges(doc)\n  return history.map((change, index) => ({\n      get change () {\n        return decodeChange(change)\n      },\n      get snapshot () {\n        const state = backend.loadChanges(backend.init(), history.slice(0, index + 1))\n        return Frontend.applyPatch(init(actor), backend.getPatch(state), state)\n      }\n    })\n  )\n}\n\nfunction generateSyncMessage(doc, syncState) {\n  const state = Frontend.getBackendState(doc, 'generateSyncMessage')\n  return backend.generateSyncMessage(state, syncState)\n}\n\nfunction receiveSyncMessage(doc, oldSyncState, message) {\n  const oldBackendState = Frontend.getBackendState(doc, 'receiveSyncMessage')\n  const [backendState, syncState, patch] = backend.receiveSyncMessage(oldBackendState, oldSyncState, message)\n  if (!patch) return [doc, syncState, patch]\n\n  // The patchCallback is passed as argument all changes that are applied.\n  // We get those from the sync message if a patchCallback is present.\n  let changes = null\n  if (doc[OPTIONS].patchCallback) {\n    changes = backend.decodeSyncMessage(message).changes\n  }\n  return [applyPatch(doc, patch, backendState, changes, {}), syncState, patch]\n}\n\nfunction initSyncState() {\n  return backend.initSyncState()\n}\n\n/**\n * Replaces the default backend implementation with a different one.\n * This allows you to switch to using the Rust/WebAssembly implementation.\n */\nfunction setDefaultBackend(newBackend) {\n  backend = newBackend\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, clone, free,\n  load, save, merge, getChanges, getAllChanges, applyChanges,\n  encodeChange, decodeChange, equals, getHistory, uuid,\n  Frontend, setDefaultBackend, generateSyncMessage, receiveSyncMessage, initSyncState,\n  get Backend() { return backend }\n}\n\nfor (let name of ['getObjectId', 'getObjectById', 'getActorId',\n     'setActorId', 'getConflicts', 'getLastLocalChange',\n     'Text', 'Table', 'Counter', 'Observable', 'Int', 'Uint', 'Float64']) {\n  module.exports[name] = Frontend[name]\n}\n"]},"metadata":{},"sourceType":"script"}