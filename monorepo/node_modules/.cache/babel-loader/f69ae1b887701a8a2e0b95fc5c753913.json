{"ast":null,"code":"/**\n * UTF-8 decoding and encoding using API that is supported in Node >= 12 and modern browsers:\n * https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode\n * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode\n * If you're running in an environment where it's not available, please use a polyfill, such as:\n * https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n */\nconst utf8encoder = new TextEncoder();\nconst utf8decoder = new TextDecoder('utf-8');\n\nfunction stringToUtf8(string) {\n  return utf8encoder.encode(string);\n}\n\nfunction utf8ToString(buffer) {\n  return utf8decoder.decode(buffer);\n}\n/**\n * Converts a string consisting of hexadecimal digits into an Uint8Array.\n */\n\n\nfunction hexStringToBytes(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('value is not a string');\n  }\n\n  if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {\n    throw new RangeError('value is not hexadecimal');\n  }\n\n  if (value === '') {\n    return new Uint8Array(0);\n  } else {\n    return new Uint8Array(value.match(/../g).map(b => parseInt(b, 16)));\n  }\n}\n\nconst NIBBLE_TO_HEX = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nconst BYTE_TO_HEX = new Array(256);\n\nfor (let i = 0; i < 256; i++) {\n  BYTE_TO_HEX[i] = `${NIBBLE_TO_HEX[i >>> 4 & 0xf]}${NIBBLE_TO_HEX[i & 0xf]}`;\n}\n/**\n * Converts a Uint8Array into the equivalent hexadecimal string.\n */\n\n\nfunction bytesToHexString(bytes) {\n  let hex = '',\n      len = bytes.byteLength;\n\n  for (let i = 0; i < len; i++) {\n    hex += BYTE_TO_HEX[bytes[i]];\n  }\n\n  return hex;\n}\n/**\n * Wrapper around an Uint8Array that allows values to be appended to the buffer,\n * and that automatically grows the buffer when space runs out.\n */\n\n\nclass Encoder {\n  constructor() {\n    this.buf = new Uint8Array(16);\n    this.offset = 0;\n  }\n  /**\n   * Returns the byte array containing the encoded data.\n   */\n\n\n  get buffer() {\n    this.finish();\n    return this.buf.subarray(0, this.offset);\n  }\n  /**\n   * Reallocates the encoder's buffer to be bigger.\n   */\n\n\n  grow() {\n    let minSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let newSize = this.buf.byteLength * 4;\n\n    while (newSize < minSize) newSize *= 2;\n\n    const newBuf = new Uint8Array(newSize);\n    newBuf.set(this.buf, 0);\n    this.buf = newBuf;\n    return this;\n  }\n  /**\n   * Appends one byte (0 to 255) to the buffer.\n   */\n\n\n  appendByte(value) {\n    if (this.offset >= this.buf.byteLength) this.grow();\n    this.buf[this.offset] = value;\n    this.offset += 1;\n  }\n  /**\n   * Encodes a 32-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and\n   * appends it to the buffer. Returns the number of bytes written.\n   */\n\n\n  appendUint32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n    if (value < 0 || value > 0xffffffff) throw new RangeError('number out of range');\n    const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7));\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = value & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      value >>>= 7; // zero-filling right shift\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a 32-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends\n   * it to the buffer. Returns the number of bytes written.\n   */\n\n\n  appendInt32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n    if (value < -0x80000000 || value > 0x7fffffff) throw new RangeError('number out of range');\n    const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = value & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      value >>= 7; // sign-propagating right shift\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a nonnegative integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n\n\n  appendUint53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n\n    if (value < 0 || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range');\n    }\n\n    const high32 = Math.floor(value / 0x100000000);\n    const low32 = (value & 0xffffffff) >>> 0; // right shift to interpret as unsigned\n\n    return this.appendUint64(high32, low32);\n  }\n  /**\n   * Encodes a signed integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n\n\n  appendInt53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer');\n\n    if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range');\n    }\n\n    const high32 = Math.floor(value / 0x100000000);\n    const low32 = (value & 0xffffffff) >>> 0; // right shift to interpret as unsigned\n\n    return this.appendInt64(high32, low32);\n  }\n  /**\n   * Encodes a 64-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme, and appends it to the buffer. The number is\n   * given as two 32-bit halves since JavaScript cannot accurately represent\n   * integers with more than 53 bits in a single variable.\n   */\n\n\n  appendUint64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer');\n    }\n\n    if (high32 < 0 || high32 > 0xffffffff || low32 < 0 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range');\n    }\n\n    if (high32 === 0) return this.appendUint32(low32);\n    const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = low32 & 0x7f | 0x80;\n      low32 >>>= 7; // zero-filling right shift\n    }\n\n    this.buf[this.offset + 4] = low32 & 0x0f | (high32 & 0x07) << 4 | (numBytes === 5 ? 0x00 : 0x80);\n    high32 >>>= 3;\n\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = high32 & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      high32 >>>= 7;\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Encodes a 64-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme, and appends it to the buffer. The number is given\n   * as two 32-bit halves since JavaScript cannot accurately represent integers\n   * with more than 53 bits in a single variable. The sign of the 64-bit\n   * number is determined by the sign of the `high32` half; the sign of the\n   * `low32` half is ignored.\n   */\n\n\n  appendInt64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer');\n    }\n\n    if (high32 < -0x80000000 || high32 > 0x7fffffff || low32 < -0x80000000 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range');\n    }\n\n    low32 >>>= 0; // interpret as unsigned\n\n    if (high32 === 0 && low32 <= 0x7fffffff) return this.appendInt32(low32);\n    if (high32 === -1 && low32 >= 0x80000000) return this.appendInt32(low32 - 0x100000000);\n    const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7);\n    if (this.offset + numBytes > this.buf.byteLength) this.grow();\n\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = low32 & 0x7f | 0x80;\n      low32 >>>= 7; // zero-filling right shift\n    }\n\n    this.buf[this.offset + 4] = low32 & 0x0f | (high32 & 0x07) << 4 | (numBytes === 5 ? 0x00 : 0x80);\n    high32 >>= 3; // sign-propagating right shift\n\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = high32 & 0x7f | (i === numBytes - 1 ? 0x00 : 0x80);\n      high32 >>= 7;\n    }\n\n    this.offset += numBytes;\n    return numBytes;\n  }\n  /**\n   * Appends the contents of byte buffer `data` to the buffer. Returns the\n   * number of bytes appended.\n   */\n\n\n  appendRawBytes(data) {\n    if (this.offset + data.byteLength > this.buf.byteLength) {\n      this.grow(this.offset + data.byteLength);\n    }\n\n    this.buf.set(data, this.offset);\n    this.offset += data.byteLength;\n    return data.byteLength;\n  }\n  /**\n   * Appends a UTF-8 string to the buffer, without any metadata. Returns the\n   * number of bytes appended.\n   */\n\n\n  appendRawString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string');\n    return this.appendRawBytes(stringToUtf8(value));\n  }\n  /**\n   * Appends the contents of byte buffer `data` to the buffer, prefixed with the\n   * number of bytes in the buffer (as a LEB128-encoded unsigned integer).\n   */\n\n\n  appendPrefixedBytes(data) {\n    this.appendUint53(data.byteLength);\n    this.appendRawBytes(data);\n    return this;\n  }\n  /**\n   * Appends a UTF-8 string to the buffer, prefixed with its length in bytes\n   * (where the length is encoded as an unsigned LEB128 integer).\n   */\n\n\n  appendPrefixedString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string');\n    this.appendPrefixedBytes(stringToUtf8(value));\n    return this;\n  }\n  /**\n   * Takes a value, which must be a string consisting only of hexadecimal\n   * digits, maps it to a byte array, and appends it to the buffer, prefixed\n   * with its length in bytes.\n   */\n\n\n  appendHexString(value) {\n    this.appendPrefixedBytes(hexStringToBytes(value));\n    return this;\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {}\n\n}\n/**\n * Counterpart to Encoder. Wraps a Uint8Array buffer with a cursor indicating\n * the current decoding position, and allows values to be incrementally read by\n * decoding the bytes at the current position.\n */\n\n\nclass Decoder {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw new TypeError(`Not a byte array: ${buffer}`);\n    }\n\n    this.buf = buffer;\n    this.offset = 0;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n  }\n  /**\n   * Moves the current decoding position forward by the specified number of\n   * bytes, without decoding anything.\n   */\n\n\n  skip(bytes) {\n    if (this.offset + bytes > this.buf.byteLength) {\n      throw new RangeError('cannot skip beyond end of buffer');\n    }\n\n    this.offset += bytes;\n  }\n  /**\n   * Reads one byte (0 to 255) from the buffer.\n   */\n\n\n  readByte() {\n    this.offset += 1;\n    return this.buf[this.offset - 1];\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit unsigned int.\n   */\n\n\n  readUint32() {\n    let result = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 28 && (nextByte & 0xf0) !== 0) {\n        // more than 5 bytes, or value > 0xffffffff\n        throw new RangeError('number out of range');\n      }\n\n      result = (result | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return result;\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit signed int.\n   */\n\n\n  readInt32() {\n    let result = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 28 && (nextByte & 0x80) !== 0 || // more than 5 bytes\n      shift === 28 && (nextByte & 0x40) === 0 && (nextByte & 0x38) !== 0 || // positive int > 0x7fffffff\n      shift === 28 && (nextByte & 0x40) !== 0 && (nextByte & 0x38) !== 0x38) {\n        // negative int < -0x80000000\n        throw new RangeError('number out of range');\n      }\n\n      result |= (nextByte & 0x7f) << shift;\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) === 0 || shift > 28) {\n          return result; // positive, or negative value that doesn't need sign-extending\n        } else {\n          return result | -1 << shift; // sign-extend negative integer\n        }\n      }\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (up to 2^53 - 1), and throws an exception outside of that range.\n   */\n\n\n  readUint53() {\n    const {\n      low32,\n      high32\n    } = this.readUint64();\n\n    if (high32 < 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range');\n    }\n\n    return high32 * 0x100000000 + low32;\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.\n   */\n\n\n  readInt53() {\n    const {\n      low32,\n      high32\n    } = this.readInt64();\n\n    if (high32 < -0x200000 || high32 === -0x200000 && low32 === 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range');\n    }\n\n    return high32 * 0x100000000 + low32;\n  }\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`.\n   */\n\n\n  readUint64() {\n    let low32 = 0,\n        high32 = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset];\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4;\n      }\n\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return {\n        high32,\n        low32\n      };\n    }\n\n    shift = 3;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset];\n\n      if (shift === 31 && (nextByte & 0xfe) !== 0) {\n        // more than 10 bytes, or value > 2^64 - 1\n        throw new RangeError('number out of range');\n      }\n\n      high32 = (high32 | (nextByte & 0x7f) << shift) >>> 0;\n      shift += 7;\n      this.offset++;\n      if ((nextByte & 0x80) === 0) return {\n        high32,\n        low32\n      };\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit signed\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`. The `low32` half is always non-negative, and the\n   * sign of the `high32` half indicates the sign of the 64-bit number.\n   */\n\n\n  readInt64() {\n    let low32 = 0,\n        high32 = 0,\n        shift = 0;\n\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset];\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0; // right shift to interpret value as unsigned\n\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4;\n      }\n\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0) {\n          // sign-extend negative integer\n          if (shift < 32) low32 = (low32 | -1 << shift) >>> 0;\n          high32 |= -1 << Math.max(shift - 32, 0);\n        }\n\n        return {\n          high32,\n          low32\n        };\n      }\n    }\n\n    shift = 3;\n\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]; // On the 10th byte there are only two valid values: all 7 value bits zero\n      // (if the value is positive) or all 7 bits one (if the value is negative)\n\n      if (shift === 31 && nextByte !== 0 && nextByte !== 0x7f) {\n        throw new RangeError('number out of range');\n      }\n\n      high32 |= (nextByte & 0x7f) << shift;\n      shift += 7;\n      this.offset++;\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0 && shift < 32) {\n          // sign-extend negative integer\n          high32 |= -1 << shift;\n        }\n\n        return {\n          high32,\n          low32\n        };\n      }\n    }\n\n    throw new RangeError('buffer ended with incomplete number');\n  }\n  /**\n   * Extracts a subarray `length` bytes in size, starting from the current\n   * position in the buffer, and moves the position forward.\n   */\n\n\n  readRawBytes(length) {\n    const start = this.offset;\n\n    if (start + length > this.buf.byteLength) {\n      throw new RangeError('subarray exceeds buffer size');\n    }\n\n    this.offset += length;\n    return this.buf.subarray(start, this.offset);\n  }\n  /**\n   * Extracts `length` bytes from the buffer, starting from the current position,\n   * and returns the UTF-8 string decoding of those bytes.\n   */\n\n\n  readRawString(length) {\n    return utf8ToString(this.readRawBytes(length));\n  }\n  /**\n   * Extracts a subarray from the current position in the buffer, prefixed with\n   * its length in bytes (encoded as an unsigned LEB128 integer).\n   */\n\n\n  readPrefixedBytes() {\n    return this.readRawBytes(this.readUint53());\n  }\n  /**\n   * Reads a UTF-8 string from the current position in the buffer, prefixed with its\n   * length in bytes (where the length is encoded as an unsigned LEB128 integer).\n   */\n\n\n  readPrefixedString() {\n    return utf8ToString(this.readPrefixedBytes());\n  }\n  /**\n   * Reads a byte array from the current position in the buffer, prefixed with its\n   * length in bytes. Returns that byte array converted to a hexadecimal string.\n   */\n\n\n  readHexString() {\n    return bytesToHexString(this.readPrefixedBytes());\n  }\n\n}\n/**\n * An encoder that uses run-length encoding to compress sequences of repeated\n * values. The constructor argument specifies the type of values, which may be\n * either 'int', 'uint', or 'utf8'. Besides valid values of the selected\n * datatype, values may also be null.\n *\n * The encoded buffer starts with a LEB128-encoded signed integer, the\n * repetition count. The interpretation of the following values depends on this\n * repetition count:\n *   - If this number is a positive value n, the next value in the buffer\n *     (encoded as the specified datatype) is repeated n times in the sequence.\n *   - If the repetition count is a negative value -n, then the next n values\n *     (encoded as the specified datatype) in the buffer are treated as a\n *     literal, i.e. they appear in the sequence without any further\n *     interpretation or repetition.\n *   - If the repetition count is zero, then the next value in the buffer is a\n *     LEB128-encoded unsigned integer indicating the number of null values\n *     that appear at the current position in the sequence.\n *\n * After one of these three has completed, the process repeats, starting again\n * with a repetition count, until we reach the end of the buffer.\n */\n\n\nclass RLEEncoder extends Encoder {\n  constructor(type) {\n    super();\n    this.type = type;\n    this.state = 'empty';\n    this.lastValue = undefined;\n    this.count = 0;\n    this.literal = [];\n  }\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value) {\n    let repetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    this._appendValue(value, repetitions);\n  }\n  /**\n   * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.\n   */\n\n\n  _appendValue(value) {\n    let repetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (repetitions <= 0) return;\n\n    if (this.state === 'empty') {\n      this.state = value === null ? 'nulls' : repetitions === 1 ? 'loneValue' : 'repetition';\n      this.lastValue = value;\n      this.count = repetitions;\n    } else if (this.state === 'loneValue') {\n      if (value === null) {\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.state = 'repetition';\n        this.count = 1 + repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.state = 'literal';\n        this.literal = [this.lastValue];\n        this.lastValue = value;\n      }\n    } else if (this.state === 'repetition') {\n      if (value === null) {\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.count += repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.flush();\n        this.state = 'loneValue';\n        this.lastValue = value;\n      }\n    } else if (this.state === 'literal') {\n      if (value === null) {\n        this.literal.push(this.lastValue);\n        this.flush();\n        this.state = 'nulls';\n        this.count = repetitions;\n      } else if (value === this.lastValue) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = 1 + repetitions;\n      } else if (repetitions > 1) {\n        this.literal.push(this.lastValue);\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.literal.push(this.lastValue);\n        this.lastValue = value;\n      }\n    } else if (this.state === 'nulls') {\n      if (value === null) {\n        this.count += repetitions;\n      } else if (repetitions > 1) {\n        this.flush();\n        this.state = 'repetition';\n        this.count = repetitions;\n        this.lastValue = value;\n      } else {\n        this.flush();\n        this.state = 'loneValue';\n        this.lastValue = value;\n      }\n    }\n  }\n  /**\n   * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may\n   * contain the following keys:\n   *  - `count`: The number of values to copy. If not specified, copies all remaining values.\n   *  - `sumValues`: If true, the function computes the sum of all numeric values as they are\n   *    copied (null values are counted as zero), and returns that number.\n   *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.\n   *\n   * Returns an object of the form `{nonNullValues, sum}` where `nonNullValues` is the number of\n   * non-null values copied, and `sum` is the sum (only if the `sumValues` option is set).\n   */\n\n\n  copyFrom(decoder) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      count,\n      sumValues,\n      sumShift\n    } = options;\n\n    if (!(decoder instanceof RLEDecoder) || decoder.type !== this.type) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    let remaining = typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER;\n    let nonNullValues = 0,\n        sum = 0;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    }; // Copy a value so that we have a well-defined starting state. NB: when super.copyFrom() is\n    // called by the DeltaEncoder subclass, the following calls to readValue() and appendValue()\n    // refer to the overridden methods, while later readRecord(), readRawValue() and _appendValue()\n    // calls refer to the non-overridden RLEDecoder/RLEEncoder methods.\n\n    let firstValue = decoder.readValue();\n\n    if (firstValue === null) {\n      const numNulls = Math.min(decoder.count + 1, remaining);\n      remaining -= numNulls;\n      decoder.count -= numNulls - 1;\n      this.appendValue(null, numNulls);\n      if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n      if (remaining === 0 || decoder.done) return sumValues ? {\n        nonNullValues,\n        sum\n      } : {\n        nonNullValues\n      };\n      firstValue = decoder.readValue();\n      if (firstValue === null) throw new RangeError('null run must be followed by non-null value');\n    }\n\n    this.appendValue(firstValue);\n    remaining--;\n    nonNullValues++;\n    if (sumValues) sum += sumShift ? firstValue >>> sumShift : firstValue;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    }; // Copy data at the record level without expanding repetitions\n\n    let firstRun = decoder.count > 0;\n\n    while (remaining > 0 && !decoder.done) {\n      if (!firstRun) decoder.readRecord();\n      const numValues = Math.min(decoder.count, remaining);\n      decoder.count -= numValues;\n\n      if (decoder.state === 'literal') {\n        nonNullValues += numValues;\n\n        for (let i = 0; i < numValues; i++) {\n          if (decoder.done) throw new RangeError('incomplete literal');\n          const value = decoder.readRawValue();\n          if (value === decoder.lastValue) throw new RangeError('Repetition of values is not allowed in literal');\n          decoder.lastValue = value;\n\n          this._appendValue(value);\n\n          if (sumValues) sum += sumShift ? value >>> sumShift : value;\n        }\n      } else if (decoder.state === 'repetition') {\n        nonNullValues += numValues;\n        if (sumValues) sum += numValues * (sumShift ? decoder.lastValue >>> sumShift : decoder.lastValue);\n        const value = decoder.lastValue;\n\n        this._appendValue(value);\n\n        if (numValues > 1) {\n          this._appendValue(value);\n\n          if (this.state !== 'repetition') throw new RangeError(`Unexpected state ${this.state}`);\n          this.count += numValues - 2;\n        }\n      } else if (decoder.state === 'nulls') {\n        this._appendValue(null);\n\n        if (this.state !== 'nulls') throw new RangeError(`Unexpected state ${this.state}`);\n        this.count += numValues - 1;\n      }\n\n      firstRun = false;\n      remaining -= numValues;\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    return sumValues ? {\n      nonNullValues,\n      sum\n    } : {\n      nonNullValues\n    };\n  }\n  /**\n   * Private method, do not call from outside the class.\n   */\n\n\n  flush() {\n    if (this.state === 'loneValue') {\n      this.appendInt32(-1);\n      this.appendRawValue(this.lastValue);\n    } else if (this.state === 'repetition') {\n      this.appendInt53(this.count);\n      this.appendRawValue(this.lastValue);\n    } else if (this.state === 'literal') {\n      this.appendInt53(-this.literal.length);\n\n      for (let v of this.literal) this.appendRawValue(v);\n    } else if (this.state === 'nulls') {\n      this.appendInt32(0);\n      this.appendUint53(this.count);\n    }\n\n    this.state = 'empty';\n  }\n  /**\n   * Private method, do not call from outside the class.\n   */\n\n\n  appendRawValue(value) {\n    if (this.type === 'int') {\n      this.appendInt53(value);\n    } else if (this.type === 'uint') {\n      this.appendUint53(value);\n    } else if (this.type === 'utf8') {\n      this.appendPrefixedString(value);\n    } else {\n      throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`);\n    }\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {\n    if (this.state === 'literal') this.literal.push(this.lastValue); // Don't write anything if the only values we have seen are nulls\n\n    if (this.state !== 'nulls' || this.offset > 0) this.flush();\n  }\n\n}\n/**\n * Counterpart to RLEEncoder: reads values from an RLE-compressed sequence,\n * returning nulls and repeated values as required.\n */\n\n\nclass RLEDecoder extends Decoder {\n  constructor(type, buffer) {\n    super(buffer);\n    this.type = type;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.count === 0 && this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n  }\n  /**\n   * Returns the next value (or null) in the sequence.\n   */\n\n\n  readValue() {\n    if (this.done) return null;\n    if (this.count === 0) this.readRecord();\n    this.count -= 1;\n\n    if (this.state === 'literal') {\n      const value = this.readRawValue();\n      if (value === this.lastValue) throw new RangeError('Repetition of values is not allowed in literal');\n      this.lastValue = value;\n      return value;\n    } else {\n      return this.lastValue;\n    }\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readInt53();\n\n        if (this.count > 0) {\n          this.lastValue = this.count <= numSkip ? this.skipRawValues(1) : this.readRawValue();\n          this.state = 'repetition';\n        } else if (this.count < 0) {\n          this.count = -this.count;\n          this.state = 'literal';\n        } else {\n          // this.count == 0\n          this.count = this.readUint53();\n          this.lastValue = null;\n          this.state = 'nulls';\n        }\n      }\n\n      const consume = Math.min(numSkip, this.count);\n      if (this.state === 'literal') this.skipRawValues(consume);\n      numSkip -= consume;\n      this.count -= consume;\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Reads a repetition count from the buffer and sets up the state appropriately.\n   */\n\n\n  readRecord() {\n    this.count = this.readInt53();\n\n    if (this.count > 1) {\n      const value = this.readRawValue();\n\n      if ((this.state === 'repetition' || this.state === 'literal') && this.lastValue === value) {\n        throw new RangeError('Successive repetitions with the same value are not allowed');\n      }\n\n      this.state = 'repetition';\n      this.lastValue = value;\n    } else if (this.count === 1) {\n      throw new RangeError('Repetition count of 1 is not allowed, use a literal instead');\n    } else if (this.count < 0) {\n      this.count = -this.count;\n      if (this.state === 'literal') throw new RangeError('Successive literals are not allowed');\n      this.state = 'literal';\n    } else {\n      // this.count == 0\n      if (this.state === 'nulls') throw new RangeError('Successive null runs are not allowed');\n      this.count = this.readUint53();\n      if (this.count === 0) throw new RangeError('Zero-length null runs are not allowed');\n      this.lastValue = null;\n      this.state = 'nulls';\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Reads one value of the datatype configured on construction.\n   */\n\n\n  readRawValue() {\n    if (this.type === 'int') {\n      return this.readInt53();\n    } else if (this.type === 'uint') {\n      return this.readUint53();\n    } else if (this.type === 'utf8') {\n      return this.readPrefixedString();\n    } else {\n      throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`);\n    }\n  }\n  /**\n   * Private method, do not call from outside the class.\n   * Skips over `num` values of the datatype configured on construction.\n   */\n\n\n  skipRawValues(num) {\n    if (this.type === 'utf8') {\n      for (let i = 0; i < num; i++) this.skip(this.readUint53());\n    } else {\n      while (num > 0 && this.offset < this.buf.byteLength) {\n        if ((this.buf[this.offset] & 0x80) === 0) num--;\n        this.offset++;\n      }\n\n      if (num > 0) throw new RangeError('cannot skip beyond end of buffer');\n    }\n  }\n\n}\n/**\n * A variant of RLEEncoder: rather than storing the actual values passed to\n * appendValue(), this version stores only the first value, and for all\n * subsequent values it stores the difference to the previous value. This\n * encoding is good when values tend to come in sequentially incrementing runs,\n * because the delta between successive values is 1, and repeated values of 1\n * are easily compressed with run-length encoding.\n *\n * Null values are also allowed, as with RLEEncoder.\n */\n\n\nclass DeltaEncoder extends RLEEncoder {\n  constructor() {\n    super('int');\n    this.absoluteValue = 0;\n  }\n  /**\n   * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value) {\n    let repetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (repetitions <= 0) return;\n\n    if (typeof value === 'number') {\n      super.appendValue(value - this.absoluteValue, 1);\n      this.absoluteValue = value;\n      if (repetitions > 1) super.appendValue(0, repetitions - 1);\n    } else {\n      super.appendValue(value, repetitions);\n    }\n  }\n  /**\n   * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n\n\n  copyFrom(decoder) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.sumValues) {\n      throw new RangeError('unsupported options for DeltaEncoder.copyFrom()');\n    }\n\n    if (!(decoder instanceof DeltaDecoder)) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    let remaining = options.count;\n    if (remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);\n    if (remaining === 0 || decoder.done) return; // Copy any null values, and the first non-null value, so that appendValue() computes the\n    // difference between the encoder's last value and the decoder's first (absolute) value.\n\n    let value = decoder.readValue(),\n        nulls = 0;\n    this.appendValue(value);\n\n    if (value === null) {\n      nulls = decoder.count + 1;\n      if (remaining !== undefined && remaining < nulls) nulls = remaining;\n      decoder.count -= nulls - 1;\n      this.count += nulls - 1;\n      if (remaining > nulls && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);\n      if (remaining === nulls || decoder.done) return; // The next value read is certain to be non-null because we're not at the end of the decoder,\n      // and a run of nulls must be followed by a run of non-nulls.\n\n      if (decoder.count === 0) this.appendValue(decoder.readValue());\n    } // Once we have the first value, the subsequent relative values can be copied verbatim without\n    // any further processing. Note that the first value copied by super.copyFrom() is an absolute\n    // value, while subsequent values are relative. Thus, the sum of all of the (non-null) copied\n    // values must equal the absolute value of the final element copied.\n\n\n    if (remaining !== undefined) remaining -= nulls + 1;\n    const {\n      nonNullValues,\n      sum\n    } = super.copyFrom(decoder, {\n      count: remaining,\n      sumValues: true\n    });\n\n    if (nonNullValues > 0) {\n      this.absoluteValue = sum;\n      decoder.absoluteValue = sum;\n    }\n  }\n\n}\n/**\n * Counterpart to DeltaEncoder: reads values from a delta-compressed sequence of\n * numbers (may include null values).\n */\n\n\nclass DeltaDecoder extends RLEDecoder {\n  constructor(buffer) {\n    super('int', buffer);\n    this.absoluteValue = 0;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = undefined;\n    this.count = 0;\n    this.state = undefined;\n    this.absoluteValue = 0;\n  }\n  /**\n   * Returns the next integer (or null) value in the sequence.\n   */\n\n\n  readValue() {\n    const value = super.readValue();\n    if (value === null) return null;\n    this.absoluteValue += value;\n    return this.absoluteValue;\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) this.readRecord();\n      const consume = Math.min(numSkip, this.count);\n\n      if (this.state === 'literal') {\n        for (let i = 0; i < consume; i++) {\n          this.lastValue = this.readRawValue();\n          this.absoluteValue += this.lastValue;\n        }\n      } else if (this.state === 'repetition') {\n        this.absoluteValue += consume * this.lastValue;\n      }\n\n      numSkip -= consume;\n      this.count -= consume;\n    }\n  }\n\n}\n/**\n * Encodes a sequence of boolean values by mapping it to a sequence of integers:\n * the number of false values, followed by the number of true values, followed\n * by the number of false values, and so on. Each number is encoded as a LEB128\n * unsigned integer. This encoding is a bit like RLEEncoder, except that we\n * only encode the repetition count but not the actual value, since the values\n * just alternate between false and true (starting with false).\n */\n\n\nclass BooleanEncoder extends Encoder {\n  constructor() {\n    super();\n    this.lastValue = false;\n    this.count = 0;\n  }\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n\n\n  appendValue(value) {\n    let repetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if (value !== false && value !== true) {\n      throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`);\n    }\n\n    if (repetitions <= 0) return;\n\n    if (this.lastValue === value) {\n      this.count += repetitions;\n    } else {\n      this.appendUint53(this.count);\n      this.lastValue = value;\n      this.count = repetitions;\n    }\n  }\n  /**\n   * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n\n\n  copyFrom(decoder) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(decoder instanceof BooleanDecoder)) {\n      throw new TypeError('incompatible type of decoder');\n    }\n\n    const {\n      count\n    } = options;\n    let remaining = typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER;\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n    if (remaining === 0 || decoder.done) return; // Copy one value to bring decoder and encoder state into sync, then finish that value's repetitions\n\n    this.appendValue(decoder.readValue());\n    remaining--;\n    const firstCopy = Math.min(decoder.count, remaining);\n    this.count += firstCopy;\n    decoder.count -= firstCopy;\n    remaining -= firstCopy;\n\n    while (remaining > 0 && !decoder.done) {\n      decoder.count = decoder.readUint53();\n      if (decoder.count === 0) throw new RangeError('Zero-length runs are not allowed');\n      decoder.lastValue = !decoder.lastValue;\n      this.appendUint53(this.count);\n      const numCopied = Math.min(decoder.count, remaining);\n      this.count = numCopied;\n      this.lastValue = decoder.lastValue;\n      decoder.count -= numCopied;\n      remaining -= numCopied;\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);\n  }\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n\n\n  finish() {\n    if (this.count > 0) {\n      this.appendUint53(this.count);\n      this.count = 0;\n    }\n  }\n\n}\n/**\n * Counterpart to BooleanEncoder: reads boolean values from a runlength-encoded\n * sequence.\n */\n\n\nclass BooleanDecoder extends Decoder {\n  constructor(buffer) {\n    super(buffer);\n    this.lastValue = true; // is negated the first time we read a count\n\n    this.firstRun = true;\n    this.count = 0;\n  }\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n\n\n  get done() {\n    return this.count === 0 && this.offset === this.buf.byteLength;\n  }\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.lastValue = true;\n    this.firstRun = true;\n    this.count = 0;\n  }\n  /**\n   * Returns the next value in the sequence.\n   */\n\n\n  readValue() {\n    if (this.done) return false;\n\n    while (this.count === 0) {\n      this.count = this.readUint53();\n      this.lastValue = !this.lastValue;\n\n      if (this.count === 0 && !this.firstRun) {\n        throw new RangeError('Zero-length runs are not allowed');\n      }\n\n      this.firstRun = false;\n    }\n\n    this.count -= 1;\n    return this.lastValue;\n  }\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n\n\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readUint53();\n        this.lastValue = !this.lastValue;\n\n        if (this.count === 0 && !this.firstRun) {\n          throw new RangeError('Zero-length runs are not allowed');\n        }\n\n        this.firstRun = false;\n      }\n\n      if (this.count < numSkip) {\n        numSkip -= this.count;\n        this.count = 0;\n      } else {\n        this.count -= numSkip;\n        numSkip = 0;\n      }\n    }\n  }\n\n}\n\nmodule.exports = {\n  stringToUtf8,\n  utf8ToString,\n  hexStringToBytes,\n  bytesToHexString,\n  Encoder,\n  Decoder,\n  RLEEncoder,\n  RLEDecoder,\n  DeltaEncoder,\n  DeltaDecoder,\n  BooleanEncoder,\n  BooleanDecoder\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/backend/encoding.js"],"names":["utf8encoder","TextEncoder","utf8decoder","TextDecoder","stringToUtf8","string","encode","utf8ToString","buffer","decode","hexStringToBytes","value","TypeError","test","RangeError","Uint8Array","match","map","b","parseInt","NIBBLE_TO_HEX","BYTE_TO_HEX","Array","i","bytesToHexString","bytes","hex","len","byteLength","Encoder","constructor","buf","offset","finish","subarray","grow","minSize","newSize","newBuf","set","appendByte","appendUint32","Number","isInteger","numBytes","Math","max","ceil","clz32","appendInt32","appendUint53","MAX_SAFE_INTEGER","high32","floor","low32","appendUint64","appendInt53","MIN_SAFE_INTEGER","appendInt64","appendRawBytes","data","appendRawString","appendPrefixedBytes","appendPrefixedString","appendHexString","Decoder","done","reset","skip","readByte","readUint32","result","shift","nextByte","readInt32","readUint53","readUint64","readInt53","readInt64","readRawBytes","length","start","readRawString","readPrefixedBytes","readPrefixedString","readHexString","RLEEncoder","type","state","lastValue","undefined","count","literal","appendValue","repetitions","_appendValue","flush","push","copyFrom","decoder","options","sumValues","sumShift","RLEDecoder","remaining","nonNullValues","sum","firstValue","readValue","numNulls","min","firstRun","readRecord","numValues","readRawValue","appendRawValue","v","skipValues","numSkip","skipRawValues","consume","num","DeltaEncoder","absoluteValue","DeltaDecoder","nulls","BooleanEncoder","BooleanDecoder","firstCopy","numCopied","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,WAAW,GAAG,IAAIC,WAAJ,EAApB;AACA,MAAMC,WAAW,GAAG,IAAIC,WAAJ,CAAgB,OAAhB,CAApB;;AAEA,SAASC,YAAT,CAAsBC,MAAtB,EAA8B;AAC5B,SAAOL,WAAW,CAACM,MAAZ,CAAmBD,MAAnB,CAAP;AACD;;AAED,SAASE,YAAT,CAAsBC,MAAtB,EAA8B;AAC5B,SAAON,WAAW,CAACO,MAAZ,CAAmBD,MAAnB,CAAP;AACD;AAED;AACA;AACA;;;AACA,SAASE,gBAAT,CAA0BC,KAA1B,EAAiC;AAC/B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAIC,SAAJ,CAAc,uBAAd,CAAN;AACD;;AACD,MAAI,CAAC,wBAAwBC,IAAxB,CAA6BF,KAA7B,CAAL,EAA0C;AACxC,UAAM,IAAIG,UAAJ,CAAe,0BAAf,CAAN;AACD;;AACD,MAAIH,KAAK,KAAK,EAAd,EAAkB;AAChB,WAAO,IAAII,UAAJ,CAAe,CAAf,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAIA,UAAJ,CAAeJ,KAAK,CAACK,KAAN,CAAY,KAAZ,EAAmBC,GAAnB,CAAuBC,CAAC,IAAIC,QAAQ,CAACD,CAAD,EAAI,EAAJ,CAApC,CAAf,CAAP;AACD;AACF;;AAED,MAAME,aAAa,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,GAAvE,EAA4E,GAA5E,CAAtB;AACA,MAAMC,WAAW,GAAG,IAAIC,KAAJ,CAAU,GAAV,CAApB;;AACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAApB,EAAyBA,CAAC,EAA1B,EAA8B;AAC5BF,EAAAA,WAAW,CAACE,CAAD,CAAX,GAAkB,GAAEH,aAAa,CAAEG,CAAC,KAAK,CAAP,GAAY,GAAb,CAAkB,GAAEH,aAAa,CAACG,CAAC,GAAG,GAAL,CAAU,EAA5E;AACD;AAED;AACA;AACA;;;AACA,SAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC/B,MAAIC,GAAG,GAAG,EAAV;AAAA,MAAcC,GAAG,GAAGF,KAAK,CAACG,UAA1B;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,GAApB,EAAyBJ,CAAC,EAA1B,EAA8B;AAC5BG,IAAAA,GAAG,IAAIL,WAAW,CAACI,KAAK,CAACF,CAAD,CAAN,CAAlB;AACD;;AACD,SAAOG,GAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,MAAMG,OAAN,CAAc;AACZC,EAAAA,WAAW,GAAG;AACZ,SAAKC,GAAL,GAAW,IAAIhB,UAAJ,CAAe,EAAf,CAAX;AACA,SAAKiB,MAAL,GAAc,CAAd;AACD;AAED;AACF;AACA;;;AACY,MAANxB,MAAM,GAAG;AACX,SAAKyB,MAAL;AACA,WAAO,KAAKF,GAAL,CAASG,QAAT,CAAkB,CAAlB,EAAqB,KAAKF,MAA1B,CAAP;AACD;AAED;AACF;AACA;;;AACEG,EAAAA,IAAI,GAAc;AAAA,QAAbC,OAAa,uEAAH,CAAG;AAChB,QAAIC,OAAO,GAAG,KAAKN,GAAL,CAASH,UAAT,GAAsB,CAApC;;AACA,WAAOS,OAAO,GAAGD,OAAjB,EAA0BC,OAAO,IAAI,CAAX;;AAC1B,UAAMC,MAAM,GAAG,IAAIvB,UAAJ,CAAesB,OAAf,CAAf;AACAC,IAAAA,MAAM,CAACC,GAAP,CAAW,KAAKR,GAAhB,EAAqB,CAArB;AACA,SAAKA,GAAL,GAAWO,MAAX;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;;;AACEE,EAAAA,UAAU,CAAC7B,KAAD,EAAQ;AAChB,QAAI,KAAKqB,MAAL,IAAe,KAAKD,GAAL,CAASH,UAA5B,EAAwC,KAAKO,IAAL;AACxC,SAAKJ,GAAL,CAAS,KAAKC,MAAd,IAAwBrB,KAAxB;AACA,SAAKqB,MAAL,IAAe,CAAf;AACD;AAED;AACF;AACA;AACA;AACA;;;AACES,EAAAA,YAAY,CAAC9B,KAAD,EAAQ;AAClB,QAAI,CAAC+B,MAAM,CAACC,SAAP,CAAiBhC,KAAjB,CAAL,EAA8B,MAAM,IAAIG,UAAJ,CAAe,yBAAf,CAAN;AAC9B,QAAIH,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,UAAzB,EAAqC,MAAM,IAAIG,UAAJ,CAAe,qBAAf,CAAN;AAErC,UAAM8B,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,IAAL,CAAU,CAAC,KAAKF,IAAI,CAACG,KAAL,CAAWrC,KAAX,CAAN,IAA2B,CAArC,CAAZ,CAAjB;AACA,QAAI,KAAKqB,MAAL,GAAcY,QAAd,GAAyB,KAAKb,GAAL,CAASH,UAAtC,EAAkD,KAAKO,IAAL;;AAElD,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,QAApB,EAA8BrB,CAAC,EAA/B,EAAmC;AACjC,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6BZ,KAAK,GAAG,IAAT,IAAkBY,CAAC,KAAKqB,QAAQ,GAAG,CAAjB,GAAqB,IAArB,GAA4B,IAA9C,CAA5B;AACAjC,MAAAA,KAAK,MAAM,CAAX,CAFiC,CAEpB;AACd;;AACD,SAAKqB,MAAL,IAAeY,QAAf;AACA,WAAOA,QAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEK,EAAAA,WAAW,CAACtC,KAAD,EAAQ;AACjB,QAAI,CAAC+B,MAAM,CAACC,SAAP,CAAiBhC,KAAjB,CAAL,EAA8B,MAAM,IAAIG,UAAJ,CAAe,yBAAf,CAAN;AAC9B,QAAIH,KAAK,GAAG,CAAC,UAAT,IAAuBA,KAAK,GAAG,UAAnC,EAA+C,MAAM,IAAIG,UAAJ,CAAe,qBAAf,CAAN;AAE/C,UAAM8B,QAAQ,GAAGC,IAAI,CAACE,IAAL,CAAU,CAAC,KAAKF,IAAI,CAACG,KAAL,CAAWrC,KAAK,IAAI,CAAT,GAAaA,KAAb,GAAqB,CAACA,KAAD,GAAS,CAAzC,CAAN,IAAqD,CAA/D,CAAjB;AACA,QAAI,KAAKqB,MAAL,GAAcY,QAAd,GAAyB,KAAKb,GAAL,CAASH,UAAtC,EAAkD,KAAKO,IAAL;;AAElD,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,QAApB,EAA8BrB,CAAC,EAA/B,EAAmC;AACjC,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6BZ,KAAK,GAAG,IAAT,IAAkBY,CAAC,KAAKqB,QAAQ,GAAG,CAAjB,GAAqB,IAArB,GAA4B,IAA9C,CAA5B;AACAjC,MAAAA,KAAK,KAAK,CAAV,CAFiC,CAErB;AACb;;AACD,SAAKqB,MAAL,IAAeY,QAAf;AACA,WAAOA,QAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEM,EAAAA,YAAY,CAACvC,KAAD,EAAQ;AAClB,QAAI,CAAC+B,MAAM,CAACC,SAAP,CAAiBhC,KAAjB,CAAL,EAA8B,MAAM,IAAIG,UAAJ,CAAe,yBAAf,CAAN;;AAC9B,QAAIH,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG+B,MAAM,CAACS,gBAAhC,EAAkD;AAChD,YAAM,IAAIrC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACD,UAAMsC,MAAM,GAAGP,IAAI,CAACQ,KAAL,CAAW1C,KAAK,GAAG,WAAnB,CAAf;AACA,UAAM2C,KAAK,GAAG,CAAC3C,KAAK,GAAG,UAAT,MAAyB,CAAvC,CANkB,CAMuB;;AACzC,WAAO,KAAK4C,YAAL,CAAkBH,MAAlB,EAA0BE,KAA1B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEE,EAAAA,WAAW,CAAC7C,KAAD,EAAQ;AACjB,QAAI,CAAC+B,MAAM,CAACC,SAAP,CAAiBhC,KAAjB,CAAL,EAA8B,MAAM,IAAIG,UAAJ,CAAe,yBAAf,CAAN;;AAC9B,QAAIH,KAAK,GAAG+B,MAAM,CAACe,gBAAf,IAAmC9C,KAAK,GAAG+B,MAAM,CAACS,gBAAtD,EAAwE;AACtE,YAAM,IAAIrC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACD,UAAMsC,MAAM,GAAGP,IAAI,CAACQ,KAAL,CAAW1C,KAAK,GAAG,WAAnB,CAAf;AACA,UAAM2C,KAAK,GAAG,CAAC3C,KAAK,GAAG,UAAT,MAAyB,CAAvC,CANiB,CAMwB;;AACzC,WAAO,KAAK+C,WAAL,CAAiBN,MAAjB,EAAyBE,KAAzB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,CAACH,MAAD,EAASE,KAAT,EAAgB;AAC1B,QAAI,CAACZ,MAAM,CAACC,SAAP,CAAiBS,MAAjB,CAAD,IAA6B,CAACV,MAAM,CAACC,SAAP,CAAiBW,KAAjB,CAAlC,EAA2D;AACzD,YAAM,IAAIxC,UAAJ,CAAe,yBAAf,CAAN;AACD;;AACD,QAAIsC,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,UAAvB,IAAqCE,KAAK,GAAG,CAA7C,IAAkDA,KAAK,GAAG,UAA9D,EAA0E;AACxE,YAAM,IAAIxC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACD,QAAIsC,MAAM,KAAK,CAAf,EAAkB,OAAO,KAAKX,YAAL,CAAkBa,KAAlB,CAAP;AAElB,UAAMV,QAAQ,GAAGC,IAAI,CAACE,IAAL,CAAU,CAAC,KAAKF,IAAI,CAACG,KAAL,CAAWI,MAAX,CAAN,IAA4B,CAAtC,CAAjB;AACA,QAAI,KAAKpB,MAAL,GAAcY,QAAd,GAAyB,KAAKb,GAAL,CAASH,UAAtC,EAAkD,KAAKO,IAAL;;AAClD,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6B+B,KAAK,GAAG,IAAT,GAAiB,IAA7C;AACAA,MAAAA,KAAK,MAAM,CAAX,CAF0B,CAEb;AACd;;AACD,SAAKvB,GAAL,CAAS,KAAKC,MAAL,GAAc,CAAvB,IAA6BsB,KAAK,GAAG,IAAT,GAAkB,CAACF,MAAM,GAAG,IAAV,KAAmB,CAArC,IAA2CR,QAAQ,KAAK,CAAb,GAAiB,IAAjB,GAAwB,IAAnE,CAA5B;AACAQ,IAAAA,MAAM,MAAM,CAAZ;;AACA,SAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,QAApB,EAA8BrB,CAAC,EAA/B,EAAmC;AACjC,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6B6B,MAAM,GAAG,IAAV,IAAmB7B,CAAC,KAAKqB,QAAQ,GAAG,CAAjB,GAAqB,IAArB,GAA4B,IAA/C,CAA5B;AACAQ,MAAAA,MAAM,MAAM,CAAZ;AACD;;AACD,SAAKpB,MAAL,IAAeY,QAAf;AACA,WAAOA,QAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEc,EAAAA,WAAW,CAACN,MAAD,EAASE,KAAT,EAAgB;AACzB,QAAI,CAACZ,MAAM,CAACC,SAAP,CAAiBS,MAAjB,CAAD,IAA6B,CAACV,MAAM,CAACC,SAAP,CAAiBW,KAAjB,CAAlC,EAA2D;AACzD,YAAM,IAAIxC,UAAJ,CAAe,yBAAf,CAAN;AACD;;AACD,QAAIsC,MAAM,GAAG,CAAC,UAAV,IAAwBA,MAAM,GAAG,UAAjC,IAA+CE,KAAK,GAAG,CAAC,UAAxD,IAAsEA,KAAK,GAAG,UAAlF,EAA8F;AAC5F,YAAM,IAAIxC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACDwC,IAAAA,KAAK,MAAM,CAAX,CAPyB,CAOZ;;AACb,QAAIF,MAAM,KAAK,CAAX,IAAgBE,KAAK,IAAI,UAA7B,EAAyC,OAAO,KAAKL,WAAL,CAAiBK,KAAjB,CAAP;AACzC,QAAIF,MAAM,KAAK,CAAC,CAAZ,IAAiBE,KAAK,IAAI,UAA9B,EAA0C,OAAO,KAAKL,WAAL,CAAiBK,KAAK,GAAG,WAAzB,CAAP;AAE1C,UAAMV,QAAQ,GAAGC,IAAI,CAACE,IAAL,CAAU,CAAC,KAAKF,IAAI,CAACG,KAAL,CAAWI,MAAM,IAAI,CAAV,GAAcA,MAAd,GAAuB,CAACA,MAAD,GAAU,CAA5C,CAAN,IAAwD,CAAlE,CAAjB;AACA,QAAI,KAAKpB,MAAL,GAAcY,QAAd,GAAyB,KAAKb,GAAL,CAASH,UAAtC,EAAkD,KAAKO,IAAL;;AAClD,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6B+B,KAAK,GAAG,IAAT,GAAiB,IAA7C;AACAA,MAAAA,KAAK,MAAM,CAAX,CAF0B,CAEb;AACd;;AACD,SAAKvB,GAAL,CAAS,KAAKC,MAAL,GAAc,CAAvB,IAA6BsB,KAAK,GAAG,IAAT,GAAkB,CAACF,MAAM,GAAG,IAAV,KAAmB,CAArC,IAA2CR,QAAQ,KAAK,CAAb,GAAiB,IAAjB,GAAwB,IAAnE,CAA5B;AACAQ,IAAAA,MAAM,KAAK,CAAX,CAlByB,CAkBZ;;AACb,SAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,QAApB,EAA8BrB,CAAC,EAA/B,EAAmC;AACjC,WAAKQ,GAAL,CAAS,KAAKC,MAAL,GAAcT,CAAvB,IAA6B6B,MAAM,GAAG,IAAV,IAAmB7B,CAAC,KAAKqB,QAAQ,GAAG,CAAjB,GAAqB,IAArB,GAA4B,IAA/C,CAA5B;AACAQ,MAAAA,MAAM,KAAK,CAAX;AACD;;AACD,SAAKpB,MAAL,IAAeY,QAAf;AACA,WAAOA,QAAP;AACD;AAED;AACF;AACA;AACA;;;AACEe,EAAAA,cAAc,CAACC,IAAD,EAAO;AACnB,QAAI,KAAK5B,MAAL,GAAc4B,IAAI,CAAChC,UAAnB,GAAgC,KAAKG,GAAL,CAASH,UAA7C,EAAyD;AACvD,WAAKO,IAAL,CAAU,KAAKH,MAAL,GAAc4B,IAAI,CAAChC,UAA7B;AACD;;AACD,SAAKG,GAAL,CAASQ,GAAT,CAAaqB,IAAb,EAAmB,KAAK5B,MAAxB;AACA,SAAKA,MAAL,IAAe4B,IAAI,CAAChC,UAApB;AACA,WAAOgC,IAAI,CAAChC,UAAZ;AACD;AAED;AACF;AACA;AACA;;;AACEiC,EAAAA,eAAe,CAAClD,KAAD,EAAQ;AACrB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,MAAM,IAAIC,SAAJ,CAAc,uBAAd,CAAN;AAC/B,WAAO,KAAK+C,cAAL,CAAoBvD,YAAY,CAACO,KAAD,CAAhC,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEmD,EAAAA,mBAAmB,CAACF,IAAD,EAAO;AACxB,SAAKV,YAAL,CAAkBU,IAAI,CAAChC,UAAvB;AACA,SAAK+B,cAAL,CAAoBC,IAApB;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACEG,EAAAA,oBAAoB,CAACpD,KAAD,EAAQ;AAC1B,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,MAAM,IAAIC,SAAJ,CAAc,uBAAd,CAAN;AAC/B,SAAKkD,mBAAL,CAAyB1D,YAAY,CAACO,KAAD,CAArC;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEqD,EAAAA,eAAe,CAACrD,KAAD,EAAQ;AACrB,SAAKmD,mBAAL,CAAyBpD,gBAAgB,CAACC,KAAD,CAAzC;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACEsB,EAAAA,MAAM,GAAG,CACR;;AApOW;AAuOd;AACA;AACA;AACA;AACA;;;AACA,MAAMgC,OAAN,CAAc;AACZnC,EAAAA,WAAW,CAACtB,MAAD,EAAS;AAClB,QAAI,EAAEA,MAAM,YAAYO,UAApB,CAAJ,EAAqC;AACnC,YAAM,IAAIH,SAAJ,CAAe,qBAAoBJ,MAAO,EAA1C,CAAN;AACD;;AACD,SAAKuB,GAAL,GAAWvB,MAAX;AACA,SAAKwB,MAAL,GAAc,CAAd;AACD;AAED;AACF;AACA;AACA;;;AACU,MAAJkC,IAAI,GAAG;AACT,WAAO,KAAKlC,MAAL,KAAgB,KAAKD,GAAL,CAASH,UAAhC;AACD;AAED;AACF;AACA;AACA;;;AACEuC,EAAAA,KAAK,GAAG;AACN,SAAKnC,MAAL,GAAc,CAAd;AACD;AAED;AACF;AACA;AACA;;;AACEoC,EAAAA,IAAI,CAAC3C,KAAD,EAAQ;AACV,QAAI,KAAKO,MAAL,GAAcP,KAAd,GAAsB,KAAKM,GAAL,CAASH,UAAnC,EAA+C;AAC7C,YAAM,IAAId,UAAJ,CAAe,kCAAf,CAAN;AACD;;AACD,SAAKkB,MAAL,IAAeP,KAAf;AACD;AAED;AACF;AACA;;;AACE4C,EAAAA,QAAQ,GAAG;AACT,SAAKrC,MAAL,IAAe,CAAf;AACA,WAAO,KAAKD,GAAL,CAAS,KAAKC,MAAL,GAAc,CAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEsC,EAAAA,UAAU,GAAG;AACX,QAAIC,MAAM,GAAG,CAAb;AAAA,QAAgBC,KAAK,GAAG,CAAxB;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAA9B,EAA0C;AACxC,YAAM6C,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB;;AACA,UAAIwC,KAAK,KAAK,EAAV,IAAgB,CAACC,QAAQ,GAAG,IAAZ,MAAsB,CAA1C,EAA6C;AAAE;AAC7C,cAAM,IAAI3D,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACDyD,MAAAA,MAAM,GAAG,CAACA,MAAM,GAAG,CAACE,QAAQ,GAAG,IAAZ,KAAqBD,KAA/B,MAA0C,CAAnD,CALwC,CAKa;;AACrDA,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;AACA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B,OAAOF,MAAP;AAC9B;;AACD,UAAM,IAAIzD,UAAJ,CAAe,qCAAf,CAAN;AACD;AAED;AACF;AACA;AACA;;;AACE4D,EAAAA,SAAS,GAAG;AACV,QAAIH,MAAM,GAAG,CAAb;AAAA,QAAgBC,KAAK,GAAG,CAAxB;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAA9B,EAA0C;AACxC,YAAM6C,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB;;AACA,UAAKwC,KAAK,KAAK,EAAV,IAAgB,CAACC,QAAQ,GAAG,IAAZ,MAAsB,CAAvC,IAA6C;AAC5CD,MAAAA,KAAK,KAAK,EAAV,IAAgB,CAACC,QAAQ,GAAG,IAAZ,MAAsB,CAAtC,IAA2C,CAACA,QAAQ,GAAG,IAAZ,MAAsB,CADlE,IACwE;AACvED,MAAAA,KAAK,KAAK,EAAV,IAAgB,CAACC,QAAQ,GAAG,IAAZ,MAAsB,CAAtC,IAA2C,CAACA,QAAQ,GAAG,IAAZ,MAAsB,IAFtE,EAE6E;AAAE;AAC7E,cAAM,IAAI3D,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACDyD,MAAAA,MAAM,IAAI,CAACE,QAAQ,GAAG,IAAZ,KAAqBD,KAA/B;AACAA,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;;AAEA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,YAAI,CAACA,QAAQ,GAAG,IAAZ,MAAsB,CAAtB,IAA2BD,KAAK,GAAG,EAAvC,EAA2C;AACzC,iBAAOD,MAAP,CADyC,CAC3B;AACf,SAFD,MAEO;AACL,iBAAOA,MAAM,GAAI,CAAC,CAAD,IAAMC,KAAvB,CADK,CACyB;AAC/B;AACF;AACF;;AACD,UAAM,IAAI1D,UAAJ,CAAe,qCAAf,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE6D,EAAAA,UAAU,GAAG;AACX,UAAM;AAAErB,MAAAA,KAAF;AAASF,MAAAA;AAAT,QAAoB,KAAKwB,UAAL,EAA1B;;AACA,QAAIxB,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,QAA3B,EAAqC;AACnC,YAAM,IAAItC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACD,WAAOsC,MAAM,GAAG,WAAT,GAAuBE,KAA9B;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEuB,EAAAA,SAAS,GAAG;AACV,UAAM;AAAEvB,MAAAA,KAAF;AAASF,MAAAA;AAAT,QAAoB,KAAK0B,SAAL,EAA1B;;AACA,QAAI1B,MAAM,GAAG,CAAC,QAAV,IAAuBA,MAAM,KAAK,CAAC,QAAZ,IAAwBE,KAAK,KAAK,CAAzD,IAA+DF,MAAM,GAAG,QAA5E,EAAsF;AACpF,YAAM,IAAItC,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACD,WAAOsC,MAAM,GAAG,WAAT,GAAuBE,KAA9B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEsB,EAAAA,UAAU,GAAG;AACX,QAAItB,KAAK,GAAG,CAAZ;AAAA,QAAeF,MAAM,GAAG,CAAxB;AAAA,QAA2BoB,KAAK,GAAG,CAAnC;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAAvB,IAAqC4C,KAAK,IAAI,EAArD,EAAyD;AACvD,YAAMC,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB;AACAsB,MAAAA,KAAK,GAAG,CAACA,KAAK,GAAG,CAACmB,QAAQ,GAAG,IAAZ,KAAqBD,KAA9B,MAAyC,CAAjD,CAFuD,CAEJ;;AACnD,UAAIA,KAAK,KAAK,EAAd,EAAkB;AAChBpB,QAAAA,MAAM,GAAG,CAACqB,QAAQ,GAAG,IAAZ,MAAsB,CAA/B;AACD;;AACDD,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;AACA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B,OAAO;AAAErB,QAAAA,MAAF;AAAUE,QAAAA;AAAV,OAAP;AAC9B;;AAEDkB,IAAAA,KAAK,GAAG,CAAR;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAA9B,EAA0C;AACxC,YAAM6C,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB;;AACA,UAAIwC,KAAK,KAAK,EAAV,IAAgB,CAACC,QAAQ,GAAG,IAAZ,MAAsB,CAA1C,EAA6C;AAAE;AAC7C,cAAM,IAAI3D,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACDsC,MAAAA,MAAM,GAAG,CAACA,MAAM,GAAG,CAACqB,QAAQ,GAAG,IAAZ,KAAqBD,KAA/B,MAA0C,CAAnD;AACAA,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;AACA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B,OAAO;AAAErB,QAAAA,MAAF;AAAUE,QAAAA;AAAV,OAAP;AAC9B;;AACD,UAAM,IAAIxC,UAAJ,CAAe,qCAAf,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEgE,EAAAA,SAAS,GAAG;AACV,QAAIxB,KAAK,GAAG,CAAZ;AAAA,QAAeF,MAAM,GAAG,CAAxB;AAAA,QAA2BoB,KAAK,GAAG,CAAnC;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAAvB,IAAqC4C,KAAK,IAAI,EAArD,EAAyD;AACvD,YAAMC,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB;AACAsB,MAAAA,KAAK,GAAG,CAACA,KAAK,GAAG,CAACmB,QAAQ,GAAG,IAAZ,KAAqBD,KAA9B,MAAyC,CAAjD,CAFuD,CAEJ;;AACnD,UAAIA,KAAK,KAAK,EAAd,EAAkB;AAChBpB,QAAAA,MAAM,GAAG,CAACqB,QAAQ,GAAG,IAAZ,MAAsB,CAA/B;AACD;;AACDD,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;;AACA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,YAAI,CAACA,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B;AAAE;AAC7B,cAAID,KAAK,GAAG,EAAZ,EAAgBlB,KAAK,GAAG,CAACA,KAAK,GAAI,CAAC,CAAD,IAAMkB,KAAhB,MAA4B,CAApC;AAChBpB,UAAAA,MAAM,IAAI,CAAC,CAAD,IAAMP,IAAI,CAACC,GAAL,CAAS0B,KAAK,GAAG,EAAjB,EAAqB,CAArB,CAAhB;AACD;;AACD,eAAO;AAAEpB,UAAAA,MAAF;AAAUE,UAAAA;AAAV,SAAP;AACD;AACF;;AAEDkB,IAAAA,KAAK,GAAG,CAAR;;AACA,WAAO,KAAKxC,MAAL,GAAc,KAAKD,GAAL,CAASH,UAA9B,EAA0C;AACxC,YAAM6C,QAAQ,GAAG,KAAK1C,GAAL,CAAS,KAAKC,MAAd,CAAjB,CADwC,CAExC;AACA;;AACA,UAAIwC,KAAK,KAAK,EAAV,IAAgBC,QAAQ,KAAK,CAA7B,IAAkCA,QAAQ,KAAK,IAAnD,EAAyD;AACvD,cAAM,IAAI3D,UAAJ,CAAe,qBAAf,CAAN;AACD;;AACDsC,MAAAA,MAAM,IAAI,CAACqB,QAAQ,GAAG,IAAZ,KAAqBD,KAA/B;AACAA,MAAAA,KAAK,IAAI,CAAT;AACA,WAAKxC,MAAL;;AACA,UAAI,CAACyC,QAAQ,GAAG,IAAZ,MAAsB,CAA1B,EAA6B;AAC3B,YAAI,CAACA,QAAQ,GAAG,IAAZ,MAAsB,CAAtB,IAA2BD,KAAK,GAAG,EAAvC,EAA2C;AAAE;AAC3CpB,UAAAA,MAAM,IAAI,CAAC,CAAD,IAAMoB,KAAhB;AACD;;AACD,eAAO;AAAEpB,UAAAA,MAAF;AAAUE,UAAAA;AAAV,SAAP;AACD;AACF;;AACD,UAAM,IAAIxC,UAAJ,CAAe,qCAAf,CAAN;AACD;AAED;AACF;AACA;AACA;;;AACEiE,EAAAA,YAAY,CAACC,MAAD,EAAS;AACnB,UAAMC,KAAK,GAAG,KAAKjD,MAAnB;;AACA,QAAIiD,KAAK,GAAGD,MAAR,GAAiB,KAAKjD,GAAL,CAASH,UAA9B,EAA0C;AACxC,YAAM,IAAId,UAAJ,CAAe,8BAAf,CAAN;AACD;;AACD,SAAKkB,MAAL,IAAegD,MAAf;AACA,WAAO,KAAKjD,GAAL,CAASG,QAAT,CAAkB+C,KAAlB,EAAyB,KAAKjD,MAA9B,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEkD,EAAAA,aAAa,CAACF,MAAD,EAAS;AACpB,WAAOzE,YAAY,CAAC,KAAKwE,YAAL,CAAkBC,MAAlB,CAAD,CAAnB;AACD;AAED;AACF;AACA;AACA;;;AACEG,EAAAA,iBAAiB,GAAG;AAClB,WAAO,KAAKJ,YAAL,CAAkB,KAAKJ,UAAL,EAAlB,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACES,EAAAA,kBAAkB,GAAG;AACnB,WAAO7E,YAAY,CAAC,KAAK4E,iBAAL,EAAD,CAAnB;AACD;AAED;AACF;AACA;AACA;;;AACEE,EAAAA,aAAa,GAAG;AACd,WAAO7D,gBAAgB,CAAC,KAAK2D,iBAAL,EAAD,CAAvB;AACD;;AAhPW;AAmPd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,UAAN,SAAyBzD,OAAzB,CAAiC;AAC/BC,EAAAA,WAAW,CAACyD,IAAD,EAAO;AAChB;AACA,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAa,OAAb;AACA,SAAKC,SAAL,GAAiBC,SAAjB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,OAAL,GAAe,EAAf;AACD;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,WAAW,CAAClF,KAAD,EAAyB;AAAA,QAAjBmF,WAAiB,uEAAH,CAAG;;AAClC,SAAKC,YAAL,CAAkBpF,KAAlB,EAAyBmF,WAAzB;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,YAAY,CAACpF,KAAD,EAAyB;AAAA,QAAjBmF,WAAiB,uEAAH,CAAG;AACnC,QAAIA,WAAW,IAAI,CAAnB,EAAsB;;AACtB,QAAI,KAAKN,KAAL,KAAe,OAAnB,EAA4B;AAC1B,WAAKA,KAAL,GAAc7E,KAAK,KAAK,IAAV,GAAiB,OAAjB,GAA4BmF,WAAW,KAAK,CAAhB,GAAoB,WAApB,GAAkC,YAA5E;AACA,WAAKL,SAAL,GAAiB9E,KAAjB;AACA,WAAKgF,KAAL,GAAaG,WAAb;AACD,KAJD,MAIO,IAAI,KAAKN,KAAL,KAAe,WAAnB,EAAgC;AACrC,UAAI7E,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAKqF,KAAL;AACA,aAAKR,KAAL,GAAa,OAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACD,OAJD,MAIO,IAAInF,KAAK,KAAK,KAAK8E,SAAnB,EAA8B;AACnC,aAAKD,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAa,IAAIG,WAAjB;AACD,OAHM,MAGA,IAAIA,WAAW,GAAG,CAAlB,EAAqB;AAC1B,aAAKE,KAAL;AACA,aAAKR,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACA,aAAKL,SAAL,GAAiB9E,KAAjB;AACD,OALM,MAKA;AACL,aAAK6E,KAAL,GAAa,SAAb;AACA,aAAKI,OAAL,GAAe,CAAC,KAAKH,SAAN,CAAf;AACA,aAAKA,SAAL,GAAiB9E,KAAjB;AACD;AACF,KAlBM,MAkBA,IAAI,KAAK6E,KAAL,KAAe,YAAnB,EAAiC;AACtC,UAAI7E,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAKqF,KAAL;AACA,aAAKR,KAAL,GAAa,OAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACD,OAJD,MAIO,IAAInF,KAAK,KAAK,KAAK8E,SAAnB,EAA8B;AACnC,aAAKE,KAAL,IAAcG,WAAd;AACD,OAFM,MAEA,IAAIA,WAAW,GAAG,CAAlB,EAAqB;AAC1B,aAAKE,KAAL;AACA,aAAKR,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACA,aAAKL,SAAL,GAAiB9E,KAAjB;AACD,OALM,MAKA;AACL,aAAKqF,KAAL;AACA,aAAKR,KAAL,GAAa,WAAb;AACA,aAAKC,SAAL,GAAiB9E,KAAjB;AACD;AACF,KAjBM,MAiBA,IAAI,KAAK6E,KAAL,KAAe,SAAnB,EAA8B;AACnC,UAAI7E,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAKiF,OAAL,CAAaK,IAAb,CAAkB,KAAKR,SAAvB;AACA,aAAKO,KAAL;AACA,aAAKR,KAAL,GAAa,OAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACD,OALD,MAKO,IAAInF,KAAK,KAAK,KAAK8E,SAAnB,EAA8B;AACnC,aAAKO,KAAL;AACA,aAAKR,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAa,IAAIG,WAAjB;AACD,OAJM,MAIA,IAAIA,WAAW,GAAG,CAAlB,EAAqB;AAC1B,aAAKF,OAAL,CAAaK,IAAb,CAAkB,KAAKR,SAAvB;AACA,aAAKO,KAAL;AACA,aAAKR,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACA,aAAKL,SAAL,GAAiB9E,KAAjB;AACD,OANM,MAMA;AACL,aAAKiF,OAAL,CAAaK,IAAb,CAAkB,KAAKR,SAAvB;AACA,aAAKA,SAAL,GAAiB9E,KAAjB;AACD;AACF,KApBM,MAoBA,IAAI,KAAK6E,KAAL,KAAe,OAAnB,EAA4B;AACjC,UAAI7E,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAKgF,KAAL,IAAcG,WAAd;AACD,OAFD,MAEO,IAAIA,WAAW,GAAG,CAAlB,EAAqB;AAC1B,aAAKE,KAAL;AACA,aAAKR,KAAL,GAAa,YAAb;AACA,aAAKG,KAAL,GAAaG,WAAb;AACA,aAAKL,SAAL,GAAiB9E,KAAjB;AACD,OALM,MAKA;AACL,aAAKqF,KAAL;AACA,aAAKR,KAAL,GAAa,WAAb;AACA,aAAKC,SAAL,GAAiB9E,KAAjB;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEuF,EAAAA,QAAQ,CAACC,OAAD,EAAwB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC9B,UAAM;AAAET,MAAAA,KAAF;AAASU,MAAAA,SAAT;AAAoBC,MAAAA;AAApB,QAAiCF,OAAvC;;AACA,QAAI,EAAED,OAAO,YAAYI,UAArB,KAAqCJ,OAAO,CAACZ,IAAR,KAAiB,KAAKA,IAA/D,EAAsE;AACpE,YAAM,IAAI3E,SAAJ,CAAc,8BAAd,CAAN;AACD;;AACD,QAAI4F,SAAS,GAAI,OAAOb,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCjD,MAAM,CAACS,gBAA5D;AACA,QAAIsD,aAAa,GAAG,CAApB;AAAA,QAAuBC,GAAG,GAAG,CAA7B;AACA,QAAIf,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC5C,QAAIa,SAAS,KAAK,CAAd,IAAmBL,OAAO,CAACjC,IAA/B,EAAqC,OAAOmC,SAAS,GAAG;AAACI,MAAAA,aAAD;AAAgBC,MAAAA;AAAhB,KAAH,GAA0B;AAACD,MAAAA;AAAD,KAA1C,CARP,CAU9B;AACA;AACA;AACA;;AACA,QAAIE,UAAU,GAAGR,OAAO,CAACS,SAAR,EAAjB;;AACA,QAAID,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAME,QAAQ,GAAGhE,IAAI,CAACiE,GAAL,CAASX,OAAO,CAACR,KAAR,GAAgB,CAAzB,EAA4Ba,SAA5B,CAAjB;AACAA,MAAAA,SAAS,IAAIK,QAAb;AACAV,MAAAA,OAAO,CAACR,KAAR,IAAiBkB,QAAQ,GAAG,CAA5B;AACA,WAAKhB,WAAL,CAAiB,IAAjB,EAAuBgB,QAAvB;AACA,UAAIlB,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC5C,UAAIa,SAAS,KAAK,CAAd,IAAmBL,OAAO,CAACjC,IAA/B,EAAqC,OAAOmC,SAAS,GAAG;AAACI,QAAAA,aAAD;AAAgBC,QAAAA;AAAhB,OAAH,GAA0B;AAACD,QAAAA;AAAD,OAA1C;AACrCE,MAAAA,UAAU,GAAGR,OAAO,CAACS,SAAR,EAAb;AACA,UAAID,UAAU,KAAK,IAAnB,EAAyB,MAAM,IAAI7F,UAAJ,CAAe,6CAAf,CAAN;AAC1B;;AACD,SAAK+E,WAAL,CAAiBc,UAAjB;AACAH,IAAAA,SAAS;AACTC,IAAAA,aAAa;AACb,QAAIJ,SAAJ,EAAeK,GAAG,IAAKJ,QAAQ,GAAIK,UAAU,KAAKL,QAAnB,GAA+BK,UAA/C;AACf,QAAIhB,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC5C,QAAIa,SAAS,KAAK,CAAd,IAAmBL,OAAO,CAACjC,IAA/B,EAAqC,OAAOmC,SAAS,GAAG;AAACI,MAAAA,aAAD;AAAgBC,MAAAA;AAAhB,KAAH,GAA0B;AAACD,MAAAA;AAAD,KAA1C,CA9BP,CAgC9B;;AACA,QAAIM,QAAQ,GAAIZ,OAAO,CAACR,KAAR,GAAgB,CAAhC;;AACA,WAAOa,SAAS,GAAG,CAAZ,IAAiB,CAACL,OAAO,CAACjC,IAAjC,EAAuC;AACrC,UAAI,CAAC6C,QAAL,EAAeZ,OAAO,CAACa,UAAR;AACf,YAAMC,SAAS,GAAGpE,IAAI,CAACiE,GAAL,CAASX,OAAO,CAACR,KAAjB,EAAwBa,SAAxB,CAAlB;AACAL,MAAAA,OAAO,CAACR,KAAR,IAAiBsB,SAAjB;;AAEA,UAAId,OAAO,CAACX,KAAR,KAAkB,SAAtB,EAAiC;AAC/BiB,QAAAA,aAAa,IAAIQ,SAAjB;;AACA,aAAK,IAAI1F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0F,SAApB,EAA+B1F,CAAC,EAAhC,EAAoC;AAClC,cAAI4E,OAAO,CAACjC,IAAZ,EAAkB,MAAM,IAAIpD,UAAJ,CAAe,oBAAf,CAAN;AAClB,gBAAMH,KAAK,GAAGwF,OAAO,CAACe,YAAR,EAAd;AACA,cAAIvG,KAAK,KAAKwF,OAAO,CAACV,SAAtB,EAAiC,MAAM,IAAI3E,UAAJ,CAAe,gDAAf,CAAN;AACjCqF,UAAAA,OAAO,CAACV,SAAR,GAAoB9E,KAApB;;AACA,eAAKoF,YAAL,CAAkBpF,KAAlB;;AACA,cAAI0F,SAAJ,EAAeK,GAAG,IAAKJ,QAAQ,GAAI3F,KAAK,KAAK2F,QAAd,GAA0B3F,KAA1C;AAChB;AACF,OAVD,MAUO,IAAIwF,OAAO,CAACX,KAAR,KAAkB,YAAtB,EAAoC;AACzCiB,QAAAA,aAAa,IAAIQ,SAAjB;AACA,YAAIZ,SAAJ,EAAeK,GAAG,IAAIO,SAAS,IAAIX,QAAQ,GAAIH,OAAO,CAACV,SAAR,KAAsBa,QAA1B,GAAsCH,OAAO,CAACV,SAA1D,CAAhB;AACf,cAAM9E,KAAK,GAAGwF,OAAO,CAACV,SAAtB;;AACA,aAAKM,YAAL,CAAkBpF,KAAlB;;AACA,YAAIsG,SAAS,GAAG,CAAhB,EAAmB;AACjB,eAAKlB,YAAL,CAAkBpF,KAAlB;;AACA,cAAI,KAAK6E,KAAL,KAAe,YAAnB,EAAiC,MAAM,IAAI1E,UAAJ,CAAgB,oBAAmB,KAAK0E,KAAM,EAA9C,CAAN;AACjC,eAAKG,KAAL,IAAcsB,SAAS,GAAG,CAA1B;AACD;AACF,OAVM,MAUA,IAAId,OAAO,CAACX,KAAR,KAAkB,OAAtB,EAA+B;AACpC,aAAKO,YAAL,CAAkB,IAAlB;;AACA,YAAI,KAAKP,KAAL,KAAe,OAAnB,EAA4B,MAAM,IAAI1E,UAAJ,CAAgB,oBAAmB,KAAK0E,KAAM,EAA9C,CAAN;AAC5B,aAAKG,KAAL,IAAcsB,SAAS,GAAG,CAA1B;AACD;;AAEDF,MAAAA,QAAQ,GAAG,KAAX;AACAP,MAAAA,SAAS,IAAIS,SAAb;AACD;;AACD,QAAItB,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC5C,WAAOU,SAAS,GAAG;AAACI,MAAAA,aAAD;AAAgBC,MAAAA;AAAhB,KAAH,GAA0B;AAACD,MAAAA;AAAD,KAA1C;AACD;AAED;AACF;AACA;;;AACET,EAAAA,KAAK,GAAG;AACN,QAAI,KAAKR,KAAL,KAAe,WAAnB,EAAgC;AAC9B,WAAKvC,WAAL,CAAiB,CAAC,CAAlB;AACA,WAAKkE,cAAL,CAAoB,KAAK1B,SAAzB;AACD,KAHD,MAGO,IAAI,KAAKD,KAAL,KAAe,YAAnB,EAAiC;AACtC,WAAKhC,WAAL,CAAiB,KAAKmC,KAAtB;AACA,WAAKwB,cAAL,CAAoB,KAAK1B,SAAzB;AACD,KAHM,MAGA,IAAI,KAAKD,KAAL,KAAe,SAAnB,EAA8B;AACnC,WAAKhC,WAAL,CAAiB,CAAC,KAAKoC,OAAL,CAAaZ,MAA/B;;AACA,WAAK,IAAIoC,CAAT,IAAc,KAAKxB,OAAnB,EAA4B,KAAKuB,cAAL,CAAoBC,CAApB;AAC7B,KAHM,MAGA,IAAI,KAAK5B,KAAL,KAAe,OAAnB,EAA4B;AACjC,WAAKvC,WAAL,CAAiB,CAAjB;AACA,WAAKC,YAAL,CAAkB,KAAKyC,KAAvB;AACD;;AACD,SAAKH,KAAL,GAAa,OAAb;AACD;AAED;AACF;AACA;;;AACE2B,EAAAA,cAAc,CAACxG,KAAD,EAAQ;AACpB,QAAI,KAAK4E,IAAL,KAAc,KAAlB,EAAyB;AACvB,WAAK/B,WAAL,CAAiB7C,KAAjB;AACD,KAFD,MAEO,IAAI,KAAK4E,IAAL,KAAc,MAAlB,EAA0B;AAC/B,WAAKrC,YAAL,CAAkBvC,KAAlB;AACD,KAFM,MAEA,IAAI,KAAK4E,IAAL,KAAc,MAAlB,EAA0B;AAC/B,WAAKxB,oBAAL,CAA0BpD,KAA1B;AACD,KAFM,MAEA;AACL,YAAM,IAAIG,UAAJ,CAAgB,gCAA+B,KAAKyE,IAAK,EAAzD,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;;;AACEtD,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKuD,KAAL,KAAe,SAAnB,EAA8B,KAAKI,OAAL,CAAaK,IAAb,CAAkB,KAAKR,SAAvB,EADvB,CAEP;;AACA,QAAI,KAAKD,KAAL,KAAe,OAAf,IAA0B,KAAKxD,MAAL,GAAc,CAA5C,EAA+C,KAAKgE,KAAL;AAChD;;AAhO8B;AAmOjC;AACA;AACA;AACA;;;AACA,MAAMO,UAAN,SAAyBtC,OAAzB,CAAiC;AAC/BnC,EAAAA,WAAW,CAACyD,IAAD,EAAO/E,MAAP,EAAe;AACxB,UAAMA,MAAN;AACA,SAAK+E,IAAL,GAAYA,IAAZ;AACA,SAAKE,SAAL,GAAiBC,SAAjB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKH,KAAL,GAAaE,SAAb;AACD;AAED;AACF;AACA;AACA;;;AACU,MAAJxB,IAAI,GAAG;AACT,WAAQ,KAAKyB,KAAL,KAAe,CAAhB,IAAuB,KAAK3D,MAAL,KAAgB,KAAKD,GAAL,CAASH,UAAvD;AACD;AAED;AACF;AACA;AACA;;;AACEuC,EAAAA,KAAK,GAAG;AACN,SAAKnC,MAAL,GAAc,CAAd;AACA,SAAKyD,SAAL,GAAiBC,SAAjB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKH,KAAL,GAAaE,SAAb;AACD;AAED;AACF;AACA;;;AACEkB,EAAAA,SAAS,GAAG;AACV,QAAI,KAAK1C,IAAT,EAAe,OAAO,IAAP;AACf,QAAI,KAAKyB,KAAL,KAAe,CAAnB,EAAsB,KAAKqB,UAAL;AACtB,SAAKrB,KAAL,IAAc,CAAd;;AACA,QAAI,KAAKH,KAAL,KAAe,SAAnB,EAA8B;AAC5B,YAAM7E,KAAK,GAAG,KAAKuG,YAAL,EAAd;AACA,UAAIvG,KAAK,KAAK,KAAK8E,SAAnB,EAA8B,MAAM,IAAI3E,UAAJ,CAAe,gDAAf,CAAN;AAC9B,WAAK2E,SAAL,GAAiB9E,KAAjB;AACA,aAAOA,KAAP;AACD,KALD,MAKO;AACL,aAAO,KAAK8E,SAAZ;AACD;AACF;AAED;AACF;AACA;;;AACE4B,EAAAA,UAAU,CAACC,OAAD,EAAU;AAClB,WAAOA,OAAO,GAAG,CAAV,IAAe,CAAC,KAAKpD,IAA5B,EAAkC;AAChC,UAAI,KAAKyB,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKA,KAAL,GAAa,KAAKd,SAAL,EAAb;;AACA,YAAI,KAAKc,KAAL,GAAa,CAAjB,EAAoB;AAClB,eAAKF,SAAL,GAAkB,KAAKE,KAAL,IAAc2B,OAAf,GAA0B,KAAKC,aAAL,CAAmB,CAAnB,CAA1B,GAAkD,KAAKL,YAAL,EAAnE;AACA,eAAK1B,KAAL,GAAa,YAAb;AACD,SAHD,MAGO,IAAI,KAAKG,KAAL,GAAa,CAAjB,EAAoB;AACzB,eAAKA,KAAL,GAAa,CAAC,KAAKA,KAAnB;AACA,eAAKH,KAAL,GAAa,SAAb;AACD,SAHM,MAGA;AAAE;AACP,eAAKG,KAAL,GAAa,KAAKhB,UAAL,EAAb;AACA,eAAKc,SAAL,GAAiB,IAAjB;AACA,eAAKD,KAAL,GAAa,OAAb;AACD;AACF;;AAED,YAAMgC,OAAO,GAAG3E,IAAI,CAACiE,GAAL,CAASQ,OAAT,EAAkB,KAAK3B,KAAvB,CAAhB;AACA,UAAI,KAAKH,KAAL,KAAe,SAAnB,EAA8B,KAAK+B,aAAL,CAAmBC,OAAnB;AAC9BF,MAAAA,OAAO,IAAIE,OAAX;AACA,WAAK7B,KAAL,IAAc6B,OAAd;AACD;AACF;AAED;AACF;AACA;AACA;;;AACER,EAAAA,UAAU,GAAG;AACX,SAAKrB,KAAL,GAAa,KAAKd,SAAL,EAAb;;AACA,QAAI,KAAKc,KAAL,GAAa,CAAjB,EAAoB;AAClB,YAAMhF,KAAK,GAAG,KAAKuG,YAAL,EAAd;;AACA,UAAI,CAAC,KAAK1B,KAAL,KAAe,YAAf,IAA+B,KAAKA,KAAL,KAAe,SAA/C,KAA6D,KAAKC,SAAL,KAAmB9E,KAApF,EAA2F;AACzF,cAAM,IAAIG,UAAJ,CAAe,4DAAf,CAAN;AACD;;AACD,WAAK0E,KAAL,GAAa,YAAb;AACA,WAAKC,SAAL,GAAiB9E,KAAjB;AACD,KAPD,MAOO,IAAI,KAAKgF,KAAL,KAAe,CAAnB,EAAsB;AAC3B,YAAM,IAAI7E,UAAJ,CAAe,6DAAf,CAAN;AACD,KAFM,MAEA,IAAI,KAAK6E,KAAL,GAAa,CAAjB,EAAoB;AACzB,WAAKA,KAAL,GAAa,CAAC,KAAKA,KAAnB;AACA,UAAI,KAAKH,KAAL,KAAe,SAAnB,EAA8B,MAAM,IAAI1E,UAAJ,CAAe,qCAAf,CAAN;AAC9B,WAAK0E,KAAL,GAAa,SAAb;AACD,KAJM,MAIA;AAAE;AACP,UAAI,KAAKA,KAAL,KAAe,OAAnB,EAA4B,MAAM,IAAI1E,UAAJ,CAAe,sCAAf,CAAN;AAC5B,WAAK6E,KAAL,GAAa,KAAKhB,UAAL,EAAb;AACA,UAAI,KAAKgB,KAAL,KAAe,CAAnB,EAAsB,MAAM,IAAI7E,UAAJ,CAAe,uCAAf,CAAN;AACtB,WAAK2E,SAAL,GAAiB,IAAjB;AACA,WAAKD,KAAL,GAAa,OAAb;AACD;AACF;AAED;AACF;AACA;AACA;;;AACE0B,EAAAA,YAAY,GAAG;AACb,QAAI,KAAK3B,IAAL,KAAc,KAAlB,EAAyB;AACvB,aAAO,KAAKV,SAAL,EAAP;AACD,KAFD,MAEO,IAAI,KAAKU,IAAL,KAAc,MAAlB,EAA0B;AAC/B,aAAO,KAAKZ,UAAL,EAAP;AACD,KAFM,MAEA,IAAI,KAAKY,IAAL,KAAc,MAAlB,EAA0B;AAC/B,aAAO,KAAKH,kBAAL,EAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAItE,UAAJ,CAAgB,gCAA+B,KAAKyE,IAAK,EAAzD,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;;;AACEgC,EAAAA,aAAa,CAACE,GAAD,EAAM;AACjB,QAAI,KAAKlC,IAAL,KAAc,MAAlB,EAA0B;AACxB,WAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAApB,EAAyBlG,CAAC,EAA1B,EAA8B,KAAK6C,IAAL,CAAU,KAAKO,UAAL,EAAV;AAC/B,KAFD,MAEO;AACL,aAAO8C,GAAG,GAAG,CAAN,IAAW,KAAKzF,MAAL,GAAc,KAAKD,GAAL,CAASH,UAAzC,EAAqD;AACnD,YAAI,CAAC,KAAKG,GAAL,CAAS,KAAKC,MAAd,IAAwB,IAAzB,MAAmC,CAAvC,EAA0CyF,GAAG;AAC7C,aAAKzF,MAAL;AACD;;AACD,UAAIyF,GAAG,GAAG,CAAV,EAAa,MAAM,IAAI3G,UAAJ,CAAe,kCAAf,CAAN;AACd;AACF;;AAlI8B;AAqIjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM4G,YAAN,SAA2BpC,UAA3B,CAAsC;AACpCxD,EAAAA,WAAW,GAAG;AACZ,UAAM,KAAN;AACA,SAAK6F,aAAL,GAAqB,CAArB;AACD;AAED;AACF;AACA;AACA;;;AACE9B,EAAAA,WAAW,CAAClF,KAAD,EAAyB;AAAA,QAAjBmF,WAAiB,uEAAH,CAAG;AAClC,QAAIA,WAAW,IAAI,CAAnB,EAAsB;;AACtB,QAAI,OAAOnF,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAMkF,WAAN,CAAkBlF,KAAK,GAAG,KAAKgH,aAA/B,EAA8C,CAA9C;AACA,WAAKA,aAAL,GAAqBhH,KAArB;AACA,UAAImF,WAAW,GAAG,CAAlB,EAAqB,MAAMD,WAAN,CAAkB,CAAlB,EAAqBC,WAAW,GAAG,CAAnC;AACtB,KAJD,MAIO;AACL,YAAMD,WAAN,CAAkBlF,KAAlB,EAAyBmF,WAAzB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AACEI,EAAAA,QAAQ,CAACC,OAAD,EAAwB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC9B,QAAIA,OAAO,CAACC,SAAZ,EAAuB;AACrB,YAAM,IAAIvF,UAAJ,CAAe,iDAAf,CAAN;AACD;;AACD,QAAI,EAAEqF,OAAO,YAAYyB,YAArB,CAAJ,EAAwC;AACtC,YAAM,IAAIhH,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAED,QAAI4F,SAAS,GAAGJ,OAAO,CAACT,KAAxB;AACA,QAAIa,SAAS,GAAG,CAAZ,IAAiBL,OAAO,CAACjC,IAA7B,EAAmC,MAAM,IAAIpD,UAAJ,CAAgB,eAAc0F,SAAU,SAAxC,CAAN;AACnC,QAAIA,SAAS,KAAK,CAAd,IAAmBL,OAAO,CAACjC,IAA/B,EAAqC,OAVP,CAY9B;AACA;;AACA,QAAIvD,KAAK,GAAGwF,OAAO,CAACS,SAAR,EAAZ;AAAA,QAAiCiB,KAAK,GAAG,CAAzC;AACA,SAAKhC,WAAL,CAAiBlF,KAAjB;;AACA,QAAIA,KAAK,KAAK,IAAd,EAAoB;AAClBkH,MAAAA,KAAK,GAAG1B,OAAO,CAACR,KAAR,GAAgB,CAAxB;AACA,UAAIa,SAAS,KAAKd,SAAd,IAA2Bc,SAAS,GAAGqB,KAA3C,EAAkDA,KAAK,GAAGrB,SAAR;AAClDL,MAAAA,OAAO,CAACR,KAAR,IAAiBkC,KAAK,GAAG,CAAzB;AACA,WAAKlC,KAAL,IAAckC,KAAK,GAAG,CAAtB;AACA,UAAIrB,SAAS,GAAGqB,KAAZ,IAAqB1B,OAAO,CAACjC,IAAjC,EAAuC,MAAM,IAAIpD,UAAJ,CAAgB,eAAc0F,SAAU,SAAxC,CAAN;AACvC,UAAIA,SAAS,KAAKqB,KAAd,IAAuB1B,OAAO,CAACjC,IAAnC,EAAyC,OANvB,CAQlB;AACA;;AACA,UAAIiC,OAAO,CAACR,KAAR,KAAkB,CAAtB,EAAyB,KAAKE,WAAL,CAAiBM,OAAO,CAACS,SAAR,EAAjB;AAC1B,KA3B6B,CA6B9B;AACA;AACA;AACA;;;AACA,QAAIJ,SAAS,KAAKd,SAAlB,EAA6Bc,SAAS,IAAIqB,KAAK,GAAG,CAArB;AAC7B,UAAM;AAAEpB,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAAyB,MAAMR,QAAN,CAAeC,OAAf,EAAwB;AAACR,MAAAA,KAAK,EAAEa,SAAR;AAAmBH,MAAAA,SAAS,EAAE;AAA9B,KAAxB,CAA/B;;AACA,QAAII,aAAa,GAAG,CAApB,EAAuB;AACrB,WAAKkB,aAAL,GAAqBjB,GAArB;AACAP,MAAAA,OAAO,CAACwB,aAAR,GAAwBjB,GAAxB;AACD;AACF;;AAjEmC;AAoEtC;AACA;AACA;AACA;;;AACA,MAAMkB,YAAN,SAA2BrB,UAA3B,CAAsC;AACpCzE,EAAAA,WAAW,CAACtB,MAAD,EAAS;AAClB,UAAM,KAAN,EAAaA,MAAb;AACA,SAAKmH,aAAL,GAAqB,CAArB;AACD;AAED;AACF;AACA;AACA;;;AACExD,EAAAA,KAAK,GAAG;AACN,SAAKnC,MAAL,GAAc,CAAd;AACA,SAAKyD,SAAL,GAAiBC,SAAjB;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKH,KAAL,GAAaE,SAAb;AACA,SAAKiC,aAAL,GAAqB,CAArB;AACD;AAED;AACF;AACA;;;AACEf,EAAAA,SAAS,GAAG;AACV,UAAMjG,KAAK,GAAG,MAAMiG,SAAN,EAAd;AACA,QAAIjG,KAAK,KAAK,IAAd,EAAoB,OAAO,IAAP;AACpB,SAAKgH,aAAL,IAAsBhH,KAAtB;AACA,WAAO,KAAKgH,aAAZ;AACD;AAED;AACF;AACA;;;AACEN,EAAAA,UAAU,CAACC,OAAD,EAAU;AAClB,WAAOA,OAAO,GAAG,CAAV,IAAe,CAAC,KAAKpD,IAA5B,EAAkC;AAChC,UAAI,KAAKyB,KAAL,KAAe,CAAnB,EAAsB,KAAKqB,UAAL;AACtB,YAAMQ,OAAO,GAAG3E,IAAI,CAACiE,GAAL,CAASQ,OAAT,EAAkB,KAAK3B,KAAvB,CAAhB;;AACA,UAAI,KAAKH,KAAL,KAAe,SAAnB,EAA8B;AAC5B,aAAK,IAAIjE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiG,OAApB,EAA6BjG,CAAC,EAA9B,EAAkC;AAChC,eAAKkE,SAAL,GAAiB,KAAKyB,YAAL,EAAjB;AACA,eAAKS,aAAL,IAAsB,KAAKlC,SAA3B;AACD;AACF,OALD,MAKO,IAAI,KAAKD,KAAL,KAAe,YAAnB,EAAiC;AACtC,aAAKmC,aAAL,IAAsBH,OAAO,GAAG,KAAK/B,SAArC;AACD;;AACD6B,MAAAA,OAAO,IAAIE,OAAX;AACA,WAAK7B,KAAL,IAAc6B,OAAd;AACD;AACF;;AA9CmC;AAiDtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,cAAN,SAA6BjG,OAA7B,CAAqC;AACnCC,EAAAA,WAAW,GAAG;AACZ;AACA,SAAK2D,SAAL,GAAiB,KAAjB;AACA,SAAKE,KAAL,GAAa,CAAb;AACD;AAED;AACF;AACA;AACA;;;AACEE,EAAAA,WAAW,CAAClF,KAAD,EAAyB;AAAA,QAAjBmF,WAAiB,uEAAH,CAAG;;AAClC,QAAInF,KAAK,KAAK,KAAV,IAAmBA,KAAK,KAAK,IAAjC,EAAuC;AACrC,YAAM,IAAIG,UAAJ,CAAgB,yCAAwCH,KAAM,EAA9D,CAAN;AACD;;AACD,QAAImF,WAAW,IAAI,CAAnB,EAAsB;;AACtB,QAAI,KAAKL,SAAL,KAAmB9E,KAAvB,EAA8B;AAC5B,WAAKgF,KAAL,IAAcG,WAAd;AACD,KAFD,MAEO;AACL,WAAK5C,YAAL,CAAkB,KAAKyC,KAAvB;AACA,WAAKF,SAAL,GAAiB9E,KAAjB;AACA,WAAKgF,KAAL,GAAaG,WAAb;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AACEI,EAAAA,QAAQ,CAACC,OAAD,EAAwB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAC9B,QAAI,EAAED,OAAO,YAAY4B,cAArB,CAAJ,EAA0C;AACxC,YAAM,IAAInH,SAAJ,CAAc,8BAAd,CAAN;AACD;;AAED,UAAM;AAAE+E,MAAAA;AAAF,QAAYS,OAAlB;AACA,QAAII,SAAS,GAAI,OAAOb,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCjD,MAAM,CAACS,gBAA5D;AACA,QAAIwC,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC5C,QAAIa,SAAS,KAAK,CAAd,IAAmBL,OAAO,CAACjC,IAA/B,EAAqC,OARP,CAU9B;;AACA,SAAK2B,WAAL,CAAiBM,OAAO,CAACS,SAAR,EAAjB;AACAJ,IAAAA,SAAS;AACT,UAAMwB,SAAS,GAAGnF,IAAI,CAACiE,GAAL,CAASX,OAAO,CAACR,KAAjB,EAAwBa,SAAxB,CAAlB;AACA,SAAKb,KAAL,IAAcqC,SAAd;AACA7B,IAAAA,OAAO,CAACR,KAAR,IAAiBqC,SAAjB;AACAxB,IAAAA,SAAS,IAAIwB,SAAb;;AAEA,WAAOxB,SAAS,GAAG,CAAZ,IAAiB,CAACL,OAAO,CAACjC,IAAjC,EAAuC;AACrCiC,MAAAA,OAAO,CAACR,KAAR,GAAgBQ,OAAO,CAACxB,UAAR,EAAhB;AACA,UAAIwB,OAAO,CAACR,KAAR,KAAkB,CAAtB,EAAyB,MAAM,IAAI7E,UAAJ,CAAe,kCAAf,CAAN;AACzBqF,MAAAA,OAAO,CAACV,SAAR,GAAoB,CAACU,OAAO,CAACV,SAA7B;AACA,WAAKvC,YAAL,CAAkB,KAAKyC,KAAvB;AAEA,YAAMsC,SAAS,GAAGpF,IAAI,CAACiE,GAAL,CAASX,OAAO,CAACR,KAAjB,EAAwBa,SAAxB,CAAlB;AACA,WAAKb,KAAL,GAAasC,SAAb;AACA,WAAKxC,SAAL,GAAiBU,OAAO,CAACV,SAAzB;AACAU,MAAAA,OAAO,CAACR,KAAR,IAAiBsC,SAAjB;AACAzB,MAAAA,SAAS,IAAIyB,SAAb;AACD;;AAED,QAAItC,KAAK,IAAIa,SAAS,GAAG,CAArB,IAA0BL,OAAO,CAACjC,IAAtC,EAA4C,MAAM,IAAIpD,UAAJ,CAAgB,eAAc6E,KAAM,SAApC,CAAN;AAC7C;AAED;AACF;AACA;AACA;;;AACE1D,EAAAA,MAAM,GAAG;AACP,QAAI,KAAK0D,KAAL,GAAa,CAAjB,EAAoB;AAClB,WAAKzC,YAAL,CAAkB,KAAKyC,KAAvB;AACA,WAAKA,KAAL,GAAa,CAAb;AACD;AACF;;AAzEkC;AA4ErC;AACA;AACA;AACA;;;AACA,MAAMoC,cAAN,SAA6B9D,OAA7B,CAAqC;AACnCnC,EAAAA,WAAW,CAACtB,MAAD,EAAS;AAClB,UAAMA,MAAN;AACA,SAAKiF,SAAL,GAAiB,IAAjB,CAFkB,CAEI;;AACtB,SAAKsB,QAAL,GAAgB,IAAhB;AACA,SAAKpB,KAAL,GAAa,CAAb;AACD;AAED;AACF;AACA;AACA;;;AACU,MAAJzB,IAAI,GAAG;AACT,WAAQ,KAAKyB,KAAL,KAAe,CAAhB,IAAuB,KAAK3D,MAAL,KAAgB,KAAKD,GAAL,CAASH,UAAvD;AACD;AAED;AACF;AACA;AACA;;;AACEuC,EAAAA,KAAK,GAAG;AACN,SAAKnC,MAAL,GAAc,CAAd;AACA,SAAKyD,SAAL,GAAiB,IAAjB;AACA,SAAKsB,QAAL,GAAgB,IAAhB;AACA,SAAKpB,KAAL,GAAa,CAAb;AACD;AAED;AACF;AACA;;;AACEiB,EAAAA,SAAS,GAAG;AACV,QAAI,KAAK1C,IAAT,EAAe,OAAO,KAAP;;AACf,WAAO,KAAKyB,KAAL,KAAe,CAAtB,EAAyB;AACvB,WAAKA,KAAL,GAAa,KAAKhB,UAAL,EAAb;AACA,WAAKc,SAAL,GAAiB,CAAC,KAAKA,SAAvB;;AACA,UAAI,KAAKE,KAAL,KAAe,CAAf,IAAoB,CAAC,KAAKoB,QAA9B,EAAwC;AACtC,cAAM,IAAIjG,UAAJ,CAAe,kCAAf,CAAN;AACD;;AACD,WAAKiG,QAAL,GAAgB,KAAhB;AACD;;AACD,SAAKpB,KAAL,IAAc,CAAd;AACA,WAAO,KAAKF,SAAZ;AACD;AAED;AACF;AACA;;;AACE4B,EAAAA,UAAU,CAACC,OAAD,EAAU;AAClB,WAAOA,OAAO,GAAG,CAAV,IAAe,CAAC,KAAKpD,IAA5B,EAAkC;AAChC,UAAI,KAAKyB,KAAL,KAAe,CAAnB,EAAsB;AACpB,aAAKA,KAAL,GAAa,KAAKhB,UAAL,EAAb;AACA,aAAKc,SAAL,GAAiB,CAAC,KAAKA,SAAvB;;AACA,YAAI,KAAKE,KAAL,KAAe,CAAf,IAAoB,CAAC,KAAKoB,QAA9B,EAAwC;AACtC,gBAAM,IAAIjG,UAAJ,CAAe,kCAAf,CAAN;AACD;;AACD,aAAKiG,QAAL,GAAgB,KAAhB;AACD;;AACD,UAAI,KAAKpB,KAAL,GAAa2B,OAAjB,EAA0B;AACxBA,QAAAA,OAAO,IAAI,KAAK3B,KAAhB;AACA,aAAKA,KAAL,GAAa,CAAb;AACD,OAHD,MAGO;AACL,aAAKA,KAAL,IAAc2B,OAAd;AACAA,QAAAA,OAAO,GAAG,CAAV;AACD;AACF;AACF;;AAjEkC;;AAoErCY,MAAM,CAACC,OAAP,GAAiB;AACf/H,EAAAA,YADe;AACDG,EAAAA,YADC;AACaG,EAAAA,gBADb;AAC+Bc,EAAAA,gBAD/B;AAEfK,EAAAA,OAFe;AAENoC,EAAAA,OAFM;AAEGqB,EAAAA,UAFH;AAEeiB,EAAAA,UAFf;AAE2BmB,EAAAA,YAF3B;AAEyCE,EAAAA,YAFzC;AAEuDE,EAAAA,cAFvD;AAEuEC,EAAAA;AAFvE,CAAjB","sourcesContent":["/**\n * UTF-8 decoding and encoding using API that is supported in Node >= 12 and modern browsers:\n * https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode\n * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode\n * If you're running in an environment where it's not available, please use a polyfill, such as:\n * https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n */\nconst utf8encoder = new TextEncoder()\nconst utf8decoder = new TextDecoder('utf-8')\n\nfunction stringToUtf8(string) {\n  return utf8encoder.encode(string)\n}\n\nfunction utf8ToString(buffer) {\n  return utf8decoder.decode(buffer)\n}\n\n/**\n * Converts a string consisting of hexadecimal digits into an Uint8Array.\n */\nfunction hexStringToBytes(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('value is not a string')\n  }\n  if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {\n    throw new RangeError('value is not hexadecimal')\n  }\n  if (value === '') {\n    return new Uint8Array(0)\n  } else {\n    return new Uint8Array(value.match(/../g).map(b => parseInt(b, 16)))\n  }\n}\n\nconst NIBBLE_TO_HEX = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\nconst BYTE_TO_HEX = new Array(256)\nfor (let i = 0; i < 256; i++) {\n  BYTE_TO_HEX[i] = `${NIBBLE_TO_HEX[(i >>> 4) & 0xf]}${NIBBLE_TO_HEX[i & 0xf]}`;\n}\n\n/**\n * Converts a Uint8Array into the equivalent hexadecimal string.\n */\nfunction bytesToHexString(bytes) {\n  let hex = '', len = bytes.byteLength\n  for (let i = 0; i < len; i++) {\n    hex += BYTE_TO_HEX[bytes[i]]\n  }\n  return hex\n}\n\n/**\n * Wrapper around an Uint8Array that allows values to be appended to the buffer,\n * and that automatically grows the buffer when space runs out.\n */\nclass Encoder {\n  constructor() {\n    this.buf = new Uint8Array(16)\n    this.offset = 0\n  }\n\n  /**\n   * Returns the byte array containing the encoded data.\n   */\n  get buffer() {\n    this.finish()\n    return this.buf.subarray(0, this.offset)\n  }\n\n  /**\n   * Reallocates the encoder's buffer to be bigger.\n   */\n  grow(minSize = 0) {\n    let newSize = this.buf.byteLength * 4\n    while (newSize < minSize) newSize *= 2\n    const newBuf = new Uint8Array(newSize)\n    newBuf.set(this.buf, 0)\n    this.buf = newBuf\n    return this\n  }\n\n  /**\n   * Appends one byte (0 to 255) to the buffer.\n   */\n  appendByte(value) {\n    if (this.offset >= this.buf.byteLength) this.grow()\n    this.buf[this.offset] = value\n    this.offset += 1\n  }\n\n  /**\n   * Encodes a 32-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and\n   * appends it to the buffer. Returns the number of bytes written.\n   */\n  appendUint32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > 0xffffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7))\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>>= 7 // zero-filling right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 32-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends\n   * it to the buffer. Returns the number of bytes written.\n   */\n  appendInt32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < -0x80000000 || value > 0x7fffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>= 7 // sign-propagating right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a nonnegative integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendUint53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendUint64(high32, low32)\n  }\n\n  /**\n   * Encodes a signed integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendInt53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendInt64(high32, low32)\n  }\n\n  /**\n   * Encodes a 64-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme, and appends it to the buffer. The number is\n   * given as two 32-bit halves since JavaScript cannot accurately represent\n   * integers with more than 53 bits in a single variable.\n   */\n  appendUint64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < 0 || high32 > 0xffffffff || low32 < 0 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    if (high32 === 0) return this.appendUint32(low32)\n\n    const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>>= 3\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 64-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme, and appends it to the buffer. The number is given\n   * as two 32-bit halves since JavaScript cannot accurately represent integers\n   * with more than 53 bits in a single variable. The sign of the 64-bit\n   * number is determined by the sign of the `high32` half; the sign of the\n   * `low32` half is ignored.\n   */\n  appendInt64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < -0x80000000 || high32 > 0x7fffffff || low32 < -0x80000000 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    low32 >>>= 0 // interpret as unsigned\n    if (high32 === 0 && low32 <= 0x7fffffff) return this.appendInt32(low32)\n    if (high32 === -1 && low32 >= 0x80000000) return this.appendInt32(low32 - 0x100000000)\n\n    const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>= 3 // sign-propagating right shift\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer. Returns the\n   * number of bytes appended.\n   */\n  appendRawBytes(data) {\n    if (this.offset + data.byteLength > this.buf.byteLength) {\n      this.grow(this.offset + data.byteLength)\n    }\n    this.buf.set(data, this.offset)\n    this.offset += data.byteLength\n    return data.byteLength\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, without any metadata. Returns the\n   * number of bytes appended.\n   */\n  appendRawString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    return this.appendRawBytes(stringToUtf8(value))\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer, prefixed with the\n   * number of bytes in the buffer (as a LEB128-encoded unsigned integer).\n   */\n  appendPrefixedBytes(data) {\n    this.appendUint53(data.byteLength)\n    this.appendRawBytes(data)\n    return this\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, prefixed with its length in bytes\n   * (where the length is encoded as an unsigned LEB128 integer).\n   */\n  appendPrefixedString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    this.appendPrefixedBytes(stringToUtf8(value))\n    return this\n  }\n\n  /**\n   * Takes a value, which must be a string consisting only of hexadecimal\n   * digits, maps it to a byte array, and appends it to the buffer, prefixed\n   * with its length in bytes.\n   */\n  appendHexString(value) {\n    this.appendPrefixedBytes(hexStringToBytes(value))\n    return this\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n  }\n}\n\n/**\n * Counterpart to Encoder. Wraps a Uint8Array buffer with a cursor indicating\n * the current decoding position, and allows values to be incrementally read by\n * decoding the bytes at the current position.\n */\nclass Decoder {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw new TypeError(`Not a byte array: ${buffer}`)\n    }\n    this.buf = buffer\n    this.offset = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return this.offset === this.buf.byteLength\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n  }\n\n  /**\n   * Moves the current decoding position forward by the specified number of\n   * bytes, without decoding anything.\n   */\n  skip(bytes) {\n    if (this.offset + bytes > this.buf.byteLength) {\n      throw new RangeError('cannot skip beyond end of buffer')\n    }\n    this.offset += bytes\n  }\n\n  /**\n   * Reads one byte (0 to 255) from the buffer.\n   */\n  readByte() {\n    this.offset += 1\n    return this.buf[this.offset - 1]\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit unsigned int.\n   */\n  readUint32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 28 && (nextByte & 0xf0) !== 0) { // more than 5 bytes, or value > 0xffffffff\n        throw new RangeError('number out of range')\n      }\n      result = (result | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return result\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit signed int.\n   */\n  readInt32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if ((shift === 28 && (nextByte & 0x80) !== 0) || // more than 5 bytes\n          (shift === 28 && (nextByte & 0x40) === 0 && (nextByte & 0x38) !== 0) || // positive int > 0x7fffffff\n          (shift === 28 && (nextByte & 0x40) !== 0 && (nextByte & 0x38) !== 0x38)) { // negative int < -0x80000000\n        throw new RangeError('number out of range')\n      }\n      result |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) === 0 || shift > 28) {\n          return result // positive, or negative value that doesn't need sign-extending\n        } else {\n          return result | (-1 << shift) // sign-extend negative integer\n        }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (up to 2^53 - 1), and throws an exception outside of that range.\n   */\n  readUint53() {\n    const { low32, high32 } = this.readUint64()\n    if (high32 < 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.\n   */\n  readInt53() {\n    const { low32, high32 } = this.readInt64()\n    if (high32 < -0x200000 || (high32 === -0x200000 && low32 === 0) || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`.\n   */\n  readUint64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 31 && (nextByte & 0xfe) !== 0) { // more than 10 bytes, or value > 2^64 - 1\n        throw new RangeError('number out of range')\n      }\n      high32 = (high32 | (nextByte & 0x7f) << shift) >>> 0\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit signed\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`. The `low32` half is always non-negative, and the\n   * sign of the `high32` half indicates the sign of the 64-bit number.\n   */\n  readInt64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0) { // sign-extend negative integer\n          if (shift < 32) low32 = (low32 | (-1 << shift)) >>> 0\n          high32 |= -1 << Math.max(shift - 32, 0)\n        }\n        return { high32, low32 }\n      }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      // On the 10th byte there are only two valid values: all 7 value bits zero\n      // (if the value is positive) or all 7 bits one (if the value is negative)\n      if (shift === 31 && nextByte !== 0 && nextByte !== 0x7f) {\n        throw new RangeError('number out of range')\n      }\n      high32 |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0 && shift < 32) { // sign-extend negative integer\n          high32 |= -1 << shift\n        }\n        return { high32, low32 }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Extracts a subarray `length` bytes in size, starting from the current\n   * position in the buffer, and moves the position forward.\n   */\n  readRawBytes(length) {\n    const start = this.offset\n    if (start + length > this.buf.byteLength) {\n      throw new RangeError('subarray exceeds buffer size')\n    }\n    this.offset += length\n    return this.buf.subarray(start, this.offset)\n  }\n\n  /**\n   * Extracts `length` bytes from the buffer, starting from the current position,\n   * and returns the UTF-8 string decoding of those bytes.\n   */\n  readRawString(length) {\n    return utf8ToString(this.readRawBytes(length))\n  }\n\n  /**\n   * Extracts a subarray from the current position in the buffer, prefixed with\n   * its length in bytes (encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedBytes() {\n    return this.readRawBytes(this.readUint53())\n  }\n\n  /**\n   * Reads a UTF-8 string from the current position in the buffer, prefixed with its\n   * length in bytes (where the length is encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedString() {\n    return utf8ToString(this.readPrefixedBytes())\n  }\n\n  /**\n   * Reads a byte array from the current position in the buffer, prefixed with its\n   * length in bytes. Returns that byte array converted to a hexadecimal string.\n   */\n  readHexString() {\n    return bytesToHexString(this.readPrefixedBytes())\n  }\n}\n\n/**\n * An encoder that uses run-length encoding to compress sequences of repeated\n * values. The constructor argument specifies the type of values, which may be\n * either 'int', 'uint', or 'utf8'. Besides valid values of the selected\n * datatype, values may also be null.\n *\n * The encoded buffer starts with a LEB128-encoded signed integer, the\n * repetition count. The interpretation of the following values depends on this\n * repetition count:\n *   - If this number is a positive value n, the next value in the buffer\n *     (encoded as the specified datatype) is repeated n times in the sequence.\n *   - If the repetition count is a negative value -n, then the next n values\n *     (encoded as the specified datatype) in the buffer are treated as a\n *     literal, i.e. they appear in the sequence without any further\n *     interpretation or repetition.\n *   - If the repetition count is zero, then the next value in the buffer is a\n *     LEB128-encoded unsigned integer indicating the number of null values\n *     that appear at the current position in the sequence.\n *\n * After one of these three has completed, the process repeats, starting again\n * with a repetition count, until we reach the end of the buffer.\n */\nclass RLEEncoder extends Encoder {\n  constructor(type) {\n    super()\n    this.type = type\n    this.state = 'empty'\n    this.lastValue = undefined\n    this.count = 0\n    this.literal = []\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    this._appendValue(value, repetitions)\n  }\n\n  /**\n   * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.\n   */\n  _appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (this.state === 'empty') {\n      this.state = (value === null ? 'nulls' : (repetitions === 1 ? 'loneValue' : 'repetition'))\n      this.lastValue = value\n      this.count = repetitions\n    } else if (this.state === 'loneValue') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.state = 'literal'\n        this.literal = [this.lastValue]\n        this.lastValue = value\n      }\n    } else if (this.state === 'repetition') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    } else if (this.state === 'literal') {\n      if (value === null) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.literal.push(this.lastValue)\n        this.lastValue = value\n      }\n    } else if (this.state === 'nulls') {\n      if (value === null) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    }\n  }\n\n  /**\n   * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may\n   * contain the following keys:\n   *  - `count`: The number of values to copy. If not specified, copies all remaining values.\n   *  - `sumValues`: If true, the function computes the sum of all numeric values as they are\n   *    copied (null values are counted as zero), and returns that number.\n   *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.\n   *\n   * Returns an object of the form `{nonNullValues, sum}` where `nonNullValues` is the number of\n   * non-null values copied, and `sum` is the sum (only if the `sumValues` option is set).\n   */\n  copyFrom(decoder, options = {}) {\n    const { count, sumValues, sumShift } = options\n    if (!(decoder instanceof RLEDecoder) || (decoder.type !== this.type)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER)\n    let nonNullValues = 0, sum = 0\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n\n    // Copy a value so that we have a well-defined starting state. NB: when super.copyFrom() is\n    // called by the DeltaEncoder subclass, the following calls to readValue() and appendValue()\n    // refer to the overridden methods, while later readRecord(), readRawValue() and _appendValue()\n    // calls refer to the non-overridden RLEDecoder/RLEEncoder methods.\n    let firstValue = decoder.readValue()\n    if (firstValue === null) {\n      const numNulls = Math.min(decoder.count + 1, remaining)\n      remaining -= numNulls\n      decoder.count -= numNulls - 1\n      this.appendValue(null, numNulls)\n      if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n      if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n      firstValue = decoder.readValue()\n      if (firstValue === null) throw new RangeError('null run must be followed by non-null value')\n    }\n    this.appendValue(firstValue)\n    remaining--\n    nonNullValues++\n    if (sumValues) sum += (sumShift ? (firstValue >>> sumShift) : firstValue)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n\n    // Copy data at the record level without expanding repetitions\n    let firstRun = (decoder.count > 0)\n    while (remaining > 0 && !decoder.done) {\n      if (!firstRun) decoder.readRecord()\n      const numValues = Math.min(decoder.count, remaining)\n      decoder.count -= numValues\n\n      if (decoder.state === 'literal') {\n        nonNullValues += numValues\n        for (let i = 0; i < numValues; i++) {\n          if (decoder.done) throw new RangeError('incomplete literal')\n          const value = decoder.readRawValue()\n          if (value === decoder.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n          decoder.lastValue = value\n          this._appendValue(value)\n          if (sumValues) sum += (sumShift ? (value >>> sumShift) : value)\n        }\n      } else if (decoder.state === 'repetition') {\n        nonNullValues += numValues\n        if (sumValues) sum += numValues * (sumShift ? (decoder.lastValue >>> sumShift) : decoder.lastValue)\n        const value = decoder.lastValue\n        this._appendValue(value)\n        if (numValues > 1) {\n          this._appendValue(value)\n          if (this.state !== 'repetition') throw new RangeError(`Unexpected state ${this.state}`)\n          this.count += numValues - 2\n        }\n      } else if (decoder.state === 'nulls') {\n        this._appendValue(null)\n        if (this.state !== 'nulls') throw new RangeError(`Unexpected state ${this.state}`)\n        this.count += numValues - 1\n      }\n\n      firstRun = false\n      remaining -= numValues\n    }\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    return sumValues ? {nonNullValues, sum} : {nonNullValues}\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  flush() {\n    if (this.state === 'loneValue') {\n      this.appendInt32(-1)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'repetition') {\n      this.appendInt53(this.count)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'literal') {\n      this.appendInt53(-this.literal.length)\n      for (let v of this.literal) this.appendRawValue(v)\n    } else if (this.state === 'nulls') {\n      this.appendInt32(0)\n      this.appendUint53(this.count)\n    }\n    this.state = 'empty'\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  appendRawValue(value) {\n    if (this.type === 'int') {\n      this.appendInt53(value)\n    } else if (this.type === 'uint') {\n      this.appendUint53(value)\n    } else if (this.type === 'utf8') {\n      this.appendPrefixedString(value)\n    } else {\n      throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.state === 'literal') this.literal.push(this.lastValue)\n    // Don't write anything if the only values we have seen are nulls\n    if (this.state !== 'nulls' || this.offset > 0) this.flush()\n  }\n}\n\n/**\n * Counterpart to RLEEncoder: reads values from an RLE-compressed sequence,\n * returning nulls and repeated values as required.\n */\nclass RLEDecoder extends Decoder {\n  constructor(type, buffer) {\n    super(buffer)\n    this.type = type\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns the next value (or null) in the sequence.\n   */\n  readValue() {\n    if (this.done) return null\n    if (this.count === 0) this.readRecord()\n    this.count -= 1\n    if (this.state === 'literal') {\n      const value = this.readRawValue()\n      if (value === this.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n      this.lastValue = value\n      return value\n    } else {\n      return this.lastValue\n    }\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readInt53()\n        if (this.count > 0) {\n          this.lastValue = (this.count <= numSkip) ? this.skipRawValues(1) : this.readRawValue()\n          this.state = 'repetition'\n        } else if (this.count < 0) {\n          this.count = -this.count\n          this.state = 'literal'\n        } else { // this.count == 0\n          this.count = this.readUint53()\n          this.lastValue = null\n          this.state = 'nulls'\n        }\n      }\n\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') this.skipRawValues(consume)\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads a repetition count from the buffer and sets up the state appropriately.\n   */\n  readRecord() {\n    this.count = this.readInt53()\n    if (this.count > 1) {\n      const value = this.readRawValue()\n      if ((this.state === 'repetition' || this.state === 'literal') && this.lastValue === value) {\n        throw new RangeError('Successive repetitions with the same value are not allowed')\n      }\n      this.state = 'repetition'\n      this.lastValue = value\n    } else if (this.count === 1) {\n      throw new RangeError('Repetition count of 1 is not allowed, use a literal instead')\n    } else if (this.count < 0) {\n      this.count = -this.count\n      if (this.state === 'literal') throw new RangeError('Successive literals are not allowed')\n      this.state = 'literal'\n    } else { // this.count == 0\n      if (this.state === 'nulls') throw new RangeError('Successive null runs are not allowed')\n      this.count = this.readUint53()\n      if (this.count === 0) throw new RangeError('Zero-length null runs are not allowed')\n      this.lastValue = null\n      this.state = 'nulls'\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads one value of the datatype configured on construction.\n   */\n  readRawValue() {\n    if (this.type === 'int') {\n      return this.readInt53()\n    } else if (this.type === 'uint') {\n      return this.readUint53()\n    } else if (this.type === 'utf8') {\n      return this.readPrefixedString()\n    } else {\n      throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Skips over `num` values of the datatype configured on construction.\n   */\n  skipRawValues(num) {\n    if (this.type === 'utf8') {\n      for (let i = 0; i < num; i++) this.skip(this.readUint53())\n    } else {\n      while (num > 0 && this.offset < this.buf.byteLength) {\n        if ((this.buf[this.offset] & 0x80) === 0) num--\n        this.offset++\n      }\n      if (num > 0) throw new RangeError('cannot skip beyond end of buffer')\n    }\n  }\n}\n\n/**\n * A variant of RLEEncoder: rather than storing the actual values passed to\n * appendValue(), this version stores only the first value, and for all\n * subsequent values it stores the difference to the previous value. This\n * encoding is good when values tend to come in sequentially incrementing runs,\n * because the delta between successive values is 1, and repeated values of 1\n * are easily compressed with run-length encoding.\n *\n * Null values are also allowed, as with RLEEncoder.\n */\nclass DeltaEncoder extends RLEEncoder {\n  constructor() {\n    super('int')\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (typeof value === 'number') {\n      super.appendValue(value - this.absoluteValue, 1)\n      this.absoluteValue = value\n      if (repetitions > 1) super.appendValue(0, repetitions - 1)\n    } else {\n      super.appendValue(value, repetitions)\n    }\n  }\n\n  /**\n   * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (options.sumValues) {\n      throw new RangeError('unsupported options for DeltaEncoder.copyFrom()')\n    }\n    if (!(decoder instanceof DeltaDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    let remaining = options.count\n    if (remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${remaining} values`)\n    if (remaining === 0 || decoder.done) return\n\n    // Copy any null values, and the first non-null value, so that appendValue() computes the\n    // difference between the encoder's last value and the decoder's first (absolute) value.\n    let value = decoder.readValue(), nulls = 0\n    this.appendValue(value)\n    if (value === null) {\n      nulls = decoder.count + 1\n      if (remaining !== undefined && remaining < nulls) nulls = remaining\n      decoder.count -= nulls - 1\n      this.count += nulls - 1\n      if (remaining > nulls && decoder.done) throw new RangeError(`cannot copy ${remaining} values`)\n      if (remaining === nulls || decoder.done) return\n\n      // The next value read is certain to be non-null because we're not at the end of the decoder,\n      // and a run of nulls must be followed by a run of non-nulls.\n      if (decoder.count === 0) this.appendValue(decoder.readValue())\n    }\n\n    // Once we have the first value, the subsequent relative values can be copied verbatim without\n    // any further processing. Note that the first value copied by super.copyFrom() is an absolute\n    // value, while subsequent values are relative. Thus, the sum of all of the (non-null) copied\n    // values must equal the absolute value of the final element copied.\n    if (remaining !== undefined) remaining -= nulls + 1\n    const { nonNullValues, sum } = super.copyFrom(decoder, {count: remaining, sumValues: true})\n    if (nonNullValues > 0) {\n      this.absoluteValue = sum\n      decoder.absoluteValue = sum\n    }\n  }\n}\n\n/**\n * Counterpart to DeltaEncoder: reads values from a delta-compressed sequence of\n * numbers (may include null values).\n */\nclass DeltaDecoder extends RLEDecoder {\n  constructor(buffer) {\n    super('int', buffer)\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Returns the next integer (or null) value in the sequence.\n   */\n  readValue() {\n    const value = super.readValue()\n    if (value === null) return null\n    this.absoluteValue += value\n    return this.absoluteValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) this.readRecord()\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') {\n        for (let i = 0; i < consume; i++) {\n          this.lastValue = this.readRawValue()\n          this.absoluteValue += this.lastValue\n        }\n      } else if (this.state === 'repetition') {\n        this.absoluteValue += consume * this.lastValue\n      }\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n}\n\n/**\n * Encodes a sequence of boolean values by mapping it to a sequence of integers:\n * the number of false values, followed by the number of true values, followed\n * by the number of false values, and so on. Each number is encoded as a LEB128\n * unsigned integer. This encoding is a bit like RLEEncoder, except that we\n * only encode the repetition count but not the actual value, since the values\n * just alternate between false and true (starting with false).\n */\nclass BooleanEncoder extends Encoder {\n  constructor() {\n    super()\n    this.lastValue = false\n    this.count = 0\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (value !== false && value !== true) {\n      throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`)\n    }\n    if (repetitions <= 0) return\n    if (this.lastValue === value) {\n      this.count += repetitions\n    } else {\n      this.appendUint53(this.count)\n      this.lastValue = value\n      this.count = repetitions\n    }\n  }\n\n  /**\n   * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (!(decoder instanceof BooleanDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    const { count } = options\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return\n\n    // Copy one value to bring decoder and encoder state into sync, then finish that value's repetitions\n    this.appendValue(decoder.readValue())\n    remaining--\n    const firstCopy = Math.min(decoder.count, remaining)\n    this.count += firstCopy\n    decoder.count -= firstCopy\n    remaining -= firstCopy\n\n    while (remaining > 0 && !decoder.done) {\n      decoder.count = decoder.readUint53()\n      if (decoder.count === 0) throw new RangeError('Zero-length runs are not allowed')\n      decoder.lastValue = !decoder.lastValue\n      this.appendUint53(this.count)\n\n      const numCopied = Math.min(decoder.count, remaining)\n      this.count = numCopied\n      this.lastValue = decoder.lastValue\n      decoder.count -= numCopied\n      remaining -= numCopied\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.count > 0) {\n      this.appendUint53(this.count)\n      this.count = 0\n    }\n  }\n}\n\n/**\n * Counterpart to BooleanEncoder: reads boolean values from a runlength-encoded\n * sequence.\n */\nclass BooleanDecoder extends Decoder {\n  constructor(buffer) {\n    super(buffer)\n    this.lastValue = true // is negated the first time we read a count\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = true\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns the next value in the sequence.\n   */\n  readValue() {\n    if (this.done) return false\n    while (this.count === 0) {\n      this.count = this.readUint53()\n      this.lastValue = !this.lastValue\n      if (this.count === 0 && !this.firstRun) {\n        throw new RangeError('Zero-length runs are not allowed')\n      }\n      this.firstRun = false\n    }\n    this.count -= 1\n    return this.lastValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readUint53()\n        this.lastValue = !this.lastValue\n        if (this.count === 0 && !this.firstRun) {\n          throw new RangeError('Zero-length runs are not allowed')\n        }\n        this.firstRun = false\n      }\n      if (this.count < numSkip) {\n        numSkip -= this.count\n        this.count = 0\n      } else {\n        this.count -= numSkip\n        numSkip = 0\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  stringToUtf8, utf8ToString, hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n}\n"]},"metadata":{},"sourceType":"script"}