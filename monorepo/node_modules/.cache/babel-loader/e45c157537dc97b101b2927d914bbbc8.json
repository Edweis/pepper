{"ast":null,"code":"const {\n  OBJECT_ID,\n  CHANGE,\n  STATE\n} = require('./constants');\n\nconst {\n  createArrayOfNulls\n} = require('../src/common');\n\nconst {\n  Text\n} = require('./text');\n\nconst {\n  Table\n} = require('./table');\n\nfunction parseListIndex(key) {\n  if (typeof key === 'string' && /^[0-9]+$/.test(key)) key = parseInt(key, 10);\n\n  if (typeof key !== 'number') {\n    throw new TypeError('A list index must be a number, but you passed ' + JSON.stringify(key));\n  }\n\n  if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n    throw new RangeError('A list index must be positive, but you passed ' + key);\n  }\n\n  return key;\n}\n\nfunction listMethods(context, listId, path) {\n  const methods = {\n    deleteAt(index, numDelete) {\n      context.splice(path, parseListIndex(index), numDelete || 1, []);\n      return this;\n    },\n\n    fill(value, start, end) {\n      let list = context.getObject(listId);\n\n      for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {\n        context.setListIndex(path, index, value);\n      }\n\n      return this;\n    },\n\n    indexOf(o) {\n      let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const id = o[OBJECT_ID];\n\n      if (id) {\n        const list = context.getObject(listId);\n\n        for (let index = start; index < list.length; index++) {\n          if (list[index][OBJECT_ID] === id) {\n            return index;\n          }\n        }\n\n        return -1;\n      } else {\n        return context.getObject(listId).indexOf(o, start);\n      }\n    },\n\n    insertAt(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n\n      context.splice(path, parseListIndex(index), 0, values);\n      return this;\n    },\n\n    pop() {\n      let list = context.getObject(listId);\n      if (list.length == 0) return;\n      const last = context.getObjectField(path, listId, list.length - 1);\n      context.splice(path, list.length - 1, 1, []);\n      return last;\n    },\n\n    push() {\n      let list = context.getObject(listId);\n\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      context.splice(path, list.length, 0, values); // need to getObject() again because the list object above may be immutable\n\n      return context.getObject(listId).length;\n    },\n\n    shift() {\n      let list = context.getObject(listId);\n      if (list.length == 0) return;\n      const first = context.getObjectField(path, listId, 0);\n      context.splice(path, 0, 1, []);\n      return first;\n    },\n\n    splice(start, deleteCount) {\n      let list = context.getObject(listId);\n      start = parseListIndex(start);\n\n      if (deleteCount === undefined || deleteCount > list.length - start) {\n        deleteCount = list.length - start;\n      }\n\n      const deleted = [];\n\n      for (let n = 0; n < deleteCount; n++) {\n        deleted.push(context.getObjectField(path, listId, start + n));\n      }\n\n      for (var _len3 = arguments.length, values = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        values[_key3 - 2] = arguments[_key3];\n      }\n\n      context.splice(path, start, deleteCount, values);\n      return deleted;\n    },\n\n    unshift() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n\n      context.splice(path, 0, 0, values);\n      return context.getObject(listId).length;\n    }\n\n  };\n\n  for (let iterator of ['entries', 'keys', 'values']) {\n    let list = context.getObject(listId);\n\n    methods[iterator] = () => list[iterator]();\n  } // Read-only methods that can delegate to the JavaScript built-in implementations\n\n\n  for (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some', 'toLocaleString', 'toString']) {\n    methods[method] = function () {\n      const list = context.getObject(listId).map((item, index) => context.getObjectField(path, listId, index));\n      return list[method](...arguments);\n    };\n  }\n\n  return methods;\n}\n\nconst MapHandler = {\n  get(target, key) {\n    const {\n      context,\n      objectId,\n      path\n    } = target;\n    if (key === OBJECT_ID) return objectId;\n    if (key === CHANGE) return context;\n    if (key === STATE) return {\n      actorId: context.actorId\n    };\n    return context.getObjectField(path, objectId, key);\n  },\n\n  set(target, key, value) {\n    const {\n      context,\n      path,\n      readonly\n    } = target;\n\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`);\n    }\n\n    context.setMapKey(path, key, value);\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    const {\n      context,\n      path,\n      readonly\n    } = target;\n\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`);\n    }\n\n    context.deleteMapKey(path, key);\n    return true;\n  },\n\n  has(target, key) {\n    const {\n      context,\n      objectId\n    } = target;\n    return [OBJECT_ID, CHANGE].includes(key) || key in context.getObject(objectId);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    const {\n      context,\n      objectId\n    } = target;\n    const object = context.getObject(objectId);\n\n    if (key in object) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value: context.getObjectField(objectId, key)\n      };\n    }\n  },\n\n  ownKeys(target) {\n    const {\n      context,\n      objectId\n    } = target;\n    return Object.keys(context.getObject(objectId));\n  }\n\n};\nconst ListHandler = {\n  get(target, key) {\n    const [context, objectId, path] = target;\n    if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator];\n    if (key === OBJECT_ID) return objectId;\n    if (key === CHANGE) return context;\n    if (key === 'length') return context.getObject(objectId).length;\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return context.getObjectField(path, objectId, parseListIndex(key));\n    }\n\n    return listMethods(context, objectId, path)[key];\n  },\n\n  set(target, key, value) {\n    const [context, objectId, path] = target;\n\n    if (key === 'length') {\n      if (typeof value !== 'number') {\n        throw new RangeError(\"Invalid array length\");\n      }\n\n      const length = context.getObject(objectId).length;\n\n      if (length > value) {\n        context.splice(path, value, length - value, []);\n      } else {\n        context.splice(path, length, 0, createArrayOfNulls(value - length));\n      }\n    } else {\n      context.setListIndex(path, parseListIndex(key), value);\n    }\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    const [\n      /* objectId */\n    context,, path] = target;\n    context.splice(path, parseListIndex(key), 1, []);\n    return true;\n  },\n\n  has(target, key) {\n    const [context, objectId\n    /* path */\n    ] = target;\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return parseListIndex(key) < context.getObject(objectId).length;\n    }\n\n    return ['length', OBJECT_ID, CHANGE].includes(key);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    const [context, objectId\n    /* path */\n    ] = target;\n    const object = context.getObject(objectId);\n    if (key === 'length') return {\n      writable: true,\n      value: object.length\n    };\n    if (key === OBJECT_ID) return {\n      configurable: false,\n      enumerable: false,\n      value: objectId\n    };\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      const index = parseListIndex(key);\n      if (index < object.length) return {\n        configurable: true,\n        enumerable: true,\n        value: context.getObjectField(objectId, index)\n      };\n    }\n  },\n\n  ownKeys(target) {\n    const [context, objectId\n    /* path */\n    ] = target;\n    const object = context.getObject(objectId);\n    let keys = ['length'];\n\n    for (let key of Object.keys(object)) keys.push(key);\n\n    return keys;\n  }\n\n};\n\nfunction mapProxy(context, objectId, path, readonly) {\n  return new Proxy({\n    context,\n    objectId,\n    path,\n    readonly\n  }, MapHandler);\n}\n\nfunction listProxy(context, objectId, path) {\n  return new Proxy([context, objectId, path], ListHandler);\n}\n/**\n * Instantiates a proxy object for the given `objectId`.\n * This function is added as a method to the context object by rootObjectProxy().\n * When it is called, `this` is the context object.\n * `readonly` is a list of map property names that cannot be modified.\n */\n\n\nfunction instantiateProxy(path, objectId, readonly) {\n  const object = this.getObject(objectId);\n\n  if (Array.isArray(object)) {\n    return listProxy(this, objectId, path);\n  } else if (object instanceof Text || object instanceof Table) {\n    return object.getWriteable(this, path);\n  } else {\n    return mapProxy(this, objectId, path, readonly);\n  }\n}\n\nfunction rootObjectProxy(context) {\n  context.instantiateObject = instantiateProxy;\n  return mapProxy(context, '_root', []);\n}\n\nmodule.exports = {\n  rootObjectProxy\n};","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/automerge/frontend/proxies.js"],"names":["OBJECT_ID","CHANGE","STATE","require","createArrayOfNulls","Text","Table","parseListIndex","key","test","parseInt","TypeError","JSON","stringify","isNaN","Infinity","RangeError","listMethods","context","listId","path","methods","deleteAt","index","numDelete","splice","fill","value","start","end","list","getObject","length","setListIndex","indexOf","o","id","insertAt","values","pop","last","getObjectField","push","shift","first","deleteCount","undefined","deleted","n","unshift","iterator","method","map","item","MapHandler","get","target","objectId","actorId","set","readonly","Array","isArray","setMapKey","deleteProperty","deleteMapKey","has","includes","getOwnPropertyDescriptor","object","configurable","enumerable","ownKeys","Object","keys","ListHandler","Symbol","writable","mapProxy","Proxy","listProxy","instantiateProxy","getWriteable","rootObjectProxy","instantiateObject","module","exports"],"mappings":"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","sourcesContent":["const { OBJECT_ID, CHANGE, STATE } = require('./constants')\nconst { createArrayOfNulls } = require('../src/common')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\n\nfunction parseListIndex(key) {\n  if (typeof key === 'string' && /^[0-9]+$/.test(key)) key = parseInt(key, 10)\n  if (typeof key !== 'number') {\n    throw new TypeError('A list index must be a number, but you passed ' + JSON.stringify(key))\n  }\n  if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n    throw new RangeError('A list index must be positive, but you passed ' + key)\n  }\n  return key\n}\n\nfunction listMethods(context, listId, path) {\n  const methods = {\n    deleteAt(index, numDelete) {\n      context.splice(path, parseListIndex(index), numDelete || 1, [])\n      return this\n    },\n\n    fill(value, start, end) {\n      let list = context.getObject(listId)\n      for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {\n        context.setListIndex(path, index, value)\n      }\n      return this\n    },\n\n    indexOf(o, start = 0) {\n      const id = o[OBJECT_ID]\n      if (id) {\n        const list = context.getObject(listId)\n        for (let index = start; index < list.length; index++) {\n          if (list[index][OBJECT_ID] === id) {\n            return index\n          }\n        }\n        return -1\n      } else {\n        return context.getObject(listId).indexOf(o, start)\n      }\n    },\n\n    insertAt(index, ...values) {\n      context.splice(path, parseListIndex(index), 0, values)\n      return this\n    },\n\n    pop() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const last = context.getObjectField(path, listId, list.length - 1)\n      context.splice(path, list.length - 1, 1, [])\n      return last\n    },\n\n    push(...values) {\n      let list = context.getObject(listId)\n      context.splice(path, list.length, 0, values)\n      // need to getObject() again because the list object above may be immutable\n      return context.getObject(listId).length\n    },\n\n    shift() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const first = context.getObjectField(path, listId, 0)\n      context.splice(path, 0, 1, [])\n      return first\n    },\n\n    splice(start, deleteCount, ...values) {\n      let list = context.getObject(listId)\n      start = parseListIndex(start)\n      if (deleteCount === undefined || deleteCount > list.length - start) {\n        deleteCount = list.length - start\n      }\n      const deleted = []\n      for (let n = 0; n < deleteCount; n++) {\n        deleted.push(context.getObjectField(path, listId, start + n))\n      }\n      context.splice(path, start, deleteCount, values)\n      return deleted\n    },\n\n    unshift(...values) {\n      context.splice(path, 0, 0, values)\n      return context.getObject(listId).length\n    }\n  }\n\n  for (let iterator of ['entries', 'keys', 'values']) {\n    let list = context.getObject(listId)\n    methods[iterator] = () => list[iterator]()\n  }\n\n  // Read-only methods that can delegate to the JavaScript built-in implementations\n  for (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                      'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                      'slice', 'some', 'toLocaleString', 'toString']) {\n    methods[method] = (...args) => {\n      const list = context.getObject(listId)\n        .map((item, index) => context.getObjectField(path, listId, index))\n      return list[method](...args)\n    }\n  }\n\n  return methods\n}\n\nconst MapHandler = {\n  get (target, key) {\n    const { context, objectId, path } = target\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === STATE) return {actorId: context.actorId}\n    return context.getObjectField(path, objectId, key)\n  },\n\n  set (target, key, value) {\n    const { context, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.setMapKey(path, key, value)\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const { context, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.deleteMapKey(path, key)\n    return true\n  },\n\n  has (target, key) {\n    const { context, objectId } = target\n    return [OBJECT_ID, CHANGE].includes(key) || (key in context.getObject(objectId))\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    const { context, objectId } = target\n    const object = context.getObject(objectId)\n    if (key in object) {\n      return {\n        configurable: true, enumerable: true,\n        value: context.getObjectField(objectId, key)\n      }\n    }\n  },\n\n  ownKeys (target) {\n    const { context, objectId } = target\n    return Object.keys(context.getObject(objectId))\n  }\n}\n\nconst ListHandler = {\n  get (target, key) {\n    const [context, objectId, path] = target\n    if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator]\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === 'length') return context.getObject(objectId).length\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return context.getObjectField(path, objectId, parseListIndex(key))\n    }\n    return listMethods(context, objectId, path)[key]\n  },\n\n  set (target, key, value) {\n    const [context, objectId, path] = target\n    if (key === 'length') {\n      if (typeof value !== 'number') {\n        throw new RangeError(\"Invalid array length\")\n      }\n      const length = context.getObject(objectId).length\n      if (length > value) {\n        context.splice(path, value, length - value, [])\n      } else {\n        context.splice(path, length, 0, createArrayOfNulls(value - length))\n      }\n    } else {\n      context.setListIndex(path, parseListIndex(key), value)\n    }\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const [context, /* objectId */, path] = target\n    context.splice(path, parseListIndex(key), 1, [])\n    return true\n  },\n\n  has (target, key) {\n    const [context, objectId, /* path */] = target\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return parseListIndex(key) < context.getObject(objectId).length\n    }\n    return ['length', OBJECT_ID, CHANGE].includes(key)\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    const [context, objectId, /* path */] = target\n    const object = context.getObject(objectId)\n\n    if (key === 'length') return {writable: true, value: object.length}\n    if (key === OBJECT_ID) return {configurable: false, enumerable: false, value: objectId}\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      const index = parseListIndex(key)\n      if (index < object.length) return {\n        configurable: true, enumerable: true,\n        value: context.getObjectField(objectId, index)\n      }\n    }\n  },\n\n  ownKeys (target) {\n    const [context, objectId, /* path */] = target\n    const object = context.getObject(objectId)\n    let keys = ['length']\n    for (let key of Object.keys(object)) keys.push(key)\n    return keys\n  }\n}\n\nfunction mapProxy(context, objectId, path, readonly) {\n  return new Proxy({context, objectId, path, readonly}, MapHandler)\n}\n\nfunction listProxy(context, objectId, path) {\n  return new Proxy([context, objectId, path], ListHandler)\n}\n\n/**\n * Instantiates a proxy object for the given `objectId`.\n * This function is added as a method to the context object by rootObjectProxy().\n * When it is called, `this` is the context object.\n * `readonly` is a list of map property names that cannot be modified.\n */\nfunction instantiateProxy(path, objectId, readonly) {\n  const object = this.getObject(objectId)\n  if (Array.isArray(object)) {\n    return listProxy(this, objectId, path)\n  } else if (object instanceof Text || object instanceof Table) {\n    return object.getWriteable(this, path)\n  } else {\n    return mapProxy(this, objectId, path, readonly)\n  }\n}\n\nfunction rootObjectProxy(context) {\n  context.instantiateObject = instantiateProxy\n  return mapProxy(context, '_root', [])\n}\n\nmodule.exports = { rootObjectProxy }\n"]},"metadata":{},"sourceType":"script"}