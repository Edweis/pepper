{"ast":null,"code":"'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n\n/* ===========================================================================*/\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\n\nconst Z_FIXED = 4; //const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n\nconst Z_BINARY = 0;\nconst Z_TEXT = 1; //const Z_ASCII             = 1; // = Z_TEXT\n\nconst Z_UNKNOWN = 2;\n/*============================================================================*/\n\nfunction zero(buf) {\n  let len = buf.length;\n\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n} // From zutil.h\n\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\n/* The minimum and maximum match lengths */\n// From deflate.h\n\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES = 30;\n/* number of distance codes */\n\nconst BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */\n\nconst MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size = 16;\n/* size of bit buffer in bi_buf */\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK = 256;\n/* end of block literal code */\n\nconst REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\n\nconst extra_lbits =\n/* extra bits for each length code */\nnew Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\nconst extra_dbits =\n/* extra bits for each distance code */\nnew Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\nconst extra_blbits =\n/* extra bits for each bit length code */\nnew Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\nconst bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512;\n/* see definition of array dist_code below */\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\nconst static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code = new Array(DIST_CODE_LEN);\n\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  this.static_tree = static_tree;\n  /* static tree or NULL */\n\n  this.extra_bits = extra_bits;\n  /* extra bits for each code or NULL */\n\n  this.extra_base = extra_base;\n  /* base index for extra_bits */\n\n  this.elems = elems;\n  /* max number of elements in the tree */\n\n  this.max_length = max_length;\n  /* max bit length for the codes */\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n  this.has_stree = static_tree && static_tree.length;\n}\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;\n  /* the dynamic tree */\n\n  this.max_code = 0;\n  /* largest code with non zero frequency */\n\n  this.stat_desc = stat_desc;\n  /* the corresponding static tree */\n}\n\nconst d_code = dist => {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n\n\nconst put_short = (s, w) => {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = w & 0xff;\n  s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n};\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n\n\nconst send_bits = (s, value, length) => {\n  if (s.bi_valid > Buf_size - length) {\n    s.bi_buf |= value << s.bi_valid & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> Buf_size - s.bi_valid;\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= value << s.bi_valid & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\nconst send_code = (s, c, tree) => {\n  send_bits(s, tree[c * 2]\n  /*.Code*/\n  , tree[c * 2 + 1]\n  /*.Len*/\n  );\n};\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\n\n\nconst bi_reverse = (code, len) => {\n  let res = 0;\n\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n\n  return res >>> 1;\n};\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\n\n\nconst bi_flush = s => {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\n\n\nconst gen_bitlen = (s, desc) => //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  const tree = desc.dyn_tree;\n  const max_code = desc.max_code;\n  const stree = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const extra = desc.stat_desc.extra_bits;\n  const base = desc.stat_desc.extra_base;\n  const max_length = desc.stat_desc.max_length;\n  let h;\n  /* heap index */\n\n  let n, m;\n  /* iterate over the tree elements */\n\n  let bits;\n  /* bit length */\n\n  let xbits;\n  /* extra bits */\n\n  let f;\n  /* frequency */\n\n  let overflow = 0;\n  /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n\n\n  tree[s.heap[s.heap_max] * 2 + 1]\n  /*.Len*/\n  = 0;\n  /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]\n    /*.Dad*/\n    * 2 + 1]\n    /*.Len*/\n    + 1;\n\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n\n    tree[n * 2 + 1]\n    /*.Len*/\n    = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) {\n      continue;\n    }\n    /* not a leaf node */\n\n\n    s.bl_count[bits]++;\n    xbits = 0;\n\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n\n    f = tree[n * 2]\n    /*.Freq*/\n    ;\n    s.opt_len += f * (bits + xbits);\n\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]\n      /*.Len*/\n      + xbits);\n    }\n  }\n\n  if (overflow === 0) {\n    return;\n  } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n\n\n  do {\n    bits = max_length - 1;\n\n    while (s.bl_count[bits] === 0) {\n      bits--;\n    }\n\n    s.bl_count[bits]--;\n    /* move one leaf down the tree */\n\n    s.bl_count[bits + 1] += 2;\n    /* move one overflow item as its brother */\n\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n\n    overflow -= 2;\n  } while (overflow > 0);\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n\n\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n\n    while (n !== 0) {\n      m = s.heap[--h];\n\n      if (m > max_code) {\n        continue;\n      }\n\n      if (tree[m * 2 + 1]\n      /*.Len*/\n      !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]\n        /*.Len*/\n        ) * tree[m * 2]\n        /*.Freq*/\n        ;\n        tree[m * 2 + 1]\n        /*.Len*/\n        = bits;\n      }\n\n      n--;\n    }\n  }\n};\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\n\n\nconst gen_codes = (tree, max_code, bl_count) => //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  const next_code = new Array(MAX_BITS + 1);\n  /* next code value for each bit length */\n\n  let code = 0;\n  /* running code value */\n\n  let bits;\n  /* bit index */\n\n  let n;\n  /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = code + bl_count[bits - 1] << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n  for (n = 0; n <= max_code; n++) {\n    let len = tree[n * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (len === 0) {\n      continue;\n    }\n    /* Now reverse the bits */\n\n\n    tree[n * 2]\n    /*.Code*/\n    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\n\n\nconst tr_static_init = () => {\n  let n;\n  /* iterates over tree elements */\n\n  let bits;\n  /* bit counter */\n\n  let length;\n  /* length value */\n\n  let code;\n  /* code value */\n\n  let dist;\n  /* distance index */\n\n  const bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n  length = 0;\n\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n\n    for (n = 0; n < 1 << extra_lbits[code]; n++) {\n      _length_code[length++] = code;\n    }\n  } //Assert (length == 256, \"tr_static_init: length != 256\");\n\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n\n\n  _length_code[length - 1] = code;\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n  dist = 0;\n\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n\n    for (n = 0; n < 1 << extra_dbits[code]; n++) {\n      _dist_code[dist++] = code;\n    }\n  } //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n\n  dist >>= 7;\n  /* from now on, all distances are divided by 128 */\n\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n\n    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  } //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 8;\n    n++;\n    bl_count[8]++;\n  }\n\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 9;\n    n++;\n    bl_count[9]++;\n  }\n\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 7;\n    n++;\n    bl_count[7]++;\n  }\n\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]\n    /*.Len*/\n    = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n\n\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n  /* The static distance tree is trivial: */\n\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]\n    /*.Len*/\n    = 5;\n    static_dtree[n * 2]\n    /*.Code*/\n    = bi_reverse(n, 5);\n  } // Now data ready and we can init static trees\n\n\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;\n};\n/* ===========================================================================\n * Initialize a new block.\n */\n\n\nconst init_block = s => {\n  let n;\n  /* iterates over tree elements */\n\n  /* Initialize the trees. */\n\n  for (n = 0; n < L_CODES; n++) {\n    s.dyn_ltree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  for (n = 0; n < D_CODES; n++) {\n    s.dyn_dtree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  for (n = 0; n < BL_CODES; n++) {\n    s.bl_tree[n * 2]\n    /*.Freq*/\n    = 0;\n  }\n\n  s.dyn_ltree[END_BLOCK * 2]\n  /*.Freq*/\n  = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n};\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\n\n\nconst bi_windup = s => {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\n\n\nconst copy_block = (s, buf, len, header) => //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);\n  /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  } //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n\n\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n  s.pending += len;\n};\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n\n\nconst smaller = (tree, n, m, depth) => {\n  const _n2 = n * 2;\n\n  const _m2 = m * 2;\n\n  return tree[_n2]\n  /*.Freq*/\n  < tree[_m2]\n  /*.Freq*/\n  || tree[_n2]\n  /*.Freq*/\n  === tree[_m2]\n  /*.Freq*/\n  && depth[n] <= depth[m];\n};\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\n\n\nconst pqdownheap = (s, tree, k) => //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  const v = s.heap[k];\n  let j = k << 1;\n  /* left son of k */\n\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n\n\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break;\n    }\n    /* Exchange v with the smallest son */\n\n\n    s.heap[k] = s.heap[j];\n    k = j;\n    /* And continue down the tree, setting j to the left son of k */\n\n    j <<= 1;\n  }\n\n  s.heap[k] = v;\n}; // inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\n\n\nconst compress_block = (s, ltree, dtree) => //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  let dist;\n  /* distance of matched string */\n\n  let lc;\n  /* match length or unmatched char (if dist == 0) */\n\n  let lx = 0;\n  /* running index in l_buf */\n\n  let code;\n  /* the code to send */\n\n  let extra;\n  /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree);\n        /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree);\n        /* send the length code */\n\n        extra = extra_lbits[code];\n\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);\n          /* send the extra length bits */\n        }\n\n        dist--;\n        /* dist is now the match distance - 1 */\n\n        code = d_code(dist); //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);\n        /* send the distance code */\n\n        extra = extra_dbits[code];\n\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);\n          /* send the extra distance bits */\n        }\n      }\n      /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\n\n\nconst build_tree = (s, desc) => //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  const tree = desc.dyn_tree;\n  const stree = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems = desc.stat_desc.elems;\n  let n, m;\n  /* iterate over heap elements */\n\n  let max_code = -1;\n  /* largest code with non zero frequency */\n\n  let node;\n  /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n    } else {\n      tree[n * 2 + 1]\n      /*.Len*/\n      = 0;\n    }\n  }\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n\n\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n    tree[node * 2]\n    /*.Freq*/\n    = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]\n      /*.Len*/\n      ;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n\n  }\n\n  desc.max_code = max_code;\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n\n  for (n = s.heap_len >> 1\n  /*int /2*/\n  ; n >= 1; n--) {\n    pqdownheap(s, tree, n);\n  }\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n\n\n  node = elems;\n  /* next internal node of the tree */\n\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n\n    /*** pqremove ***/\n    n = s.heap[1\n    /*SMALLEST*/\n    ];\n    s.heap[1\n    /*SMALLEST*/\n    ] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1\n    /*SMALLEST*/\n    );\n    /***/\n\n    m = s.heap[1\n    /*SMALLEST*/\n    ];\n    /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n;\n    /* keep the nodes sorted by frequency */\n\n    s.heap[--s.heap_max] = m;\n    /* Create a new node father of n and m */\n\n    tree[node * 2]\n    /*.Freq*/\n    = tree[n * 2]\n    /*.Freq*/\n    + tree[m * 2]\n    /*.Freq*/\n    ;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]\n    /*.Dad*/\n    = tree[m * 2 + 1]\n    /*.Dad*/\n    = node;\n    /* and insert the new node in the heap */\n\n    s.heap[1\n    /*SMALLEST*/\n    ] = node++;\n    pqdownheap(s, tree, 1\n    /*SMALLEST*/\n    );\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1\n  /*SMALLEST*/\n  ];\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n\n  gen_bitlen(s, desc);\n  /* The field len is now set, we can generate the bit codes */\n\n  gen_codes(tree, max_code, s.bl_count);\n};\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\n\n\nconst scan_tree = (s, tree, max_code) => //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  let n;\n  /* iterates over all tree elements */\n\n  let prevlen = -1;\n  /* last emitted length */\n\n  let curlen;\n  /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]\n  /*.Len*/\n  ;\n  /* length of next code */\n\n  let count = 0;\n  /* repeat count of the current code */\n\n  let max_count = 7;\n  /* max repeat count */\n\n  let min_count = 4;\n  /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  tree[(max_code + 1) * 2 + 1]\n  /*.Len*/\n  = 0xffff;\n  /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]\n      /*.Freq*/\n      += count;\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2] /*.Freq*/++;\n      }\n\n      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;\n    } else {\n      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\n\n\nconst send_tree = (s, tree, max_code) => //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  let n;\n  /* iterates over all tree elements */\n\n  let prevlen = -1;\n  /* last emitted length */\n\n  let curlen;\n  /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]\n  /*.Len*/\n  ;\n  /* length of next code */\n\n  let count = 0;\n  /* repeat count of the current code */\n\n  let max_count = 7;\n  /* max repeat count */\n\n  let min_count = 4;\n  /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */\n\n  /* guard already set */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]\n    /*.Len*/\n    ;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree);\n      } while (--count !== 0);\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      } //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\n\n\nconst build_bl_tree = s => {\n  let max_blindex;\n  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n  /* Build the bit length tree: */\n\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]\n    /*.Len*/\n    !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n\n\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\n\n\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  let rank;\n  /* index in bl_order */\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n\n  send_bits(s, lcodes - 257, 5);\n  /* not +255 as stated in appnote.txt */\n\n  send_bits(s, dcodes - 1, 5);\n  send_bits(s, blcodes - 4, 4);\n  /* not -3 as stated in appnote.txt */\n\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]\n    /*.Len*/\n    , 3);\n  } //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n\n  send_tree(s, s.dyn_ltree, lcodes - 1);\n  /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1);\n  /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\n\n\nconst detect_data_type = s => {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let black_mask = 0xf3ffc07f;\n  let n;\n  /* Check for non-textual (\"black-listed\") bytes. */\n\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if (black_mask & 1 && s.dyn_ltree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      return Z_BINARY;\n    }\n  }\n  /* Check for textual (\"white-listed\") bytes. */\n\n\n  if (s.dyn_ltree[9 * 2]\n  /*.Freq*/\n  !== 0 || s.dyn_ltree[10 * 2]\n  /*.Freq*/\n  !== 0 || s.dyn_ltree[13 * 2]\n  /*.Freq*/\n  !== 0) {\n    return Z_TEXT;\n  }\n\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]\n    /*.Freq*/\n    !== 0) {\n      return Z_TEXT;\n    }\n  }\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n\n\n  return Z_BINARY;\n};\n\nlet static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\n\nconst _tr_init = s => {\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n  /* Initialize the first block of the first file: */\n\n  init_block(s);\n};\n/* ===========================================================================\n * Send a stored block\n */\n\n\nconst _tr_stored_block = (s, buf, stored_len, last) => //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n  /* send block type */\n\n  copy_block(s, buf, stored_len, true);\n  /* with header */\n};\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\n\n\nconst _tr_align = s => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\n\n\nconst _tr_flush_block = (s, buf, stored_len, last) => //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  let opt_lenb, static_lenb;\n  /* opt_len and static_len in bytes */\n\n  let max_blindex = 0;\n  /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n\n  if (s.level > 0) {\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n    /* Construct the literal and distance trees */\n\n\n    build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n\n    max_blindex = build_bl_tree(s);\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n\n    opt_lenb = s.opt_len + 3 + 7 >>> 3;\n    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb;\n    }\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5;\n    /* force a stored block */\n  }\n\n  if (stored_len + 4 <= opt_lenb && buf !== -1) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n\n\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n\n};\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\n\n\nconst _tr_tally = (s, dist, lc) => //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //let out_length, in_length, dcode;\n  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2] /*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n\n    dist--;\n    /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;\n  } // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n\n  return s.last_lit === s.lit_bufsize - 1;\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n};\n\nmodule.exports._tr_init = _tr_init;\nmodule.exports._tr_stored_block = _tr_stored_block;\nmodule.exports._tr_flush_block = _tr_flush_block;\nmodule.exports._tr_tally = _tr_tally;\nmodule.exports._tr_align = _tr_align;","map":{"version":3,"sources":["/home/eydwales/Documents/edweis/pepper/node_modules/pako/lib/zlib/trees.js"],"names":["Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","length","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","set","window","subarray","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_init","_tr_stored_block","stored_len","last","_tr_align","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","strategy","_tr_tally","lit_bufsize","module","exports"],"mappings":"AAAA,a,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AACA;AAGA;AACA;AACA;;AACA,MAAMA,OAAO,GAAiB,CAA9B,C,CACA;;AAEA;;AACA,MAAMC,QAAQ,GAAgB,CAA9B;AACA,MAAMC,MAAM,GAAkB,CAA9B,C,CACA;;AACA,MAAMC,SAAS,GAAe,CAA9B;AAEA;;AAGA,SAASC,IAAT,CAAcC,GAAd,EAAmB;AAAE,MAAIC,GAAG,GAAGD,GAAG,CAACE,MAAd;;AAAsB,SAAO,EAAED,GAAF,IAAS,CAAhB,EAAmB;AAAED,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,CAAX;AAAe;AAAE,C,CAEjF;;;AAEA,MAAME,YAAY,GAAG,CAArB;AACA,MAAMC,YAAY,GAAG,CAArB;AACA,MAAMC,SAAS,GAAM,CAArB;AACA;;AAEA,MAAMC,SAAS,GAAM,CAArB;AACA,MAAMC,SAAS,GAAM,GAArB;AACA;AAEA;;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAI,EAAtB;AACA;;AAEA,MAAMC,QAAQ,GAAQ,GAAtB;AACA;;AAEA,MAAMC,OAAO,GAASD,QAAQ,GAAG,CAAX,GAAeD,YAArC;AACA;;AAEA,MAAMG,OAAO,GAAS,EAAtB;AACA;;AAEA,MAAMC,QAAQ,GAAQ,EAAtB;AACA;;AAEA,MAAMC,SAAS,GAAO,IAAIH,OAAJ,GAAc,CAApC;AACA;;AAEA,MAAMI,QAAQ,GAAQ,EAAtB;AACA;;AAEA,MAAMC,QAAQ,GAAQ,EAAtB;AACA;;AAGA;AACA;AACA;;AAEA,MAAMC,WAAW,GAAG,CAApB;AACA;;AAEA,MAAMC,SAAS,GAAK,GAApB;AACA;;AAEA,MAAMC,OAAO,GAAO,EAApB;AACA;;AAEA,MAAMC,SAAS,GAAK,EAApB;AACA;;AAEA,MAAMC,WAAW,GAAG,EAApB;AACA;;AAEA;;AACA,MAAMC,WAAW;AAAK;AACpB,IAAIC,UAAJ,CAAe,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,EAAe,CAAf,EAAiB,CAAjB,EAAmB,CAAnB,EAAqB,CAArB,EAAuB,CAAvB,EAAyB,CAAzB,EAA2B,CAA3B,EAA6B,CAA7B,EAA+B,CAA/B,EAAiC,CAAjC,EAAmC,CAAnC,EAAqC,CAArC,EAAuC,CAAvC,EAAyC,CAAzC,EAA2C,CAA3C,EAA6C,CAA7C,EAA+C,CAA/C,EAAiD,CAAjD,EAAmD,CAAnD,EAAqD,CAArD,EAAuD,CAAvD,EAAyD,CAAzD,CAAf,CADF;AAGA,MAAMC,WAAW;AAAK;AACpB,IAAID,UAAJ,CAAe,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,EAAe,CAAf,EAAiB,CAAjB,EAAmB,CAAnB,EAAqB,CAArB,EAAuB,CAAvB,EAAyB,CAAzB,EAA2B,CAA3B,EAA6B,CAA7B,EAA+B,CAA/B,EAAiC,CAAjC,EAAmC,CAAnC,EAAqC,CAArC,EAAuC,CAAvC,EAAyC,CAAzC,EAA2C,CAA3C,EAA6C,EAA7C,EAAgD,EAAhD,EAAmD,EAAnD,EAAsD,EAAtD,EAAyD,EAAzD,EAA4D,EAA5D,EAA+D,EAA/D,EAAkE,EAAlE,CAAf,CADF;AAGA,MAAME,YAAY;AAAI;AACpB,IAAIF,UAAJ,CAAe,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,EAAe,CAAf,EAAiB,CAAjB,EAAmB,CAAnB,EAAqB,CAArB,EAAuB,CAAvB,EAAyB,CAAzB,EAA2B,CAA3B,EAA6B,CAA7B,EAA+B,CAA/B,EAAiC,CAAjC,EAAmC,CAAnC,EAAqC,CAArC,CAAf,CADF;AAGA,MAAMG,QAAQ,GACZ,IAAIH,UAAJ,CAAe,CAAC,EAAD,EAAI,EAAJ,EAAO,EAAP,EAAU,CAAV,EAAY,CAAZ,EAAc,CAAd,EAAgB,CAAhB,EAAkB,CAAlB,EAAoB,EAApB,EAAuB,CAAvB,EAAyB,EAAzB,EAA4B,CAA5B,EAA8B,EAA9B,EAAiC,CAAjC,EAAmC,EAAnC,EAAsC,CAAtC,EAAwC,EAAxC,EAA2C,CAA3C,EAA6C,EAA7C,CAAf,CADF;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA,MAAMI,aAAa,GAAG,GAAtB;AAA2B;AAE3B;;AACA,MAAMC,YAAY,GAAI,IAAIC,KAAJ,CAAU,CAAClB,OAAO,GAAG,CAAX,IAAgB,CAA1B,CAAtB;AACAX,IAAI,CAAC4B,YAAD,CAAJ;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,YAAY,GAAI,IAAID,KAAJ,CAAUjB,OAAO,GAAG,CAApB,CAAtB;AACAZ,IAAI,CAAC8B,YAAD,CAAJ;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,GAAM,IAAIF,KAAJ,CAAUF,aAAV,CAAtB;;AACA3B,IAAI,CAAC+B,UAAD,CAAJ;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAI,IAAIH,KAAJ,CAAUrB,SAAS,GAAGD,SAAZ,GAAwB,CAAlC,CAAtB;;AACAP,IAAI,CAACgC,YAAD,CAAJ;AACA;;AAEA,MAAMC,WAAW,GAAK,IAAIJ,KAAJ,CAAUpB,YAAV,CAAtB;AACAT,IAAI,CAACiC,WAAD,CAAJ;AACA;;AAEA,MAAMC,SAAS,GAAO,IAAIL,KAAJ,CAAUjB,OAAV,CAAtB;AACAZ,IAAI,CAACkC,SAAD,CAAJ;AACA;;AAGA,SAASC,cAAT,CAAwBC,WAAxB,EAAqCC,UAArC,EAAiDC,UAAjD,EAA6DC,KAA7D,EAAoEC,UAApE,EAAgF;AAE9E,OAAKJ,WAAL,GAAoBA,WAApB;AAAkC;;AAClC,OAAKC,UAAL,GAAoBA,UAApB;AAAkC;;AAClC,OAAKC,UAAL,GAAoBA,UAApB;AAAkC;;AAClC,OAAKC,KAAL,GAAoBA,KAApB;AAAkC;;AAClC,OAAKC,UAAL,GAAoBA,UAApB;AAAkC;AAElC;;AACA,OAAKC,SAAL,GAAoBL,WAAW,IAAIA,WAAW,CAACjC,MAA/C;AACD;;AAGD,IAAIuC,aAAJ;AACA,IAAIC,aAAJ;AACA,IAAIC,cAAJ;;AAGA,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,SAA5B,EAAuC;AACrC,OAAKD,QAAL,GAAgBA,QAAhB;AAA8B;;AAC9B,OAAKE,QAAL,GAAgB,CAAhB;AAA8B;;AAC9B,OAAKD,SAAL,GAAiBA,SAAjB;AAA8B;AAC/B;;AAID,MAAME,MAAM,GAAIC,IAAD,IAAU;AAEvB,SAAOA,IAAI,GAAG,GAAP,GAAanB,UAAU,CAACmB,IAAD,CAAvB,GAAgCnB,UAAU,CAAC,OAAOmB,IAAI,KAAK,CAAhB,CAAD,CAAjD;AACD,CAHD;AAMA;AACA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC5B;AACA;AACED,EAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAACG,OAAF,EAAd,IAA8BF,CAAD,GAAM,IAAnC;AACAD,EAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAACG,OAAF,EAAd,IAA8BF,CAAC,KAAK,CAAP,GAAY,IAAzC;AACD,CALD;AAQA;AACA;AACA;AACA;;;AACA,MAAMG,SAAS,GAAG,CAACJ,CAAD,EAAIK,KAAJ,EAAWtD,MAAX,KAAsB;AAEtC,MAAIiD,CAAC,CAACM,QAAF,GAAc1C,QAAQ,GAAGb,MAA7B,EAAsC;AACpCiD,IAAAA,CAAC,CAACO,MAAF,IAAaF,KAAK,IAAIL,CAAC,CAACM,QAAZ,GAAwB,MAApC;AACAP,IAAAA,SAAS,CAACC,CAAD,EAAIA,CAAC,CAACO,MAAN,CAAT;AACAP,IAAAA,CAAC,CAACO,MAAF,GAAWF,KAAK,IAAKzC,QAAQ,GAAGoC,CAAC,CAACM,QAAlC;AACAN,IAAAA,CAAC,CAACM,QAAF,IAAcvD,MAAM,GAAGa,QAAvB;AACD,GALD,MAKO;AACLoC,IAAAA,CAAC,CAACO,MAAF,IAAaF,KAAK,IAAIL,CAAC,CAACM,QAAZ,GAAwB,MAApC;AACAN,IAAAA,CAAC,CAACM,QAAF,IAAcvD,MAAd;AACD;AACF,CAXD;;AAcA,MAAMyD,SAAS,GAAG,CAACR,CAAD,EAAIS,CAAJ,EAAOC,IAAP,KAAgB;AAEhCN,EAAAA,SAAS,CAACJ,CAAD,EAAIU,IAAI,CAACD,CAAC,GAAG,CAAL;AAAO;AAAf,IAA0BC,IAAI,CAACD,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAzC,GAAT;AACD,CAHD;AAMA;AACA;AACA;AACA;AACA;;;AACA,MAAME,UAAU,GAAG,CAACC,IAAD,EAAO9D,GAAP,KAAe;AAEhC,MAAI+D,GAAG,GAAG,CAAV;;AACA,KAAG;AACDA,IAAAA,GAAG,IAAID,IAAI,GAAG,CAAd;AACAA,IAAAA,IAAI,MAAM,CAAV;AACAC,IAAAA,GAAG,KAAK,CAAR;AACD,GAJD,QAIS,EAAE/D,GAAF,GAAQ,CAJjB;;AAKA,SAAO+D,GAAG,KAAK,CAAf;AACD,CATD;AAYA;AACA;AACA;;;AACA,MAAMC,QAAQ,GAAId,CAAD,IAAO;AAEtB,MAAIA,CAAC,CAACM,QAAF,KAAe,EAAnB,EAAuB;AACrBP,IAAAA,SAAS,CAACC,CAAD,EAAIA,CAAC,CAACO,MAAN,CAAT;AACAP,IAAAA,CAAC,CAACO,MAAF,GAAW,CAAX;AACAP,IAAAA,CAAC,CAACM,QAAF,GAAa,CAAb;AAED,GALD,MAKO,IAAIN,CAAC,CAACM,QAAF,IAAc,CAAlB,EAAqB;AAC1BN,IAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAACG,OAAF,EAAd,IAA6BH,CAAC,CAACO,MAAF,GAAW,IAAxC;AACAP,IAAAA,CAAC,CAACO,MAAF,KAAa,CAAb;AACAP,IAAAA,CAAC,CAACM,QAAF,IAAc,CAAd;AACD;AACF,CAZD;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMS,UAAU,GAAG,CAACf,CAAD,EAAIgB,IAAJ,KACnB;AACA;AACA;AACE,QAAMN,IAAI,GAAcM,IAAI,CAACtB,QAA7B;AACA,QAAME,QAAQ,GAAUoB,IAAI,CAACpB,QAA7B;AACA,QAAMqB,KAAK,GAAaD,IAAI,CAACrB,SAAL,CAAeX,WAAvC;AACA,QAAMK,SAAS,GAAS2B,IAAI,CAACrB,SAAL,CAAeN,SAAvC;AACA,QAAM6B,KAAK,GAAaF,IAAI,CAACrB,SAAL,CAAeV,UAAvC;AACA,QAAMkC,IAAI,GAAcH,IAAI,CAACrB,SAAL,CAAeT,UAAvC;AACA,QAAME,UAAU,GAAQ4B,IAAI,CAACrB,SAAL,CAAeP,UAAvC;AACA,MAAIgC,CAAJ;AAAoB;;AACpB,MAAIC,CAAJ,EAAOC,CAAP;AAAoB;;AACpB,MAAIC,IAAJ;AAAoB;;AACpB,MAAIC,KAAJ;AAAoB;;AACpB,MAAIC,CAAJ;AAAoB;;AACpB,MAAIC,QAAQ,GAAG,CAAf;AAAoB;;AAEpB,OAAKH,IAAI,GAAG,CAAZ,EAAeA,IAAI,IAAI5D,QAAvB,EAAiC4D,IAAI,EAArC,EAAyC;AACvCvB,IAAAA,CAAC,CAAC2B,QAAF,CAAWJ,IAAX,IAAmB,CAAnB;AACD;AAED;AACF;AACA;;;AACEb,EAAAA,IAAI,CAACV,CAAC,CAAC4B,IAAF,CAAO5B,CAAC,CAAC6B,QAAT,IAAqB,CAArB,GAAyB,CAA1B;AAA4B;AAAhC,IAA2C,CAA3C;AAA8C;;AAE9C,OAAKT,CAAC,GAAGpB,CAAC,CAAC6B,QAAF,GAAa,CAAtB,EAAyBT,CAAC,GAAG1D,SAA7B,EAAwC0D,CAAC,EAAzC,EAA6C;AAC3CC,IAAAA,CAAC,GAAGrB,CAAC,CAAC4B,IAAF,CAAOR,CAAP,CAAJ;AACAG,IAAAA,IAAI,GAAGb,IAAI,CAACA,IAAI,CAACW,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,MAA0B,CAA1B,GAA8B,CAA/B;AAAiC;AAArC,MAAgD,CAAvD;;AACA,QAAIE,IAAI,GAAGnC,UAAX,EAAuB;AACrBmC,MAAAA,IAAI,GAAGnC,UAAP;AACAsC,MAAAA,QAAQ;AACT;;AACDhB,IAAAA,IAAI,CAACW,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,MAA0BE,IAA1B;AACA;;AAEA,QAAIF,CAAC,GAAGzB,QAAR,EAAkB;AAAE;AAAW;AAAC;;;AAEhCI,IAAAA,CAAC,CAAC2B,QAAF,CAAWJ,IAAX;AACAC,IAAAA,KAAK,GAAG,CAAR;;AACA,QAAIH,CAAC,IAAIF,IAAT,EAAe;AACbK,MAAAA,KAAK,GAAGN,KAAK,CAACG,CAAC,GAAGF,IAAL,CAAb;AACD;;AACDM,IAAAA,CAAC,GAAGf,IAAI,CAACW,CAAC,GAAG,CAAL;AAAO;AAAf;AACArB,IAAAA,CAAC,CAAC8B,OAAF,IAAaL,CAAC,IAAIF,IAAI,GAAGC,KAAX,CAAd;;AACA,QAAInC,SAAJ,EAAe;AACbW,MAAAA,CAAC,CAAC+B,UAAF,IAAgBN,CAAC,IAAIR,KAAK,CAACI,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAhB,QAA2BG,KAA/B,CAAjB;AACD;AACF;;AACD,MAAIE,QAAQ,KAAK,CAAjB,EAAoB;AAAE;AAAS,GA/CjC,CAiDE;;AACA;;AAEA;;;AACA,KAAG;AACDH,IAAAA,IAAI,GAAGnC,UAAU,GAAG,CAApB;;AACA,WAAOY,CAAC,CAAC2B,QAAF,CAAWJ,IAAX,MAAqB,CAA5B,EAA+B;AAAEA,MAAAA,IAAI;AAAK;;AAC1CvB,IAAAA,CAAC,CAAC2B,QAAF,CAAWJ,IAAX;AAAyB;;AACzBvB,IAAAA,CAAC,CAAC2B,QAAF,CAAWJ,IAAI,GAAG,CAAlB,KAAwB,CAAxB;AAA2B;;AAC3BvB,IAAAA,CAAC,CAAC2B,QAAF,CAAWvC,UAAX;AACA;AACJ;AACA;;AACIsC,IAAAA,QAAQ,IAAI,CAAZ;AACD,GAVD,QAUSA,QAAQ,GAAG,CAVpB;AAYA;AACF;AACA;AACA;AACA;;;AACE,OAAKH,IAAI,GAAGnC,UAAZ,EAAwBmC,IAAI,KAAK,CAAjC,EAAoCA,IAAI,EAAxC,EAA4C;AAC1CF,IAAAA,CAAC,GAAGrB,CAAC,CAAC2B,QAAF,CAAWJ,IAAX,CAAJ;;AACA,WAAOF,CAAC,KAAK,CAAb,EAAgB;AACdC,MAAAA,CAAC,GAAGtB,CAAC,CAAC4B,IAAF,CAAO,EAAER,CAAT,CAAJ;;AACA,UAAIE,CAAC,GAAG1B,QAAR,EAAkB;AAAE;AAAW;;AAC/B,UAAIc,IAAI,CAACY,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,UAA4BC,IAAhC,EAAsC;AACpC;AACAvB,QAAAA,CAAC,CAAC8B,OAAF,IAAa,CAACP,IAAI,GAAGb,IAAI,CAACY,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,YAAmCZ,IAAI,CAACY,CAAC,GAAG,CAAL;AAAO;AAA3D;AACAZ,QAAAA,IAAI,CAACY,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,UAA0BC,IAA1B;AACD;;AACDF,MAAAA,CAAC;AACF;AACF;AACF,CAtFD;AAyFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMW,SAAS,GAAG,CAACtB,IAAD,EAAOd,QAAP,EAAiB+B,QAAjB,KAClB;AACA;AACA;AACA;AACE,QAAMM,SAAS,GAAG,IAAIxD,KAAJ,CAAUd,QAAQ,GAAG,CAArB,CAAlB;AAA2C;;AAC3C,MAAIiD,IAAI,GAAG,CAAX;AAA2B;;AAC3B,MAAIW,IAAJ;AAA2B;;AAC3B,MAAIF,CAAJ;AAA2B;;AAE3B;AACF;AACA;;AACE,OAAKE,IAAI,GAAG,CAAZ,EAAeA,IAAI,IAAI5D,QAAvB,EAAiC4D,IAAI,EAArC,EAAyC;AACvCU,IAAAA,SAAS,CAACV,IAAD,CAAT,GAAkBX,IAAI,GAAIA,IAAI,GAAGe,QAAQ,CAACJ,IAAI,GAAG,CAAR,CAAhB,IAA+B,CAAxD;AACD;AACD;AACF;AACA;AACE;AACA;AACA;;;AAEA,OAAKF,CAAC,GAAG,CAAT,EAAaA,CAAC,IAAIzB,QAAlB,EAA4ByB,CAAC,EAA7B,EAAiC;AAC/B,QAAIvE,GAAG,GAAG4D,IAAI,CAACW,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAzB;;AACA,QAAIvE,GAAG,KAAK,CAAZ,EAAe;AAAE;AAAW;AAC5B;;;AACA4D,IAAAA,IAAI,CAACW,CAAC,GAAG,CAAL;AAAO;AAAX,MAAuBV,UAAU,CAACsB,SAAS,CAACnF,GAAD,CAAT,EAAD,EAAmBA,GAAnB,CAAjC,CAJ+B,CAM/B;AACA;AACD;AACF,CAhCD;AAmCA;AACA;AACA;;;AACA,MAAMoF,cAAc,GAAG,MAAM;AAE3B,MAAIb,CAAJ;AAAc;;AACd,MAAIE,IAAJ;AAAc;;AACd,MAAIxE,MAAJ;AAAc;;AACd,MAAI6D,IAAJ;AAAc;;AACd,MAAId,IAAJ;AAAc;;AACd,QAAM6B,QAAQ,GAAG,IAAIlD,KAAJ,CAAUd,QAAQ,GAAG,CAArB,CAAjB;AACA;AAEA;AACA;;AAEA;;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;;AACAZ,EAAAA,MAAM,GAAG,CAAT;;AACA,OAAK6D,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGvD,YAAY,GAAG,CAArC,EAAwCuD,IAAI,EAA5C,EAAgD;AAC9C/B,IAAAA,WAAW,CAAC+B,IAAD,CAAX,GAAoB7D,MAApB;;AACA,SAAKsE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAI,KAAKnD,WAAW,CAAC0C,IAAD,CAAjC,EAA0CS,CAAC,EAA3C,EAA+C;AAC7CzC,MAAAA,YAAY,CAAC7B,MAAM,EAAP,CAAZ,GAAyB6D,IAAzB;AACD;AACF,GA7B0B,CA8B3B;;AACA;AACF;AACA;AACA;;;AACEhC,EAAAA,YAAY,CAAC7B,MAAM,GAAG,CAAV,CAAZ,GAA2B6D,IAA3B;AAEA;;AACAd,EAAAA,IAAI,GAAG,CAAP;;AACA,OAAKc,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAG,EAAtB,EAA0BA,IAAI,EAA9B,EAAkC;AAChC9B,IAAAA,SAAS,CAAC8B,IAAD,CAAT,GAAkBd,IAAlB;;AACA,SAAKuB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAI,KAAKjD,WAAW,CAACwC,IAAD,CAAjC,EAA0CS,CAAC,EAA3C,EAA+C;AAC7C1C,MAAAA,UAAU,CAACmB,IAAI,EAAL,CAAV,GAAqBc,IAArB;AACD;AACF,GA5C0B,CA6C3B;;;AACAd,EAAAA,IAAI,KAAK,CAAT;AAAY;;AACZ,SAAOc,IAAI,GAAGpD,OAAd,EAAuBoD,IAAI,EAA3B,EAA+B;AAC7B9B,IAAAA,SAAS,CAAC8B,IAAD,CAAT,GAAkBd,IAAI,IAAI,CAA1B;;AACA,SAAKuB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAI,KAAMjD,WAAW,CAACwC,IAAD,CAAX,GAAoB,CAA3C,EAAgDS,CAAC,EAAjD,EAAqD;AACnD1C,MAAAA,UAAU,CAAC,MAAMmB,IAAI,EAAX,CAAV,GAA2Bc,IAA3B;AACD;AACF,GApD0B,CAqD3B;;AAEA;;;AACA,OAAKW,IAAI,GAAG,CAAZ,EAAeA,IAAI,IAAI5D,QAAvB,EAAiC4D,IAAI,EAArC,EAAyC;AACvCI,IAAAA,QAAQ,CAACJ,IAAD,CAAR,GAAiB,CAAjB;AACD;;AAEDF,EAAAA,CAAC,GAAG,CAAJ;;AACA,SAAOA,CAAC,IAAI,GAAZ,EAAiB;AACf7C,IAAAA,YAAY,CAAC6C,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,MAAkC,CAAlC;AACAA,IAAAA,CAAC;AACDM,IAAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AACD,SAAON,CAAC,IAAI,GAAZ,EAAiB;AACf7C,IAAAA,YAAY,CAAC6C,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,MAAkC,CAAlC;AACAA,IAAAA,CAAC;AACDM,IAAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AACD,SAAON,CAAC,IAAI,GAAZ,EAAiB;AACf7C,IAAAA,YAAY,CAAC6C,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,MAAkC,CAAlC;AACAA,IAAAA,CAAC;AACDM,IAAAA,QAAQ,CAAC,CAAD,CAAR;AACD;;AACD,SAAON,CAAC,IAAI,GAAZ,EAAiB;AACf7C,IAAAA,YAAY,CAAC6C,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,MAAkC,CAAlC;AACAA,IAAAA,CAAC;AACDM,IAAAA,QAAQ,CAAC,CAAD,CAAR;AACD;AACD;AACF;AACA;AACA;;;AACEK,EAAAA,SAAS,CAACxD,YAAD,EAAejB,OAAO,GAAG,CAAzB,EAA4BoE,QAA5B,CAAT;AAEA;;AACA,OAAKN,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7D,OAAhB,EAAyB6D,CAAC,EAA1B,EAA8B;AAC5B3C,IAAAA,YAAY,CAAC2C,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAvB,MAAkC,CAAlC;AACA3C,IAAAA,YAAY,CAAC2C,CAAC,GAAG,CAAL;AAAO;AAAnB,MAA+BV,UAAU,CAACU,CAAD,EAAI,CAAJ,CAAzC;AACD,GA3F0B,CA6F3B;;;AACA/B,EAAAA,aAAa,GAAG,IAAIP,cAAJ,CAAmBP,YAAnB,EAAiCN,WAAjC,EAA8CZ,QAAQ,GAAG,CAAzD,EAA4DC,OAA5D,EAAqEI,QAArE,CAAhB;AACA4B,EAAAA,aAAa,GAAG,IAAIR,cAAJ,CAAmBL,YAAnB,EAAiCN,WAAjC,EAA8C,CAA9C,EAA0DZ,OAA1D,EAAmEG,QAAnE,CAAhB;AACA6B,EAAAA,cAAc,GAAG,IAAIT,cAAJ,CAAmB,IAAIN,KAAJ,CAAU,CAAV,CAAnB,EAAiCJ,YAAjC,EAA+C,CAA/C,EAA0DZ,QAA1D,EAAoEI,WAApE,CAAjB,CAhG2B,CAkG3B;AACD,CAnGD;AAsGA;AACA;AACA;;;AACA,MAAMsE,UAAU,GAAInC,CAAD,IAAO;AAExB,MAAIqB,CAAJ;AAAO;;AAEP;;AACA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG9D,OAAhB,EAA0B8D,CAAC,EAA3B,EAA+B;AAAErB,IAAAA,CAAC,CAACoC,SAAF,CAAYf,CAAC,GAAG,CAAhB;AAAkB;AAAlB,MAA8B,CAA9B;AAAkC;;AACnE,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7D,OAAhB,EAA0B6D,CAAC,EAA3B,EAA+B;AAAErB,IAAAA,CAAC,CAACqC,SAAF,CAAYhB,CAAC,GAAG,CAAhB;AAAkB;AAAlB,MAA8B,CAA9B;AAAkC;;AACnE,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG5D,QAAhB,EAA0B4D,CAAC,EAA3B,EAA+B;AAAErB,IAAAA,CAAC,CAACsC,OAAF,CAAUjB,CAAC,GAAG,CAAd;AAAgB;AAAhB,MAA4B,CAA5B;AAAgC;;AAEjErB,EAAAA,CAAC,CAACoC,SAAF,CAAYtE,SAAS,GAAG,CAAxB;AAA0B;AAA1B,IAAsC,CAAtC;AACAkC,EAAAA,CAAC,CAAC8B,OAAF,GAAY9B,CAAC,CAAC+B,UAAF,GAAe,CAA3B;AACA/B,EAAAA,CAAC,CAACuC,QAAF,GAAavC,CAAC,CAACwC,OAAF,GAAY,CAAzB;AACD,CAZD;AAeA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAIzC,CAAD,IAClB;AACE,MAAIA,CAAC,CAACM,QAAF,GAAa,CAAjB,EAAoB;AAClBP,IAAAA,SAAS,CAACC,CAAD,EAAIA,CAAC,CAACO,MAAN,CAAT;AACD,GAFD,MAEO,IAAIP,CAAC,CAACM,QAAF,GAAa,CAAjB,EAAoB;AACzB;AACAN,IAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAACG,OAAF,EAAd,IAA6BH,CAAC,CAACO,MAA/B;AACD;;AACDP,EAAAA,CAAC,CAACO,MAAF,GAAW,CAAX;AACAP,EAAAA,CAAC,CAACM,QAAF,GAAa,CAAb;AACD,CAVD;AAYA;AACA;AACA;AACA;;;AACA,MAAMoC,UAAU,GAAG,CAAC1C,CAAD,EAAInD,GAAJ,EAASC,GAAT,EAAc6F,MAAd,KACnB;AACA;AACA;AACA;AACA;AACEF,EAAAA,SAAS,CAACzC,CAAD,CAAT;AAAqB;;AAErB,MAAI2C,MAAJ,EAAY;AACV5C,IAAAA,SAAS,CAACC,CAAD,EAAIlD,GAAJ,CAAT;AACAiD,IAAAA,SAAS,CAACC,CAAD,EAAI,CAAClD,GAAL,CAAT;AACD,GANH,CAOA;AACA;AACA;;;AACEkD,EAAAA,CAAC,CAACE,WAAF,CAAc0C,GAAd,CAAkB5C,CAAC,CAAC6C,MAAF,CAASC,QAAT,CAAkBjG,GAAlB,EAAuBA,GAAG,GAAGC,GAA7B,CAAlB,EAAqDkD,CAAC,CAACG,OAAvD;AACAH,EAAAA,CAAC,CAACG,OAAF,IAAarD,GAAb;AACD,CAjBD;AAmBA;AACA;AACA;AACA;;;AACA,MAAMiG,OAAO,GAAG,CAACrC,IAAD,EAAOW,CAAP,EAAUC,CAAV,EAAa0B,KAAb,KAAuB;AAErC,QAAMC,GAAG,GAAG5B,CAAC,GAAG,CAAhB;;AACA,QAAM6B,GAAG,GAAG5B,CAAC,GAAG,CAAhB;;AACA,SAAQZ,IAAI,CAACuC,GAAD;AAAK;AAAT,IAAqBvC,IAAI,CAACwC,GAAD;AAAK;AAA9B,KACAxC,IAAI,CAACuC,GAAD;AAAK;AAAT,MAAuBvC,IAAI,CAACwC,GAAD;AAAK;AAAhC,KAA6CF,KAAK,CAAC3B,CAAD,CAAL,IAAY2B,KAAK,CAAC1B,CAAD,CADtE;AAED,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM6B,UAAU,GAAG,CAACnD,CAAD,EAAIU,IAAJ,EAAU0C,CAAV,KACnB;AACA;AACA;AACA;AACE,QAAMC,CAAC,GAAGrD,CAAC,CAAC4B,IAAF,CAAOwB,CAAP,CAAV;AACA,MAAIE,CAAC,GAAGF,CAAC,IAAI,CAAb;AAAiB;;AACjB,SAAOE,CAAC,IAAItD,CAAC,CAACuD,QAAd,EAAwB;AACtB;AACA,QAAID,CAAC,GAAGtD,CAAC,CAACuD,QAAN,IACFR,OAAO,CAACrC,IAAD,EAAOV,CAAC,CAAC4B,IAAF,CAAO0B,CAAC,GAAG,CAAX,CAAP,EAAsBtD,CAAC,CAAC4B,IAAF,CAAO0B,CAAP,CAAtB,EAAiCtD,CAAC,CAACgD,KAAnC,CADT,EACoD;AAClDM,MAAAA,CAAC;AACF;AACD;;;AACA,QAAIP,OAAO,CAACrC,IAAD,EAAO2C,CAAP,EAAUrD,CAAC,CAAC4B,IAAF,CAAO0B,CAAP,CAAV,EAAqBtD,CAAC,CAACgD,KAAvB,CAAX,EAA0C;AAAE;AAAQ;AAEpD;;;AACAhD,IAAAA,CAAC,CAAC4B,IAAF,CAAOwB,CAAP,IAAYpD,CAAC,CAAC4B,IAAF,CAAO0B,CAAP,CAAZ;AACAF,IAAAA,CAAC,GAAGE,CAAJ;AAEA;;AACAA,IAAAA,CAAC,KAAK,CAAN;AACD;;AACDtD,EAAAA,CAAC,CAAC4B,IAAF,CAAOwB,CAAP,IAAYC,CAAZ;AACD,CAxBD,C,CA2BA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMG,cAAc,GAAG,CAACxD,CAAD,EAAIyD,KAAJ,EAAWC,KAAX,KACvB;AACA;AACA;AACA;AACE,MAAI5D,IAAJ;AAAoB;;AACpB,MAAI6D,EAAJ;AAAoB;;AACpB,MAAIC,EAAE,GAAG,CAAT;AAAoB;;AACpB,MAAIhD,IAAJ;AAAoB;;AACpB,MAAIM,KAAJ;AAAoB;;AAEpB,MAAIlB,CAAC,CAACuC,QAAF,KAAe,CAAnB,EAAsB;AACpB,OAAG;AACDzC,MAAAA,IAAI,GAAIE,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC6D,KAAF,GAAUD,EAAE,GAAG,CAA7B,KAAmC,CAApC,GAA0C5D,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC6D,KAAF,GAAUD,EAAE,GAAG,CAAf,GAAmB,CAAjC,CAAjD;AACAD,MAAAA,EAAE,GAAG3D,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC8D,KAAF,GAAUF,EAAxB,CAAL;AACAA,MAAAA,EAAE;;AAEF,UAAI9D,IAAI,KAAK,CAAb,EAAgB;AACdU,QAAAA,SAAS,CAACR,CAAD,EAAI2D,EAAJ,EAAQF,KAAR,CAAT;AAAyB;AACzB;AACD,OAHD,MAGO;AACL;AACA7C,QAAAA,IAAI,GAAGhC,YAAY,CAAC+E,EAAD,CAAnB;AACAnD,QAAAA,SAAS,CAACR,CAAD,EAAIY,IAAI,GAAGtD,QAAP,GAAkB,CAAtB,EAAyBmG,KAAzB,CAAT;AAA0C;;AAC1CvC,QAAAA,KAAK,GAAGhD,WAAW,CAAC0C,IAAD,CAAnB;;AACA,YAAIM,KAAK,KAAK,CAAd,EAAiB;AACfyC,UAAAA,EAAE,IAAI9E,WAAW,CAAC+B,IAAD,CAAjB;AACAR,UAAAA,SAAS,CAACJ,CAAD,EAAI2D,EAAJ,EAAQzC,KAAR,CAAT;AAA+B;AAChC;;AACDpB,QAAAA,IAAI;AAAI;;AACRc,QAAAA,IAAI,GAAGf,MAAM,CAACC,IAAD,CAAb,CAVK,CAWL;;AAEAU,QAAAA,SAAS,CAACR,CAAD,EAAIY,IAAJ,EAAU8C,KAAV,CAAT;AAAiC;;AACjCxC,QAAAA,KAAK,GAAG9C,WAAW,CAACwC,IAAD,CAAnB;;AACA,YAAIM,KAAK,KAAK,CAAd,EAAiB;AACfpB,UAAAA,IAAI,IAAIhB,SAAS,CAAC8B,IAAD,CAAjB;AACAR,UAAAA,SAAS,CAACJ,CAAD,EAAIF,IAAJ,EAAUoB,KAAV,CAAT;AAA6B;AAC9B;AACF;AAAC;;AAEF;AACA;AACA;;AAED,KAjCD,QAiCS0C,EAAE,GAAG5D,CAAC,CAACuC,QAjChB;AAkCD;;AAED/B,EAAAA,SAAS,CAACR,CAAD,EAAIlC,SAAJ,EAAe2F,KAAf,CAAT;AACD,CAjDD;AAoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,UAAU,GAAG,CAAC/D,CAAD,EAAIgB,IAAJ,KACnB;AACA;AACA;AACE,QAAMN,IAAI,GAAOM,IAAI,CAACtB,QAAtB;AACA,QAAMuB,KAAK,GAAMD,IAAI,CAACrB,SAAL,CAAeX,WAAhC;AACA,QAAMK,SAAS,GAAG2B,IAAI,CAACrB,SAAL,CAAeN,SAAjC;AACA,QAAMF,KAAK,GAAM6B,IAAI,CAACrB,SAAL,CAAeR,KAAhC;AACA,MAAIkC,CAAJ,EAAOC,CAAP;AAAmB;;AACnB,MAAI1B,QAAQ,GAAG,CAAC,CAAhB;AAAmB;;AACnB,MAAIoE,IAAJ;AAAmB;;AAEnB;AACF;AACA;AACA;;AACEhE,EAAAA,CAAC,CAACuD,QAAF,GAAa,CAAb;AACAvD,EAAAA,CAAC,CAAC6B,QAAF,GAAanE,SAAb;;AAEA,OAAK2D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGlC,KAAhB,EAAuBkC,CAAC,EAAxB,EAA4B;AAC1B,QAAIX,IAAI,CAACW,CAAC,GAAG,CAAL;AAAO;AAAX,QAAyB,CAA7B,EAAgC;AAC9BrB,MAAAA,CAAC,CAAC4B,IAAF,CAAO,EAAE5B,CAAC,CAACuD,QAAX,IAAuB3D,QAAQ,GAAGyB,CAAlC;AACArB,MAAAA,CAAC,CAACgD,KAAF,CAAQ3B,CAAR,IAAa,CAAb;AAED,KAJD,MAIO;AACLX,MAAAA,IAAI,CAACW,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,QAA0B,CAA1B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AACE,SAAOrB,CAAC,CAACuD,QAAF,GAAa,CAApB,EAAuB;AACrBS,IAAAA,IAAI,GAAGhE,CAAC,CAAC4B,IAAF,CAAO,EAAE5B,CAAC,CAACuD,QAAX,IAAwB3D,QAAQ,GAAG,CAAX,GAAe,EAAEA,QAAjB,GAA4B,CAA3D;AACAc,IAAAA,IAAI,CAACsD,IAAI,GAAG,CAAR;AAAU;AAAd,MAA0B,CAA1B;AACAhE,IAAAA,CAAC,CAACgD,KAAF,CAAQgB,IAAR,IAAgB,CAAhB;AACAhE,IAAAA,CAAC,CAAC8B,OAAF;;AAEA,QAAIzC,SAAJ,EAAe;AACbW,MAAAA,CAAC,CAAC+B,UAAF,IAAgBd,KAAK,CAAC+C,IAAI,GAAG,CAAP,GAAW,CAAZ;AAAc;AAAnC;AACD;AACD;;AACD;;AACDhD,EAAAA,IAAI,CAACpB,QAAL,GAAgBA,QAAhB;AAEA;AACF;AACA;;AACE,OAAKyB,CAAC,GAAIrB,CAAC,CAACuD,QAAF,IAAc;AAAC;AAAzB,IAAsClC,CAAC,IAAI,CAA3C,EAA8CA,CAAC,EAA/C,EAAmD;AAAE8B,IAAAA,UAAU,CAACnD,CAAD,EAAIU,IAAJ,EAAUW,CAAV,CAAV;AAAyB;AAE9E;AACF;AACA;;;AACE2C,EAAAA,IAAI,GAAG7E,KAAP;AAA2B;;AAC3B,KAAG;AACD;;AACA;AACAkC,IAAAA,CAAC,GAAGrB,CAAC,CAAC4B,IAAF,CAAO;AAAC;AAAR,KAAJ;AACA5B,IAAAA,CAAC,CAAC4B,IAAF,CAAO;AAAC;AAAR,QAAwB5B,CAAC,CAAC4B,IAAF,CAAO5B,CAAC,CAACuD,QAAF,EAAP,CAAxB;AACAJ,IAAAA,UAAU,CAACnD,CAAD,EAAIU,IAAJ,EAAU;AAAC;AAAX,KAAV;AACA;;AAEAY,IAAAA,CAAC,GAAGtB,CAAC,CAAC4B,IAAF,CAAO;AAAC;AAAR,KAAJ;AAA2B;;AAE3B5B,IAAAA,CAAC,CAAC4B,IAAF,CAAO,EAAE5B,CAAC,CAAC6B,QAAX,IAAuBR,CAAvB;AAA0B;;AAC1BrB,IAAAA,CAAC,CAAC4B,IAAF,CAAO,EAAE5B,CAAC,CAAC6B,QAAX,IAAuBP,CAAvB;AAEA;;AACAZ,IAAAA,IAAI,CAACsD,IAAI,GAAG,CAAR;AAAU;AAAd,MAA0BtD,IAAI,CAACW,CAAC,GAAG,CAAL;AAAO;AAAX,MAAuBX,IAAI,CAACY,CAAC,GAAG,CAAL;AAAO;AAA5D;AACAtB,IAAAA,CAAC,CAACgD,KAAF,CAAQgB,IAAR,IAAgB,CAAChE,CAAC,CAACgD,KAAF,CAAQ3B,CAAR,KAAcrB,CAAC,CAACgD,KAAF,CAAQ1B,CAAR,CAAd,GAA2BtB,CAAC,CAACgD,KAAF,CAAQ3B,CAAR,CAA3B,GAAwCrB,CAAC,CAACgD,KAAF,CAAQ1B,CAAR,CAAzC,IAAuD,CAAvE;AACAZ,IAAAA,IAAI,CAACW,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,MAA0BX,IAAI,CAACY,CAAC,GAAG,CAAJ,GAAQ,CAAT;AAAW;AAAf,MAA0B0C,IAApD;AAEA;;AACAhE,IAAAA,CAAC,CAAC4B,IAAF,CAAO;AAAC;AAAR,QAAwBoC,IAAI,EAA5B;AACAb,IAAAA,UAAU,CAACnD,CAAD,EAAIU,IAAJ,EAAU;AAAC;AAAX,KAAV;AAED,GAtBD,QAsBSV,CAAC,CAACuD,QAAF,IAAc,CAtBvB;;AAwBAvD,EAAAA,CAAC,CAAC4B,IAAF,CAAO,EAAE5B,CAAC,CAAC6B,QAAX,IAAuB7B,CAAC,CAAC4B,IAAF,CAAO;AAAC;AAAR,GAAvB;AAEA;AACF;AACA;;AACEb,EAAAA,UAAU,CAACf,CAAD,EAAIgB,IAAJ,CAAV;AAEA;;AACAgB,EAAAA,SAAS,CAACtB,IAAD,EAAOd,QAAP,EAAiBI,CAAC,CAAC2B,QAAnB,CAAT;AACD,CAzFD;AA4FA;AACA;AACA;AACA;;;AACA,MAAMsC,SAAS,GAAG,CAACjE,CAAD,EAAIU,IAAJ,EAAUd,QAAV,KAClB;AACA;AACA;AACA;AACE,MAAIyB,CAAJ;AAA2B;;AAC3B,MAAI6C,OAAO,GAAG,CAAC,CAAf;AAA2B;;AAC3B,MAAIC,MAAJ;AAA2B;;AAE3B,MAAIC,OAAO,GAAG1D,IAAI,CAAC,IAAI,CAAJ,GAAQ,CAAT;AAAW;AAA7B;AAAuC;;AAEvC,MAAI2D,KAAK,GAAG,CAAZ;AAA2B;;AAC3B,MAAIC,SAAS,GAAG,CAAhB;AAA2B;;AAC3B,MAAIC,SAAS,GAAG,CAAhB;AAA2B;;AAE3B,MAAIH,OAAO,KAAK,CAAhB,EAAmB;AACjBE,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,CAAZ;AACD;;AACD7D,EAAAA,IAAI,CAAC,CAACd,QAAQ,GAAG,CAAZ,IAAiB,CAAjB,GAAqB,CAAtB;AAAwB;AAA5B,IAAuC,MAAvC;AAA+C;;AAE/C,OAAKyB,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAIzB,QAAjB,EAA2ByB,CAAC,EAA5B,EAAgC;AAC9B8C,IAAAA,MAAM,GAAGC,OAAT;AACAA,IAAAA,OAAO,GAAG1D,IAAI,CAAC,CAACW,CAAC,GAAG,CAAL,IAAU,CAAV,GAAc,CAAf;AAAiB;AAA/B;;AAEA,QAAI,EAAEgD,KAAF,GAAUC,SAAV,IAAuBH,MAAM,KAAKC,OAAtC,EAA+C;AAC7C;AAED,KAHD,MAGO,IAAIC,KAAK,GAAGE,SAAZ,EAAuB;AAC5BvE,MAAAA,CAAC,CAACsC,OAAF,CAAU6B,MAAM,GAAG,CAAnB;AAAqB;AAArB,SAAkCE,KAAlC;AAED,KAHM,MAGA,IAAIF,MAAM,KAAK,CAAf,EAAkB;AAEvB,UAAIA,MAAM,KAAKD,OAAf,EAAwB;AAAElE,QAAAA,CAAC,CAACsC,OAAF,CAAU6B,MAAM,GAAG,CAAnB,EAAqB,SAArB;AAAmC;;AAC7DnE,MAAAA,CAAC,CAACsC,OAAF,CAAUvE,OAAO,GAAG,CAApB,EAAsB,SAAtB;AAED,KALM,MAKA,IAAIsG,KAAK,IAAI,EAAb,EAAiB;AACtBrE,MAAAA,CAAC,CAACsC,OAAF,CAAUtE,SAAS,GAAG,CAAtB,EAAwB,SAAxB;AAED,KAHM,MAGA;AACLgC,MAAAA,CAAC,CAACsC,OAAF,CAAUrE,WAAW,GAAG,CAAxB,EAA0B,SAA1B;AACD;;AAEDoG,IAAAA,KAAK,GAAG,CAAR;AACAH,IAAAA,OAAO,GAAGC,MAAV;;AAEA,QAAIC,OAAO,KAAK,CAAhB,EAAmB;AACjBE,MAAAA,SAAS,GAAG,GAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AAED,KAJD,MAIO,IAAIJ,MAAM,KAAKC,OAAf,EAAwB;AAC7BE,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AAED,KAJM,MAIA;AACLD,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AACD;AACF;AACF,CA3DD;AA8DA;AACA;AACA;AACA;;;AACA,MAAMC,SAAS,GAAG,CAACxE,CAAD,EAAIU,IAAJ,EAAUd,QAAV,KAClB;AACA;AACA;AACA;AACE,MAAIyB,CAAJ;AAA2B;;AAC3B,MAAI6C,OAAO,GAAG,CAAC,CAAf;AAA2B;;AAC3B,MAAIC,MAAJ;AAA2B;;AAE3B,MAAIC,OAAO,GAAG1D,IAAI,CAAC,IAAI,CAAJ,GAAQ,CAAT;AAAW;AAA7B;AAAuC;;AAEvC,MAAI2D,KAAK,GAAG,CAAZ;AAA2B;;AAC3B,MAAIC,SAAS,GAAG,CAAhB;AAA2B;;AAC3B,MAAIC,SAAS,GAAG,CAAhB;AAA2B;;AAE3B;;AAAkC;;AAClC,MAAIH,OAAO,KAAK,CAAhB,EAAmB;AACjBE,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,CAAZ;AACD;;AAED,OAAKlD,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAIzB,QAAjB,EAA2ByB,CAAC,EAA5B,EAAgC;AAC9B8C,IAAAA,MAAM,GAAGC,OAAT;AACAA,IAAAA,OAAO,GAAG1D,IAAI,CAAC,CAACW,CAAC,GAAG,CAAL,IAAU,CAAV,GAAc,CAAf;AAAiB;AAA/B;;AAEA,QAAI,EAAEgD,KAAF,GAAUC,SAAV,IAAuBH,MAAM,KAAKC,OAAtC,EAA+C;AAC7C;AAED,KAHD,MAGO,IAAIC,KAAK,GAAGE,SAAZ,EAAuB;AAC5B,SAAG;AAAE/D,QAAAA,SAAS,CAACR,CAAD,EAAImE,MAAJ,EAAYnE,CAAC,CAACsC,OAAd,CAAT;AAAkC,OAAvC,QAA+C,EAAE+B,KAAF,KAAY,CAA3D;AAED,KAHM,MAGA,IAAIF,MAAM,KAAK,CAAf,EAAkB;AACvB,UAAIA,MAAM,KAAKD,OAAf,EAAwB;AACtB1D,QAAAA,SAAS,CAACR,CAAD,EAAImE,MAAJ,EAAYnE,CAAC,CAACsC,OAAd,CAAT;AACA+B,QAAAA,KAAK;AACN,OAJsB,CAKvB;;;AACA7D,MAAAA,SAAS,CAACR,CAAD,EAAIjC,OAAJ,EAAaiC,CAAC,CAACsC,OAAf,CAAT;AACAlC,MAAAA,SAAS,CAACJ,CAAD,EAAIqE,KAAK,GAAG,CAAZ,EAAe,CAAf,CAAT;AAED,KATM,MASA,IAAIA,KAAK,IAAI,EAAb,EAAiB;AACtB7D,MAAAA,SAAS,CAACR,CAAD,EAAIhC,SAAJ,EAAegC,CAAC,CAACsC,OAAjB,CAAT;AACAlC,MAAAA,SAAS,CAACJ,CAAD,EAAIqE,KAAK,GAAG,CAAZ,EAAe,CAAf,CAAT;AAED,KAJM,MAIA;AACL7D,MAAAA,SAAS,CAACR,CAAD,EAAI/B,WAAJ,EAAiB+B,CAAC,CAACsC,OAAnB,CAAT;AACAlC,MAAAA,SAAS,CAACJ,CAAD,EAAIqE,KAAK,GAAG,EAAZ,EAAgB,CAAhB,CAAT;AACD;;AAEDA,IAAAA,KAAK,GAAG,CAAR;AACAH,IAAAA,OAAO,GAAGC,MAAV;;AACA,QAAIC,OAAO,KAAK,CAAhB,EAAmB;AACjBE,MAAAA,SAAS,GAAG,GAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AAED,KAJD,MAIO,IAAIJ,MAAM,KAAKC,OAAf,EAAwB;AAC7BE,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AAED,KAJM,MAIA;AACLD,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,SAAS,GAAG,CAAZ;AACD;AACF;AACF,CAhED;AAmEA;AACA;AACA;AACA;;;AACA,MAAME,aAAa,GAAIzE,CAAD,IAAO;AAE3B,MAAI0E,WAAJ;AAAkB;;AAElB;;AACAT,EAAAA,SAAS,CAACjE,CAAD,EAAIA,CAAC,CAACoC,SAAN,EAAiBpC,CAAC,CAAC2E,MAAF,CAAS/E,QAA1B,CAAT;AACAqE,EAAAA,SAAS,CAACjE,CAAD,EAAIA,CAAC,CAACqC,SAAN,EAAiBrC,CAAC,CAAC4E,MAAF,CAAShF,QAA1B,CAAT;AAEA;;AACAmE,EAAAA,UAAU,CAAC/D,CAAD,EAAIA,CAAC,CAAC6E,OAAN,CAAV;AACA;AACF;AACA;;AAEE;AACF;AACA;AACA;;AACE,OAAKH,WAAW,GAAGjH,QAAQ,GAAG,CAA9B,EAAiCiH,WAAW,IAAI,CAAhD,EAAmDA,WAAW,EAA9D,EAAkE;AAChE,QAAI1E,CAAC,CAACsC,OAAF,CAAUhE,QAAQ,CAACoG,WAAD,CAAR,GAAwB,CAAxB,GAA4B,CAAtC;AAAwC;AAAxC,QAAqD,CAAzD,EAA4D;AAC1D;AACD;AACF;AACD;;;AACA1E,EAAAA,CAAC,CAAC8B,OAAF,IAAa,KAAK4C,WAAW,GAAG,CAAnB,IAAwB,CAAxB,GAA4B,CAA5B,GAAgC,CAA7C,CAxB2B,CAyB3B;AACA;;AAEA,SAAOA,WAAP;AACD,CA7BD;AAgCA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,cAAc,GAAG,CAAC9E,CAAD,EAAI+E,MAAJ,EAAYC,MAAZ,EAAoBC,OAApB,KACvB;AACA;AACA;AACE,MAAIC,IAAJ;AAA6B;AAE7B;AACA;AACA;AACA;;AACA9E,EAAAA,SAAS,CAACJ,CAAD,EAAI+E,MAAM,GAAG,GAAb,EAAkB,CAAlB,CAAT;AAA+B;;AAC/B3E,EAAAA,SAAS,CAACJ,CAAD,EAAIgF,MAAM,GAAG,CAAb,EAAkB,CAAlB,CAAT;AACA5E,EAAAA,SAAS,CAACJ,CAAD,EAAIiF,OAAO,GAAG,CAAd,EAAkB,CAAlB,CAAT;AAA+B;;AAC/B,OAAKC,IAAI,GAAG,CAAZ,EAAeA,IAAI,GAAGD,OAAtB,EAA+BC,IAAI,EAAnC,EAAuC;AACrC;AACA9E,IAAAA,SAAS,CAACJ,CAAD,EAAIA,CAAC,CAACsC,OAAF,CAAUhE,QAAQ,CAAC4G,IAAD,CAAR,GAAiB,CAAjB,GAAqB,CAA/B;AAAiC;AAArC,MAA+C,CAA/C,CAAT;AACD,GAbH,CAcE;;;AAEAV,EAAAA,SAAS,CAACxE,CAAD,EAAIA,CAAC,CAACoC,SAAN,EAAiB2C,MAAM,GAAG,CAA1B,CAAT;AAAuC;AACvC;;AAEAP,EAAAA,SAAS,CAACxE,CAAD,EAAIA,CAAC,CAACqC,SAAN,EAAiB2C,MAAM,GAAG,CAA1B,CAAT;AAAuC;AACvC;AACD,CAxBD;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,gBAAgB,GAAInF,CAAD,IAAO;AAC9B;AACF;AACA;AACA;AACE,MAAIoF,UAAU,GAAG,UAAjB;AACA,MAAI/D,CAAJ;AAEA;;AACA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAI,EAAjB,EAAqBA,CAAC,IAAI+D,UAAU,MAAM,CAA1C,EAA6C;AAC3C,QAAKA,UAAU,GAAG,CAAd,IAAqBpF,CAAC,CAACoC,SAAF,CAAYf,CAAC,GAAG,CAAhB;AAAkB;AAAlB,QAAgC,CAAzD,EAA6D;AAC3D,aAAO5E,QAAP;AACD;AACF;AAED;;;AACA,MAAIuD,CAAC,CAACoC,SAAF,CAAY,IAAI,CAAhB;AAAkB;AAAlB,MAAgC,CAAhC,IAAqCpC,CAAC,CAACoC,SAAF,CAAY,KAAK,CAAjB;AAAmB;AAAnB,MAAiC,CAAtE,IACApC,CAAC,CAACoC,SAAF,CAAY,KAAK,CAAjB;AAAmB;AAAnB,MAAiC,CADrC,EACwC;AACtC,WAAO1F,MAAP;AACD;;AACD,OAAK2E,CAAC,GAAG,EAAT,EAAaA,CAAC,GAAG/D,QAAjB,EAA2B+D,CAAC,EAA5B,EAAgC;AAC9B,QAAIrB,CAAC,CAACoC,SAAF,CAAYf,CAAC,GAAG,CAAhB;AAAkB;AAAlB,QAAgC,CAApC,EAAuC;AACrC,aAAO3E,MAAP;AACD;AACF;AAED;AACF;AACA;;;AACE,SAAOD,QAAP;AACD,CA9BD;;AAiCA,IAAI4I,gBAAgB,GAAG,KAAvB;AAEA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAItF,CAAD,IACjB;AAEE,MAAI,CAACqF,gBAAL,EAAuB;AACrBnD,IAAAA,cAAc;AACdmD,IAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAEDrF,EAAAA,CAAC,CAAC2E,MAAF,GAAY,IAAIlF,QAAJ,CAAaO,CAAC,CAACoC,SAAf,EAA0B9C,aAA1B,CAAZ;AACAU,EAAAA,CAAC,CAAC4E,MAAF,GAAY,IAAInF,QAAJ,CAAaO,CAAC,CAACqC,SAAf,EAA0B9C,aAA1B,CAAZ;AACAS,EAAAA,CAAC,CAAC6E,OAAF,GAAY,IAAIpF,QAAJ,CAAaO,CAAC,CAACsC,OAAf,EAAwB9C,cAAxB,CAAZ;AAEAQ,EAAAA,CAAC,CAACO,MAAF,GAAW,CAAX;AACAP,EAAAA,CAAC,CAACM,QAAF,GAAa,CAAb;AAEA;;AACA6B,EAAAA,UAAU,CAACnC,CAAD,CAAV;AACD,CAjBD;AAoBA;AACA;AACA;;;AACA,MAAMuF,gBAAgB,GAAG,CAACvF,CAAD,EAAInD,GAAJ,EAAS2I,UAAT,EAAqBC,IAArB,KACzB;AACA;AACA;AACA;AACA;AACErF,EAAAA,SAAS,CAACJ,CAAD,EAAI,CAAChD,YAAY,IAAI,CAAjB,KAAuByI,IAAI,GAAG,CAAH,GAAO,CAAlC,CAAJ,EAA0C,CAA1C,CAAT;AAA0D;;AAC1D/C,EAAAA,UAAU,CAAC1C,CAAD,EAAInD,GAAJ,EAAS2I,UAAT,EAAqB,IAArB,CAAV;AAAsC;AACvC,CARD;AAWA;AACA;AACA;AACA;;;AACA,MAAME,SAAS,GAAI1F,CAAD,IAAO;AACvBI,EAAAA,SAAS,CAACJ,CAAD,EAAI/C,YAAY,IAAI,CAApB,EAAuB,CAAvB,CAAT;AACAuD,EAAAA,SAAS,CAACR,CAAD,EAAIlC,SAAJ,EAAeU,YAAf,CAAT;AACAsC,EAAAA,QAAQ,CAACd,CAAD,CAAR;AACD,CAJD;AAOA;AACA;AACA;AACA;;;AACA,MAAM2F,eAAe,GAAG,CAAC3F,CAAD,EAAInD,GAAJ,EAAS2I,UAAT,EAAqBC,IAArB,KACxB;AACA;AACA;AACA;AACA;AACE,MAAIG,QAAJ,EAAcC,WAAd;AAA4B;;AAC5B,MAAInB,WAAW,GAAG,CAAlB;AAA4B;;AAE5B;;AACA,MAAI1E,CAAC,CAAC8F,KAAF,GAAU,CAAd,EAAiB;AAEf;AACA,QAAI9F,CAAC,CAAC+F,IAAF,CAAOC,SAAP,KAAqBrJ,SAAzB,EAAoC;AAClCqD,MAAAA,CAAC,CAAC+F,IAAF,CAAOC,SAAP,GAAmBb,gBAAgB,CAACnF,CAAD,CAAnC;AACD;AAED;;;AACA+D,IAAAA,UAAU,CAAC/D,CAAD,EAAIA,CAAC,CAAC2E,MAAN,CAAV,CARe,CASf;AACA;;AAEAZ,IAAAA,UAAU,CAAC/D,CAAD,EAAIA,CAAC,CAAC4E,MAAN,CAAV,CAZe,CAaf;AACA;;AACA;AACJ;AACA;;AAEI;AACJ;AACA;;AACIF,IAAAA,WAAW,GAAGD,aAAa,CAACzE,CAAD,CAA3B;AAEA;;AACA4F,IAAAA,QAAQ,GAAI5F,CAAC,CAAC8B,OAAF,GAAY,CAAZ,GAAgB,CAAjB,KAAwB,CAAnC;AACA+D,IAAAA,WAAW,GAAI7F,CAAC,CAAC+B,UAAF,GAAe,CAAf,GAAmB,CAApB,KAA2B,CAAzC,CA1Be,CA4Bf;AACA;AACA;;AAEA,QAAI8D,WAAW,IAAID,QAAnB,EAA6B;AAAEA,MAAAA,QAAQ,GAAGC,WAAX;AAAyB;AAEzD,GAlCD,MAkCO;AACL;AACAD,IAAAA,QAAQ,GAAGC,WAAW,GAAGL,UAAU,GAAG,CAAtC;AAAyC;AAC1C;;AAED,MAAKA,UAAU,GAAG,CAAb,IAAkBI,QAAnB,IAAiC/I,GAAG,KAAK,CAAC,CAA9C,EAAkD;AAChD;;AAEA;AACJ;AACA;AACA;AACA;AACA;AACI0I,IAAAA,gBAAgB,CAACvF,CAAD,EAAInD,GAAJ,EAAS2I,UAAT,EAAqBC,IAArB,CAAhB;AAED,GAXD,MAWO,IAAIzF,CAAC,CAACiG,QAAF,KAAezJ,OAAf,IAA0BqJ,WAAW,KAAKD,QAA9C,EAAwD;AAE7DxF,IAAAA,SAAS,CAACJ,CAAD,EAAI,CAAC/C,YAAY,IAAI,CAAjB,KAAuBwI,IAAI,GAAG,CAAH,GAAO,CAAlC,CAAJ,EAA0C,CAA1C,CAAT;AACAjC,IAAAA,cAAc,CAACxD,CAAD,EAAIxB,YAAJ,EAAkBE,YAAlB,CAAd;AAED,GALM,MAKA;AACL0B,IAAAA,SAAS,CAACJ,CAAD,EAAI,CAAC9C,SAAS,IAAI,CAAd,KAAoBuI,IAAI,GAAG,CAAH,GAAO,CAA/B,CAAJ,EAAuC,CAAvC,CAAT;AACAX,IAAAA,cAAc,CAAC9E,CAAD,EAAIA,CAAC,CAAC2E,MAAF,CAAS/E,QAAT,GAAoB,CAAxB,EAA2BI,CAAC,CAAC4E,MAAF,CAAShF,QAAT,GAAoB,CAA/C,EAAkD8E,WAAW,GAAG,CAAhE,CAAd;AACAlB,IAAAA,cAAc,CAACxD,CAAD,EAAIA,CAAC,CAACoC,SAAN,EAAiBpC,CAAC,CAACqC,SAAnB,CAAd;AACD,GAhEH,CAiEE;;AACA;AACF;AACA;;;AACEF,EAAAA,UAAU,CAACnC,CAAD,CAAV;;AAEA,MAAIyF,IAAJ,EAAU;AACRhD,IAAAA,SAAS,CAACzC,CAAD,CAAT;AACD,GAzEH,CA0EE;AACA;;AACD,CAjFD;AAmFA;AACA;AACA;AACA;;;AACA,MAAMkG,SAAS,GAAG,CAAClG,CAAD,EAAIF,IAAJ,EAAU6D,EAAV,KAClB;AACA;AACA;AACA;AACE;AAEA3D,EAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC6D,KAAF,GAAU7D,CAAC,CAACuC,QAAF,GAAa,CAArC,IAA+CzC,IAAI,KAAK,CAAV,GAAe,IAA7D;AACAE,EAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC6D,KAAF,GAAU7D,CAAC,CAACuC,QAAF,GAAa,CAAvB,GAA2B,CAAzC,IAA8CzC,IAAI,GAAG,IAArD;AAEAE,EAAAA,CAAC,CAACE,WAAF,CAAcF,CAAC,CAAC8D,KAAF,GAAU9D,CAAC,CAACuC,QAA1B,IAAsCoB,EAAE,GAAG,IAA3C;AACA3D,EAAAA,CAAC,CAACuC,QAAF;;AAEA,MAAIzC,IAAI,KAAK,CAAb,EAAgB;AACd;AACAE,IAAAA,CAAC,CAACoC,SAAF,CAAYuB,EAAE,GAAG,CAAjB,EAAmB,SAAnB;AACD,GAHD,MAGO;AACL3D,IAAAA,CAAC,CAACwC,OAAF;AACA;;AACA1C,IAAAA,IAAI;AAAgB;AACpB;AACA;AACA;;AAEAE,IAAAA,CAAC,CAACoC,SAAF,CAAY,CAACxD,YAAY,CAAC+E,EAAD,CAAZ,GAAmBrG,QAAnB,GAA8B,CAA/B,IAAoC,CAAhD,EAAkD,SAAlD;AACA0C,IAAAA,CAAC,CAACqC,SAAF,CAAYxC,MAAM,CAACC,IAAD,CAAN,GAAe,CAA3B,EAA6B,SAA7B;AACD,GAtBH,CAwBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEE,SAAQE,CAAC,CAACuC,QAAF,KAAevC,CAAC,CAACmG,WAAF,GAAgB,CAAvC;AACA;AACF;AACA;AACA;AACC,CAxDD;;AA0DAC,MAAM,CAACC,OAAP,CAAef,QAAf,GAA2BA,QAA3B;AACAc,MAAM,CAACC,OAAP,CAAed,gBAAf,GAAkCA,gBAAlC;AACAa,MAAM,CAACC,OAAP,CAAeV,eAAf,GAAkCA,eAAlC;AACAS,MAAM,CAACC,OAAP,CAAeH,SAAf,GAA2BA,SAA3B;AACAE,MAAM,CAACC,OAAP,CAAeX,SAAf,GAA2BA,SAA3B","sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH    = 3;\nconst MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES       = 30;\n/* number of distance codes */\n\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nconst MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) =>\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nconst copy_block = (s, buf, len, header) =>\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n  s.pending += len;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) =>\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) =>\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let lx = 0;         /* running index in l_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) =>\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) =>\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) =>\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let black_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nconst _tr_flush_block = (s, buf, stored_len, last) =>\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally = (s, dist, lc) =>\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //let out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n};\n\nmodule.exports._tr_init  = _tr_init;\nmodule.exports._tr_stored_block = _tr_stored_block;\nmodule.exports._tr_flush_block  = _tr_flush_block;\nmodule.exports._tr_tally = _tr_tally;\nmodule.exports._tr_align = _tr_align;\n"]},"metadata":{},"sourceType":"script"}